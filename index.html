<!DOCTYPE html>
<html lang="fr">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="author" content="G.G. Paterne" />
	<meta name="description" content="Cours complet Git avec fonctionnalités avancées">
	<title>Cours Complet Git - G.G. Paterne</title>

	<!-- MDB CSS (Material Design for Bootstrap) -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/8.1.0/mdb.min.css" />
	<!-- Prism.js CSS pour coloration syntaxique -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
	<!-- Font Awesome (icônes) -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" />
	<!-- Custom CSS -->
	<link rel="stylesheet" href="styles.css" />
</head>

<body>

	<!-- Barre de progression -->
	<div id="readingProgress"></div>

	<!-- Barre top mobile -->
	<nav class="navbar navbar-light bg-light d-md-none" id="menuTopBar">
		<div class="container-fluid">
			<!-- Titre / Logo -->
			<span class="navbar-brand fw-bold">Cours Git</span>

			<!-- Bouton Hamburger -->
			<button class="navbar-toggler" type="button" id="hamburgerBtn" style="border:none; background:none;">
				<i class="fas fa-bars"></i>
			</button>
		</div>
	</nav>

	<!-- Menu Table des Matières (Responsive) -->
	<nav id="navbarTOC">
		<h5>Table des Matières</h5>
		<a href="#introduction">1. Introduction</a>
		<a href="#installation">2. Installation & Config</a>
		<a href="#depots">3. Dépôts</a>
		<a href="#modifications">4. Suivi & Commit</a>
		<a href="#branches">5. Branches</a>
		<a href="#fusion">6. Merge & Conflits</a>
		<a href="#rebase">7. Rebase</a>
		<a href="#comparaison">8. Comparaison & Analyse</a>
		<a href="#annuler">9. Annuler/Commits</a>
		<a href="#stash">10. Stash</a>
		<a href="#depots-distants">11. Distants & Collab</a>
		<a href="#tags">12. Tags</a>
		<a href="#submodules">13. Submodules</a>
		<a href="#avancees">14. Avancées & Utilitaires</a>
		<a href="#bonnes-pratiques">15. Bonnes Pratiques</a>
		<a href="#commandes-avancees-git">16. Commandes Avancées de Git</a>
		<a href="#tableau-commands">17. Tableau Complet</a>
		<a href="#exemples">18. Exemples Concrets</a>
		<a href="#exercices-pieges">19. Exercices & Pièges</a>
		<a href="#commit-conventions">20. Conventions Commit</a>
		<a href="#github-actions">21. CI/CD GitHub</a>
		<a href="#glossaire">22. Glossaire Git</a>
		<a href="#conclusion">23. Conclusion</a>
		<a href="#workflows">24. Git Workflows</a>
		<a href="#hooks-git">25. Hooks Git</a>
		<a href="#gitattributes">26. Fins de Ligne & .gitattributes</a>
		<a href="#git-rerere">27. `git rerere`</a>
		<a href="#collaboration-plateformes">28. Collaboration Avancée sur Plateformes</a>

		<hr />
		<button class="btn btn-sm btn-dark" id="toggleDarkMode">Dark Mode</button>
	</nav>


	<!-- Contenu principal (décalé par rapport au menu) -->
	<div class="contentWithToc">

		<!-- Hero -->
		<div class="hero">
			<div class="container">
				<h1 class="fw-bold">Apprendre à utiliser les commandes Git</h1>
				<p class="fst-italic">Par <strong>G.G. Paterne</strong></p>
			</div>
		</div>

		<div class="container my-4">

			<!-- Recherche code -->
			<input type="text" class="form-control" id="searchBar" placeholder="Filtrer les snippets de code…" />

			<!-- (1) INTRODUCTION -->
			<section id="introduction" class="mb-4">
				<div class="card shadow-sm">
					<h2 class="card-header text-primary">1. Introduction à Git</h2>
					<div class="card-body">
						<h3>Qu’est-ce que Git ?</h3>
						<p>
							Git est un outil (logiciel) pour suivre les changements dans le code.
							Il permet de créer un historique de toutes les modifications.
							On peut aussi travailler à plusieurs dessus, sans se marcher sur les pieds.
						</p>
						<p><strong>Pourquoi utiliser Git ?</strong></p>
						<ul>
							<li>Revenir à une version antérieure si on casse quelque chose.</li>
							<li>Travailler à plusieurs sur le même projet, mais sur différentes branches.</li>
							<li>Garder un historique de tous les commits (changements).</li>
						</ul>


						<!-- Bouton de téléchargement -->
						<a href="Apprendre-git-par-la-pratique.pdf" class="btn btn-primary mt-3" download="CoursCompletGit">
							<i class="fas fa-download"></i>Télécharger le cours complet (PDF)
						</a>
					</div>
				</div>
			</section>

			<!-- (2) INSTALLATION & CONFIG -->
			<section id="installation" class="mb-4">
				<div class="card shadow-sm">
					<h2 class="card-header text-primary">2. Installation et configuration</h2>
					<div class="card-body">
						<h3>Installation</h3>
						<p>
							Pour utiliser Git, on doit l’installer sur l’ordinateur.
							Sur Linux Ubuntu/Debian, on peut faire :
						</p>
						<p>
							Sur Windows ou Mac, on peut télécharger l’installeur sur le site officiel :
							<a href="https://git-scm.com/download" target="_blank">https://git-scm.com/download</a>
						</p>

					<pre class="language-bash">

				<button class="btn btn-light copy-btn">Copier</button>
	<code>
	sudo apt update
	sudo apt install git
	</code>
	</pre>

				<p>Ces deux commandes mettent à jour la liste des paquets et installent Git.</p>


				<h3>Configuration globale</h3>
				<p>Donner son nom et email pour que Git sache qui fait les commits :</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git config --global user.name "Votre Nom"
	git config --global user.email "votre.email@example.com"</code>
	</pre>
				<p>On peut choisir son éditeur préféré, comme nano ou vim :</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git config --global core.editor "nano"</code>
	</pre>
				<p>
					Cette commande configure nano comme éditeur par défaut.
				</p>
				<p>Pour voir toutes les configs :</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git config --list</code>
	</pre>
					</div>
				</div>
			</section>

			<!-- (3) DEPOTS -->
			<section id="depots" class="mb-4">
				<div class="card shadow-sm">

					<h2 class="card-header text-primary">3. Initialiser et gérer un dépôt</h2>
					<div class="card-body">
						<h3>Initialiser un nouveau dépôt</h3>
						<p>
							Pour commencer à suivre un projet avec Git, on fait :
						</p>
						<pre class="language-bash">
						<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git init</code>
	</pre>
				<p>
					Cela crée un dossier caché <code>.git</code> qui contient toutes les infos de suivi (commits,
					historique...).
				</p>

				<h3>Cloner un dépôt existant</h3>
				<p>
					Si un projet existe déjà sur GitHub ou ailleurs, on peut le copier localement :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git clone https://github.com/utilisateur/projet.git</code>
	</pre>
				<p>
					Cela crée un dossier avec tout le code et l’historique.
				</p>

				<h3>Ajouter un dépôt distant</h3>
				<p>
					Pour lier son dossier local à un dépôt en ligne (ex: GitHub), on utilise :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git remote add origin https://github.com/utilisateur/projet.git</code>
	</pre>

				<h3>Lister / Renommer / Supprimer un dépôt distant</h3>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git remote -v              # Voir les dépôts distants
	git remote rename origin old   # Renommer 'origin' en 'old'
	git remote remove origin       # Supprimer le remote 'origin'</code>
	</pre>
					</div>
				</div>
			</section>

			<!-- (4) SUIVI & COMMIT -->
			<section id="modifications" class="mb-4">
				<div class="card shadow-sm">
					<div class="card-body">
						<h2 class="card-header text-primary">4. Suivi et validation des modifications</h2>
						<h3>Vérifier l'état</h3>
						<p>Pour voir quels fichiers sont modifiés ou non suivis :</p>
						<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git status</code>
	</pre>

						<h3>Ajouter des fichiers</h3>
						<p>
							Avant de faire un commit, on doit ajouter les fichiers dans la “zone de staging” :
						</p>
						<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git add fichier.txt
	git add .</code>
	</pre>
						<p>
							Le premier ajoute un seul fichier, le second ajoute tout ce qui est modifié/nouveau.
						</p>

						<h3>Créer un commit</h3>
						<p>
							Pour enregistrer définitivement les changements dans l’historique :
						</p>
						<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git commit -m "Description du changement"</code>
	</pre>
						<p>On peut tout faire d’un coup (pour les fichiers déjà suivis) : <code>git commit -am "message"</code>
						</p>

						<h3>Afficher l’historique</h3>
						<p>Voir la liste de tous les commits déjà faits :</p>
						<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git log
	git log --oneline
	git log --graph --decorate --oneline</code>
	</pre>
					</div>
				</div>
			</section>

			<!-- (5) BRANCHES -->
			<section id="branches" class="mb-4">
				<div class="card shadow-sm">
					<h2 class="card-header text-primary">5. Branches et navigation</h2>
					<div class="card-body">
						<h3>Créer et lister</h3>
						<p>Pour voir ou créer une branche :</p>
						<pre class="language-bash">
						<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git branch
	git branch nouvelle-branche</code>
	</pre>

				<h3>Changer de branche</h3>
				<p>On se déplace sur une branche existante :</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git checkout nouvelle-branche</code>
	</pre>
				<p>Ou on la crée et on y va d’un coup :</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git checkout -b nouvelle-branche</code>
	</pre>

				<h3>Renommer / Supprimer une branche</h3>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git branch -m ancien_nom nouveau_nom   # Renommer
	git branch -d branche            # Supprimer une branche fusionnée
	git branch -D branche            # Supprimer quand pas fusionnée</code>
	</pre>
					</div>
				</div>
			</section>

			<!-- (6) MERGE & CONFLITS -->
			<section id="fusion">
				<h2 class="card-header text-primary">6. Merge (Fusion) et Conflits</h2>
				<h3>Fusionner deux branches</h3>
				<p>
					On se place sur la branche où on veut intégrer les changements (souvent main ou master), puis on
					merge :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git checkout main
	git merge nouvelle-branche</code>
	</pre>

				<h3>Conflits</h3>
				<p>
					S’il y a des conflits, Git arrête le merge et on doit résoudre à la main :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git add fichier_conflit.txt
	git commit -m "Résolution du conflit"</code>
	</pre>

				<h3>Merge “no fast-forward”</h3>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git merge --no-ff nouvelle-branche</code>
	</pre>
				<p>
					Crée un commit de merge même si on peut faire un fast-forward, pour garder une trace.
				</p>
			</section>

			<!-- (7) REBASE -->
			<section id="rebase">
				<h2 class="card-header text-primary">7. Rebase (Réécriture de l’historique)</h2>
				<p>
					La commande <code>git rebase</code> permet de réécrire l'historique du dépôt en appliquant une série de commits sur une nouvelle base. Cela permet d'avoir un historique plus linéaire et propre, de résoudre les conflits de fusion, et de simplifier l'intégration des modifications avec d'autres branches. Cela permet d’obtenir un historique plus <em>linéaire</em> et lisible, en évitant les commits de fusion inutiles. Elle est particulièrement utile pour intégrer les dernières modifications d’une branche (ex. : <code>main</code>) dans votre branche de développement.
					<br><br><strong>Note :</strong> Le rebase modifie l'historique de votre dépôt, vous devez être sur une branche sans commits non publiés pour utiliser le rebase.'
				</p>

				<p>
					<strong>Attention :</strong> N’effectuez pas de rebase sur des branches déjà poussées sur un dépôt partagé, car cela réécrit l’historique et peut perturber le travail de vos collègues. Il est recommandé de tester ces opérations sur des dépôts de test ou des branches locales avant de les utiliser en production.
				</p>

				Voici quelques avantages de rebase :<br>
				<ul>
					<li>Simplifie l'historique : rebase permet de mettre à jour l'historique en appliquant les modifications sur une nouvelle base, ce qui rend l'historique plus facile à comprendre et à analyser.</li>
					<li>Résout les conflits : rebase permet de résoudre les conflits de fusion en modifiant les fichiers conflictueux et en créant de nouveaux commits.</li>
					<li>Simplifie l'intégration : rebase permet de simplifier l'intégration des modifications avec d'autres branches en appliquant les modifications sur une nouvelle base, ce qui facilite la résolution des conflits et la fusion des branches.</li>
				</ul>

				<h3>Rebase simple</h3>
				<p>
					Pour mettre à jour votre branche <code>ma-branche</code> avec les derniers commits de <code>main</code>, exécutez :
				</p>
				<pre class="language-bash">
			<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git checkout ma-branche
	git rebase main
	</code>
		</pre>
				<p>
					<strong>Exemple :</strong> Si vous travaillez sur une branche <code>feature</code> et que des modifications ont été apportées sur <code>main</code>, cette commande permet de réappliquer vos commits de <code>feature</code> au-dessus des derniers commits de <code>main</code>.
				</p>

				<h3>Gestion des conflits lors d'un rebase</h3>
				<p>
					Si des conflits surviennent pendant le rebase, Git interrompt l’opération pour que vous puissiez les résoudre. La procédure est la suivante :
				</p>
				<ul>
					<li>
						<strong>Identifier et résoudre le conflit :</strong> Ouvrez le(s) fichier(s) concerné(s) et modifiez les sections marquées par <code>&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code> et <code>&gt;&gt;&gt;&gt;&gt;&gt;</code> pour choisir le contenu approprié.
					</li>
					<li>
						<strong>Ajouter le fichier résolu :</strong>
						<pre class="language-bash">
			<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git add fichier_conflit.txt
	</code>
				</pre>
					</li>
					<li>
						<strong>Poursuivre le rebase :</strong>
						<pre class="language-bash">
			<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git rebase --continue
	</code>
				</pre>
					</li>
					<li>
						<strong>Annuler le rebase :</strong> Si nécessaire, vous pouvez abandonner le rebase en cours avec :
						<pre class="language-bash">
			<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git rebase --abort
	</code>
				</pre>
					</li>
				</ul>

				<h3>Rebase interactif</h3>
				<p>
					Le rebase interactif vous permet de modifier l’ordre des commits, de fusionner plusieurs commits (squash), de modifier leurs messages ou même de supprimer des commits. C’est une technique puissante pour nettoyer l’historique avant de fusionner une branche.
				</p>
				<pre class="language-bash">
			<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git rebase -i HEAD~3
	</code>
		</pre>
				<p>
					Lancez cette commande depuis votre branche de développement. Un éditeur s’ouvrira avec une liste des 3 derniers commits, par exemple :
				</p>
				<pre class="language-text">
			<button class="btn btn-light copy-btn">Copier</button>
	<code>
	pick abc1234 Premier commit de la feature
	squash def5678 Second commit à fusionner avec le premier
	pick ghi9012 Troisième commit
	</code>
		</pre>
				<p>
					Modifiez les mots-clés selon vos besoins (<code>pick</code>, <code>squash</code>, <code>reword</code>, etc.), sauvegardez et fermez l’éditeur. Git fusionnera alors les commits indiqués et vous demandera de confirmer ou modifier le message final.
				</p>

				<h3>Options avancées</h3>
				<ul>
					<li>
						<strong>Utilisation de <code>--onto</code> :</strong>
						<p>
							Permet de repositionner une série de commits sur une nouvelle base, différente du parent direct. Par exemple, pour déplacer tous les commits de <code>feature</code> qui ne sont pas dans <code>base</code> sur <code>nouvelle-base</code> :
						</p>
						<pre class="language-bash">
			<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git checkout feature
	git rebase --onto nouvelle-base base feature
	</code>
				</pre>
					</li>
					<li>
						<strong>Résolution automatique avec <code>-Xours</code> ou <code>-Xtheirs</code> :</strong>
						<p>
							Ces options permettent de résoudre automatiquement les conflits en privilégiant votre version (<code>ours</code>) ou celle de la branche sur laquelle vous rebasez (<code>theirs</code>).
							<em>Exemple :</em>
						</p>
						<pre class="language-bash">
			<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git rebase -Xtheirs main
	</code>
				</pre>
					</li>
					<li>
						<strong>Conservation des commits de fusion :</strong>
						<p>
							Par défaut, le rebase "aplati" l’historique en supprimant les commits de fusion. Pour conserver la topologie des fusions, utilisez l’option <code>--rebase-merges</code> :
						</p>
						<pre class="language-bash">
			<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git rebase --rebase-merges main
	</code>
				</pre>
					</li>
				</ul>

				<p>
					<strong>Attention :</strong> N’effectuez pas de rebase sur des branches déjà poussées sur un dépôt partagé, car cela réécrit l’historique et peut perturber le travail de vos collègues. Il est recommandé de tester ces opérations sur des dépôts de test ou des branches locales avant de les utiliser en production.
				</p>
			</section>


			<!-- (8) COMPARAISON & ANALYSE -->
			<section id="comparaison">
				<h2 class="card-header text-primary">8. Comparaison & Analyse</h2>
				<p>
					Quelques commandes utiles pour comparer ou analyser l’historique :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git diff                # Voir ce qui a changé avant commit
	git diff --staged       # Voir ce qui est prêt à commit
	git blame fichier       # Savoir qui a modifié chaque ligne
	git bisect start        # Commencer la recherche binaire d’un bug
	git bisect bad HEAD
	git bisect good <commit_ou_tag>
	git log -p              # Voir les changements en détail par commit
	</code>
	</pre>
			</section>

			<!-- (9) ANNULER/COMMITS -->
			<section id="annuler">
				<h2 class="card-header text-primary">9. Annuler ou corriger des commits</h2>
				<h3>Revert</h3>
				<p>
					Crée un commit inverse pour annuler un commit précédent :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git revert <commit_hash></code>
	</pre>

				<h3>Reset</h3>
				<p>
					Reculer dans l’historique, avec la possibilité de garder ou non les changements :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	# Garde les modifs mais enlève le commit
	git reset --soft HEAD~1

	# Efface complètement les modifs du dernier commit
	git reset --hard HEAD~1</code>
	</pre>

				<h3>Amend</h3>
				<p>
					Pour modifier le dernier commit (changer son message ou ajouter un fichier oublié) :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git commit --amend</code>
	</pre>
			</section>

			<!-- (10) STASH -->
			<section id="stash">
				<h2 class="card-header text-primary">10. Stash : mettre de côté des modifs</h2>
				<p>
					On peut sauvegarder temporairement son travail sans faire de commit final :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git stash
	git stash list
	git stash pop
	git stash apply</code>
	</pre>
			</section>

			<!-- (11) DISTANTS & COLLAB -->
			<section id="depots-distants">
				<h2 class="card-header text-primary">11. Dépôts Distants & Collaboration</h2>
				<p>
					Quelques commandes pour synchroniser avec un serveur (GitHub, GitLab…) :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git fetch
	git pull
	git push
	git push -u origin branche</code>
	</pre>
				<p>
					<strong>Fork & Pull Request :</strong> sur GitHub, vous pouvez forker un repo, faire vos modifs,
					puis ouvrir une Pull Request pour proposer vos changements au projet d’origine.
				</p>
			</section>

			<!-- (12) TAGS -->
			<section id="tags">
				<h2 class="card-header text-primary">12. Gestion des tags</h2>
				<p>
					Les tags servent souvent à marquer des versions (v1.0, v2.0…).
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git tag
	git tag -a v1.0 -m "Version stable"
	git push origin --tags</code>
	</pre>
			</section>

			<!-- (13) SUBMODULES -->
			<section id="submodules">
				<h2 class="card-header text-primary">13. Submodules (Sous-modules)</h2>
				<p>
					On peut inclure un autre dépôt Git à l’intérieur du nôtre (ex: librairie partagée).
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git submodule add <URL>
	git submodule init
	git submodule update</code>
	</pre>
			</section>

			<!-- (14) AVANCEES & UTILITAIRES -->
			<section id="avancees">
				<h2 class="card-header text-primary">14. Commandes avancées & utilitaires</h2>
				<p>
					Voici quelques commandes plus “spéciales” :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git cherry-pick <commit>      # Prendre un commit précis d’une autre branche
	git reflog                  # Historique caché de toutes les actions
	git gc                      # Nettoyer et compresser le repo
	git archive --format=zip HEAD > code.zip  # Exporter le code sans l'historique
	git shortlog               # Liste des commits regroupés par auteur
	</code>
	</pre>
			</section>

			<!-- (15) BONNES PRATIQUES -->
			<section id="bonnes-pratiques">
				<h2 class="card-header text-primary">15. Bonnes pratiques</h2>
				<ol>
					<li>Commits fréquents & atomiques (petites étapes faciles à comprendre).</li>
					<li>Messages de commit clairs (expliquez “pourquoi” et pas juste “ce qui a changé”).</li>
					<li>Utiliser des branches descriptives (ex: <code>feature/login</code>, <code>fix/bug-42</code>).
					</li>
					<li>Revue de code via Pull Requests (pour un avis extérieur, moins de bugs). </li>
					<li>Éviter de réécrire l’historique partagé (risque de casser le repo de l’équipe). </li>
					<li>Maintenir un <code>.gitignore</code> (exclure fichiers inutiles, logs, etc.). </li>
				</ol>
			</section>

			<!-- (16) COMMANDES AVANCÉES DE GIT -->
			<section id="commandes-avancees-git">
				<h2 class="card-header text-primary">16. Les Commandes Avancées de Git</h2>
				<p>
					Git propose de nombreuses commandes avancées permettant de gérer finement l’historique du dépôt, de résoudre des problèmes complexes ou d’automatiser certaines tâches. Voici quelques-unes de ces commandes avec leurs explications détaillées :
				</p>

				<h3>1. Git Rebase</h3>
				<p>
					<strong>Description :</strong> La commande <code>git rebase</code> permet de déplacer ou réappliquer une série de commits sur une nouvelle base, offrant ainsi un historique plus linéaire et propre.
				</p>
				<p><strong>Utilisations avancées :</strong></p>
				<ul>
					<li>
						<em>Rebase simple :</em> Pour mettre à jour une branche de fonctionnalité avec les dernières modifications de la branche principale :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git checkout featureA
	git rebase main
	</code>
		  </pre>
					</li>
					<li>
						<em>Rebase interactif :</em> Permet de modifier l’ordre des commits, de fusionner (squash), de réordonner ou supprimer certains commits. Par exemple :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git rebase -i HEAD~3
	</code>
		  </pre>
						Dans l’éditeur, vous pourriez voir :
						<pre class="language-text">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	pick abc1234 Premier commit de la feature
	squash def5678 Deuxième commit à fusionner avec le premier
	pick ghi9012 Troisième commit
	</code>
		  </pre>
					</li>
				</ul>

				<h3>2. Git Cherry-pick</h3>
				<p>
					<strong>Description :</strong> <code>git cherry-pick</code> permet d’extraire un ou plusieurs commits spécifiques depuis une autre branche et de les appliquer sur la branche courante.
				</p>
				<p><strong>Utilisation typique :</strong> Par exemple, pour appliquer une correction critique directement sur la branche de production :</p>
				<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git checkout production
	git cherry-pick &lt;commit_hash&gt;
	</code>
	  </pre>

				<h3>3. Git Bisect</h3>
				<p>
					<strong>Description :</strong> <code>git bisect</code> est un outil de recherche dichotomique qui aide à identifier le commit précis ayant introduit un bug ou une régression.
				</p>
				<p><strong>Processus :</strong></p>
				<ol>
					<li>
						Démarrer la recherche :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git bisect start
	</code>
		  </pre>
					</li>
					<li>
						Marquer le commit avec le bug :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git bisect bad
	</code>
		  </pre>
					</li>
					<li>
						Marquer un commit fonctionnel :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git bisect good &lt;commit_hash&gt;
	</code>
		  </pre>
					</li>
					<li>
						Une fois identifié, réinitialiser le bisect :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git bisect reset
	</code>
		  </pre>
					</li>
				</ol>
				<p><em>Astuce :</em> Vous pouvez automatiser ce processus en créant un script de test retournant 0 en cas de succès et 1 en cas d’échec.</p>

				<h3>4. Git Stash</h3>
				<p>
					<strong>Description :</strong> La commande <code>git stash</code> sauvegarde temporairement des modifications non committées, permettant de nettoyer l’espace de travail sans perdre votre travail en cours.
				</p>
				<ul>
					<li>
						Sauvegarder avec un message :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git stash save "Travail en cours sur feature X"
	</code>
		  </pre>
					</li>
					<li>
						Lister les stashes :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git stash list
	</code>
		  </pre>
					</li>
					<li>
						Appliquer ou supprimer un stash spécifique :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git stash apply stash@{2}
	git stash drop stash@{2}
	</code>
		  </pre>
					</li>
				</ul>

				<h3>5. Git Reflog</h3>
				<p>
					<strong>Description :</strong> <code>git reflog</code> conserve l’historique des déplacements de <code>HEAD</code>, permettant de retrouver des commits "perdus" ou de revenir à un état antérieur.
				</p>
				<p><strong>Utilisation :</strong></p>
				<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git reflog
	</code>
	  </pre>
				<p>Pour revenir à un commit précis, par exemple :</p>
				<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git reset --hard HEAD@{3}
	</code>
	  </pre>

				<h3>6. Git Reset</h3>
				<p>
					<strong>Description :</strong> <code>git reset</code> modifie la position de <code>HEAD</code> et, selon l’option choisie, peut modifier l’index et le répertoire de travail.
				</p>
				<ul>
					<li>
						<em>Soft (--soft) :</em> Déplace <code>HEAD</code> sans modifier l’index ni le répertoire de travail :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git reset --soft &lt;commit_hash&gt;
	</code>
		  </pre>
					</li>
					<li>
						<em>Mixed (par défaut) :</em> Réinitialise l’index sans toucher au répertoire de travail :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git reset &lt;commit_hash&gt;
	</code>
		  </pre>
					</li>
					<li>
						<em>Hard (--hard) :</em> Réinitialise <code>HEAD</code>, l’index et le répertoire de travail, supprimant toutes les modifications non committées :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git reset --hard &lt;commit_hash&gt;
	</code>
		  </pre>
					</li>
				</ul>
				<p><em>Conseil :</em> Utilisez <code>--hard</code> avec précaution, surtout sur des branches partagées.</p>

				<h3>7. Git Clean</h3>
				<p>
					<strong>Description :</strong> <code>git clean</code> supprime les fichiers non suivis dans le répertoire de travail, permettant de nettoyer votre environnement.
				</p>
				<ul>
					<li>
						Voir ce qui sera supprimé (mode test) :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git clean -n
	</code>
		  </pre>
					</li>
					<li>
						Supprimer les fichiers non suivis :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git clean -f
	</code>
		  </pre>
					</li>
					<li>
						Supprimer également les répertoires non suivis :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git clean -fd
	</code>
		  </pre>
					</li>
				</ul>
				<p><em>Astuce :</em> Utilisez toujours l’option <code>-n</code> pour une simulation avant de supprimer définitivement.</p>

				<h3>8. Git Filter-branch et Git Filter-repo</h3>
				<p>
					<strong>Description :</strong> Ces commandes permettent de réécrire l’historique complet du dépôt, ce qui est utile pour supprimer des fichiers sensibles ou nettoyer l’historique.
				</p>
				<ul>
					<li>
						<em>git filter-branch :</em> Bien que puissant, il peut être lent et complexe pour de gros dépôts.
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch chemin/du/fichier' --prune-empty --tag-name-filter cat -- --all
	</code>
		  </pre>
					</li>
					<li>
						<em>git filter-repo :</em> Une alternative moderne et performante. Exemple pour supprimer un fichier de l’historique :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git filter-repo --path chemin/du/fichier --invert-paths
	</code>
		  </pre>
						<p><em>Astuce :</em> Sauvegardez toujours votre dépôt avant d’effectuer une réécriture historique.</p>
					</li>
				</ul>

				<h3>9. Git Submodule</h3>
				<p>
					<strong>Description :</strong> La commande <code>git submodule</code> permet d’intégrer et de gérer un dépôt Git externe au sein d’un projet, ce qui est utile pour gérer des dépendances ou bibliothèques de manière autonome.
				</p>
				<p><strong>Utilisation typique :</strong></p>
				<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git submodule add &lt;URL_du_dépôt&gt; chemin/destination
	git submodule update --init --recursive
	</code>
	  </pre>

				<h3>10. Git Worktree</h3>
				<p>
					<strong>Description :</strong> La commande <code>git worktree</code> permet de travailler simultanément sur plusieurs branches dans des répertoires distincts sans avoir à cloner le dépôt plusieurs fois.
				</p>
				<p><strong>Utilisation :</strong> Pour créer un nouveau worktree pour une branche :</p>
				<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git worktree add ../chemin/vers/nouveau_worktree featureX
	</code>
	  </pre>
				<p>
					<em>Avantages :</em> Tester ou développer sur une branche tout en gardant la branche principale intacte. Idéal pour des tests, builds ou débogages sur des versions parallèles.<br />
					<em>Conseil :</em> Pour revenir à la gestion normale, supprimez le worktree avec :
				</p>
				<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git worktree remove ../chemin/vers/nouveau_worktree
	</code>
	  </pre>

				<h3>Conclusion</h3>
				<p>
					Ces commandes avancées offrent une flexibilité considérable pour gérer l’historique, résoudre des problèmes complexes et optimiser votre flux de travail. Leur maîtrise vous permet de :
				</p>
				<ul>
					<li><strong>Gérer des workflows complexes :</strong> Adaptez l’historique avec <code>rebase</code>, <code>cherry-pick</code> et <code>reset</code>.</li>
					<li><strong>Identifier et corriger des erreurs :</strong> Utilisez <code>bisect</code> et <code>reflog</code> pour retrouver des commits problématiques.</li>
					<li><strong>Optimiser l’environnement de développement :</strong> Grâce à <code>stash</code>, <code>clean</code>, <code>submodule</code> et <code>worktree</code> pour maintenir un espace de travail organisé.</li>
				</ul>
				<p>
					En pratiquant ces commandes sur des dépôts de test, vous gagnerez en confiance et serez mieux préparé pour gérer des projets complexes.
				</p>
			</section>


			<!-- TABLEAU COMPLET DES COMMANDES -->
			<section id="tableau-commands">
				<div class="table-responsive mt-3">
					<h2 class="card-header text-primary">Tableau complet des commandes Git</h2>
					<p>Retrouvez ci-dessous un récapitulatif complet :</p>
					<div class="table-responsive mt-3">
						<table class="table table-bordered table-hover align-middle">
							<thead class="table-dark">
							<tr>
								<th>Commande</th>
								<th>Utilisation</th>
								<th>Explication</th>
								<th>Avantage ✅</th>
								<th>Inconvénient 🚨</th>
							</tr>
							</thead>
							<tbody>
							<!-- Liste COMPLETE (non tronquée) -->
							<tr>
								<td><strong>git init</strong></td>
								<td><code>git init</code></td>
								<td>Initialise un nouveau dépôt Git (création du dossier <code>.git/</code>).</td>
								<td>Démarrer facilement un nouveau projet.</td>
								<td>Crée un dépôt vide (peut nécessiter config/dépôt distant).</td>
							</tr>
							<tr>
								<td><strong>git clone</strong></td>
								<td><code>git clone URL [dossier]</code></td>
								<td>Copie un dépôt distant (ou local) dans un nouveau dossier.</td>
								<td>Récupération rapide d’un projet existant et de son historique.</td>
								<td>Peut être volumineux si le repo est très gros.</td>
							</tr>
							<tr>
								<td><strong>git remote add</strong></td>
								<td><code>git remote add &lt;nom&gt; &lt;URL&gt;</code></td>
								<td>Associe un dépôt distant (ex: <code>origin</code>) à l’URL spécifiée.</td>
								<td>Permet de pousser/puller vers un dépôt en ligne (GitHub...).</td>
								<td>Erreur possible si l’on se trompe d’URL.</td>
							</tr>
							<tr>
								<td><strong>git remote rename</strong></td>
								<td><code>git remote rename &lt;old&gt; &lt;new&gt;</code></td>
								<td>Renomme un dépôt distant (ex. <code>origin</code> → <code>oldorigin</code>).
								</td>
								<td>Clarifie le nom (en cas de multiples remotes).</td>
								<td>Scripts/CI peuvent être impactés si le nom change.</td>
							</tr>
							<tr>
								<td><strong>git remote remove</strong></td>
								<td><code>git remote remove &lt;nom&gt;</code></td>
								<td>Supprime un dépôt distant de la configuration Git.</td>
								<td>Nettoie la liste des remotes inutiles.</td>
								<td>Plus de push/pull possible vers ce remote si besoin.</td>
							</tr>
							<tr>
								<td><strong>git status</strong></td>
								<td><code>git status</code></td>
								<td>Affiche l’état des fichiers : suivis, non suivis, prêts à être commit, etc.</td>
								<td>Vue rapide et claire des changements.</td>
								<td>Aucun inconvénient majeur.</td>
							</tr>
							<tr>
								<td><strong>git add</strong></td>
								<td><code>git add fichier</code> / <code>git add .</code></td>
								<td>Ajoute des fichiers dans la zone de staging (préparation au commit).</td>
								<td>Contrôle précis sur ce qu’on veut commiter.</td>
								<td>Si on oublie un fichier, il ne sera pas dans le commit.</td>
							</tr>
							<tr>
								<td><strong>git commit</strong></td>
								<td><code>git commit -m "msg"</code></td>
								<td>Crée un instantané (commit) des changements validés.</td>
								<td>Construit l’historique avec un message descriptif.</td>
								<td>Un mauvais message gêne la compréhension de l’historique.</td>
							</tr>
							<tr>
								<td><strong>git commit -am</strong></td>
								<td><code>git commit -am "msg"</code></td>
								<td>Combine l’ajout et le commit pour les fichiers déjà suivis.</td>
								<td>Gain de temps pour modifications rapides.</td>
								<td>Ne gère pas les nouveaux fichiers non suivis.</td>
							</tr>
							<tr>
								<td><strong>git commit --amend</strong></td>
								<td><code>git commit --amend</code></td>
								<td>Modifie le dernier commit (message ou fichiers).</td>
								<td>Corrige un oubli ou un message trop vague.</td>
								<td>Réécrit l’historique, déconseillé si déjà poussé.</td>
							</tr>
							<tr>
								<td><strong>git log</strong></td>
								<td><code>git log</code>, <code>git log --oneline</code></td>
								<td>Affiche l’historique des commits (détaillé ou succinct).</td>
								<td>Bonne vision de l’évolution du projet.</td>
								<td>Peut être verbeux sur gros projets.</td>
							</tr>
							<tr>
								<td><strong>git checkout</strong></td>
								<td><code>git checkout &lt;branche&gt;</code> /
									<code>git checkout -- &lt;fichier&gt;</code></td>
								<td>Change de branche OU annule les modifs d’un fichier local.</td>
								<td>Navigation aisée entre branches.</td>
								<td>Perte possible de changements non commit si on oublie de stasher.</td>
							</tr>
							<tr>
								<td><strong>git branch</strong></td>
								<td><code>git branch &lt;nom&gt;</code></td>
								<td>Crée une branche ou liste les branches (si pas d’argument).</td>
								<td>Organise le travail (nouvelles fonctionnalités).</td>
								<td>Trop de branches peuvent créer la confusion.</td>
							</tr>
							<tr>
								<td><strong>git branch -m</strong></td>
								<td><code>git branch -m &lt;ancien&gt; &lt;nouveau&gt;</code></td>
								<td>Renomme une branche locale.</td>
								<td>Corrige un nom mal choisi.</td>
								<td>Peut troubler d’autres si la branche est partagée.</td>
							</tr>
							<tr>
								<td><strong>git branch -d</strong></td>
								<td><code>git branch -d &lt;nom&gt;</code></td>
								<td>Supprime une branche locale (fusionnée).</td>
								<td>Nettoyage des branches terminées.</td>
								<td>Impossible si non fusionnée (risque de perte).</td>
							</tr>
							<tr>
								<td><strong>git branch -D</strong></td>
								<td><code>git branch -D &lt;nom&gt;</code></td>
								<td>Supprime une branche locale sans vérification.</td>
								<td>Forcer la suppression d’une branche obsolète.</td>
								<td>Risque de perte définitive de commits.</td>
							</tr>
							<tr>
								<td><strong>git merge</strong></td>
								<td><code>git merge &lt;branche&gt;</code></td>
								<td>Fusionne la branche spécifiée dans la branche courante.</td>
								<td>Combine facilement plusieurs flux de travail.</td>
								<td>Peut générer des conflits, crée un commit de merge.</td>
							</tr>
							<tr>
								<td><strong>git merge --no-ff</strong></td>
								<td><code>git merge --no-ff &lt;branche&gt;</code></td>
								<td>Fusion sans fast-forward, garde un commit de merge dédié.</td>
								<td>Historique plus lisible (commit de merge conservé).</td>
								<td>Même si un fast-forward était possible, on force un commit supplémentaire.</td>
							</tr>
							<tr>
								<td><strong>git rebase</strong></td>
								<td><code>git rebase &lt;branche&gt;</code></td>
								<td>“Rejoue” les commits de la branche courante sur une autre branche.</td>
								<td>Historique linéaire et propre (pas de commit de merge).</td>
								<td>Réécrit l’historique (dangereux si partagé).</td>
							</tr>
							<tr>
								<td><strong>git rebase -i</strong></td>
								<td><code>git rebase -i HEAD~n</code></td>
								<td>Rebase interactif (modifier l’ordre, fusionner, renommer des commits).</td>
								<td>Historique très propre, possibilité de “squasher”.</td>
								<td>Complexe, risque de collisions ou pertes.</td>
							</tr>
							<tr>
								<td><strong>git rebase --continue</strong></td>
								<td><code>git rebase --continue</code></td>
								<td>Poursuit le rebase après résolution de conflit.</td>
								<td>Finalise le rebase proprement.</td>
								<td>Faut résoudre tous les conflits un par un.</td>
							</tr>
							<tr>
								<td><strong>git rebase --abort</strong></td>
								<td><code>git rebase --abort</code></td>
								<td>Annule le rebase en cours et revient à l’état initial.</td>
								<td>Utile si trop de conflits.</td>
								<td>Annule tout le travail du rebase.</td>
							</tr>
							<tr>
								<td><strong>git diff</strong></td>
								<td><code>git diff</code>, <code>git diff --staged</code></td>
								<td>Compare les différences non validées ou indexées.</td>
								<td>Repère précisément les lignes modifiées.</td>
								<td>Peut être long à lire sur gros projets.</td>
							</tr>
							<tr>
								<td><strong>git blame</strong></td>
								<td><code>git blame &lt;fichier&gt;</code></td>
								<td>Montre, ligne par ligne, qui a modifié le fichier et quand.</td>
								<td>Pratique pour attribuer un changement précis.</td>
								<td>Peu lisible si gros fichier avec multiples auteurs.</td>
							</tr>
							<tr>
								<td><strong>git bisect</strong></td>
								<td><code>git bisect start</code>, <code>git bisect bad</code>,
									<code>git bisect good</code></td>
								<td>Recherche binaire d’un commit fautif.</td>
								<td>Méthode puissante pour isoler un bug.</td>
								<td>Processus parfois long.</td>
							</tr>
							<tr>
								<td><strong>git revert</strong></td>
								<td><code>git revert &lt;commit&gt;</code></td>
								<td>Crée un commit annulant un autre commit.</td>
								<td>Historique conservé sans tout écraser.</td>
								<td>Peut allonger l’historique si nombreux revert.</td>
							</tr>
							<tr>
								<td><strong>git reset --soft</strong></td>
								<td><code>git reset --soft HEAD~1</code></td>
								<td>Reculer un commit en gardant les modifications dans le staging.</td>
								<td>Permet de refaire un commit propre.</td>
								<td>Réécrit l’historique (dangereux si déjà poussé).</td>
							</tr>
							<tr>
								<td><strong>git reset --hard</strong></td>
								<td><code>git reset --hard HEAD~1</code></td>
								<td>Reculer un commit en supprimant définitivement les modifs.</td>
								<td>Retour rapide à un état stable.</td>
								<td>Perte irréversible des changements.</td>
							</tr>
							<tr>
								<td><strong>git stash</strong></td>
								<td><code>git stash</code></td>
								<td>Met de côté les modifs non commitées.</td>
								<td>Utile pour passer sur une autre branche sans perdre son travail.</td>
								<td>On peut oublier les stash si on ne les liste pas.</td>
							</tr>
							<tr>
								<td><strong>git stash pop</strong></td>
								<td><code>git stash pop</code></td>
								<td>Récupère et supprime le dernier stash.</td>
								<td>Permet de reprendre rapidement son travail mis en attente.</td>
								<td>Conflits possibles si code très différent entre-temps.</td>
							</tr>
							<tr>
								<td><strong>git stash apply</strong></td>
								<td><code>git stash apply [stash@{n}]</code></td>
								<td>Applique un stash (sans le supprimer).</td>
								<td>Peut réutiliser plusieurs fois le même stash.</td>
								<td>Attention aux duplications si on l’applique plusieurs fois.</td>
							</tr>
							<tr>
								<td><strong>git stash list</strong></td>
								<td><code>git stash list</code></td>
								<td>Affiche la liste de tous les stashes mis de côté.</td>
								<td>Visualise rapidement les réserves de code.</td>
								<td>Pas d’inconvénient notable.</td>
							</tr>
							<tr>
								<td><strong>git fetch</strong></td>
								<td><code>git fetch [remote] [branche]</code></td>
								<td>Récupère les nouveautés sans les fusionner.</td>
								<td>Voir ce qui a changé avant d’intégrer.</td>
								<td>Étape supplémentaire (pull ou merge) pour la fusion finale.</td>
							</tr>
							<tr>
								<td><strong>git pull</strong></td>
								<td><code>git pull</code></td>
								<td>Récupère et fusionne directement les modifications du dépôt distant.</td>
								<td>Simple pour rester à jour.</td>
								<td>Peut engendrer des conflits si modifs simultanées.</td>
							</tr>
							<tr>
								<td><strong>git push</strong></td>
								<td><code>git push</code></td>
								<td>Envoie les commits locaux vers la branche distante.</td>
								<td>Partage facile avec l’équipe.</td>
								<td>Conflits possibles si historique local en retard.</td>
							</tr>
							<tr>
								<td><strong>git push -u</strong></td>
								<td><code>git push -u origin &lt;branche&gt;</code></td>
								<td>Pousse la branche locale et la configure avec le dépôt distant.</td>
								<td>Simplifie les futurs push/pull.</td>
								<td>Peut créer plusieurs branches distantes si mal utilisé.</td>
							</tr>
							<tr>
								<td><strong>git push --force</strong></td>
								<td><code>git push --force</code> ou <code>git push --force-with-lease</code></td>
								<td>Force la réécriture de l’historique distant.</td>
								<td>Utile après un rebase ou amend déjà poussé.</td>
								<td>Risque de perdre le travail d’autres contributeurs.</td>
							</tr>
							<tr>
								<td><strong>git tag</strong></td>
								<td><code>git tag &lt;nom&gt;</code></td>
								<td>Crée un tag léger (non annoté) sur le commit courant.</td>
								<td>Identifier rapidement une version.</td>
								<td>Pas de message ni métadonnées.</td>
							</tr>
							<tr>
								<td><strong>git tag -a</strong></td>
								<td><code>git tag -a v1.0 -m "message"</code></td>
								<td>Crée un tag annoté (avec message).</td>
								<td>Historique complet sur la version (auteur, date, message).</td>
								<td>Trop de tags peut devenir confus.</td>
							</tr>
							<tr>
								<td><strong>git push origin --tags</strong></td>
								<td><code>git push origin --tags</code></td>
								<td>Envoie tous les tags locaux vers le dépôt distant.</td>
								<td>Partage public des différentes versions marquées.</td>
								<td>Peut pousser des tags créés par erreur.</td>
							</tr>
							<tr>
								<td><strong>git submodule add</strong></td>
								<td><code>git submodule add &lt;URL&gt;</code></td>
								<td>Ajoute un dépôt Git comme sous-module dans le projet.</td>
								<td>Gère plusieurs projets dans un seul repo principal.</td>
								<td>Gestion parfois complexe si sous-modules changent souvent.</td>
							</tr>
							<tr>
								<td><strong>git submodule init</strong></td>
								<td><code>git submodule init</code></td>
								<td>Initialise les sous-modules d’un projet déjà cloné.</td>
								<td>Indispensable après un clone contenant des submodules.</td>
								<td>Étape supplémentaire qui peut être oubliée.</td>
							</tr>
							<tr>
								<td><strong>git submodule update</strong></td>
								<td><code>git submodule update</code></td>
								<td>Met à jour les sous-modules à la version indiquée dans le repo principal.</td>
								<td>Garde les sous-modules cohérents avec la référence choisie.</td>
								<td>Parfois besoin de <code>--recursive</code> (sous-sous-modules).</td>
							</tr>
							<tr>
								<td><strong>git clone --recurse-submodules</strong></td>
								<td><code>git clone --recurse-submodules &lt;URL&gt;</code></td>
								<td>Clone un projet et initialise les sous-modules en une seule commande.</td>
								<td>Pratique pour un projet multi-modules complet.</td>
								<td>Sinon il faut <code>init</code> et <code>update</code> manuellement.</td>
							</tr>
							<tr>
								<td><strong>git cherry-pick</strong></td>
								<td><code>git cherry-pick &lt;commit&gt;</code></td>
								<td>Copie un commit précis (d’une autre branche) dans la branche courante.</td>
								<td>Importe une correction ou fonctionnalité sans fusionner toute la branche.</td>
								<td>Conflits possibles si dépendances entre commits.</td>
							</tr>
							<tr>
								<td><strong>git reflog</strong></td>
								<td><code>git reflog</code></td>
								<td>Historique détaillé des actions (commits, checkout...) même effacées du log.
								</td>
								<td>Permet de récupérer un commit perdu.</td>
								<td>Lecture parfois confuse pour les débutants.</td>
							</tr>
							<tr>
								<td><strong>git gc</strong></td>
								<td><code>git gc</code></td>
								<td>Nettoie/optimise la base de données Git (compression, purge objets obsolètes).
								</td>
								<td>Réduit la taille du repo, améliore la performance.</td>
								<td>À utiliser avec précaution (peut effacer définitivement certains objets).</td>
							</tr>
							<tr>
								<td><strong>git archive</strong></td>
								<td><code>git archive --format=zip HEAD &gt; code.zip</code></td>
								<td>Crée une archive du contenu (sans l’historique complet).</td>
								<td>Utile pour exporter une version rapidement.</td>
								<td>Aucun suivi de l’historique dans l’archive.</td>
							</tr>
							<tr>
								<td><strong>git shortlog</strong></td>
								<td><code>git shortlog</code></td>
								<td>Résumé des commits groupés par auteur.</td>
								<td>Vision rapide de la contribution de chacun.</td>
								<td>Manque de détails sur les changements eux-mêmes.</td>
							</tr>
							</tbody>
						</table>
					</div>
					<p><strong>Remarques :</strong></p>
					<ul>
						<li>Certaines commandes ont des variantes (ex. <code>-m</code>, <code>-p</code>,
							<code>--stat</code>).</li>
						<li>Les avantages/inconvénients dépendent du contexte (projet solo/équipe, etc.).</li>
					</ul>
			</section>

			<!-- EXEMPLES CONCRETS -->
			<section id="exemples">
				<h2 class="card-header text-primary">Exemples Concrets</h2>
				<h4>1. Annuler le dernier commit en gardant les modifs</h4>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git reset --soft HEAD~1
	# Les fichiers restent modifiés
	</code>
	</pre>

				<h4>2. Rebaser sa branche sur main</h4>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git checkout ma-branche
	git pull origin main
	git rebase main
	</code>
	</pre>
			</section>

			<!-- EXERCICES & PIEGES -->
			<section id="exercices-pieges">
				<h2 class="card-header text-primary">Exercices & pièges courants</h2>
				<h3>Exercices pratiques</h3>
				<ul>
					<li><strong>Exercice 1 :</strong> Créer un dépôt local, y faire deux commits et pousser sur GitHub.
					</li>
					<li><strong>Exercice 2 :</strong> Créer une branche, y faire une modif, provoquer un conflit et le
						résoudre.</li>
					<li><strong>Exercice 3 :</strong> Faire un stash avant de changer de branche, puis le récupérer.
					</li>
				</ul>

				<h3>Pièges courants à éviter</h3>
				<ul>
					<li><strong>Forcer un push</strong> : <code>git push --force</code> sans précaution risque d’écraser
						le travail d’autrui.</li>
					<li><strong>Réécrire l’historique partagé</strong> : rebase ou reset sur une branche déjà utilisée
						par d’autres.</li>
					<li><strong>Oublier stash</strong> : si on change de branche sans stasher, on peut perdre ses
						modifs.</li>
					<li><strong>Merge mal résolu</strong> : bien faire <code>git add</code> et <code>git commit</code>
						après le conflit.</li>
				</ul>
			</section>

			<!-- CONVENTIONS DE COMMIT -->
			<section id="commit-conventions">
				<h2 class="card-header text-primary">Conventions Commit</h2>
				<p>
					Parfois on suit des règles pour les messages de commit (ex. <em>Conventional Commits</em>),
					afin de générer des changelogs automatiques, d’avoir une structure claire, etc.
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	feat: ajout fonctionnalité
	fix: correction bug
	docs: mise à jour doc
	</code>
		</pre>
			</section>

			<!-- CI/CD GITHUB ACTIONS -->
			<section id="github-actions">
				<h2 class="card-header text-primary">CI/CD (GitHub Actions)</h2>
				<p>
					Pour automatiser des tests ou un déploiement, on peut créer un fichier
					<code>.github/workflows/ci.yml</code> comme ceci :
				</p>
				<pre class="language-yaml">
				  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	name: CI

	on:
		push:
		branches: [ "main" ]
		pull_request:
		branches: [ "main" ]

	jobs:
		build:
		runs-on: ubuntu-latest
		steps:
			- uses: actions/checkout@v2
			- name: Installer dépendances
			run: npm install
			- name: Lancer les tests
			run: npm test
	</code>
		</pre>
			</section>

			<!-- GLOSSAIRE GIT -->
			<section id="glossaire">
				<h2 class="card-header text-primary">Glossaire Git</h2>
				<ul>
					<li><strong>stash</strong> : mettre de côté des modifications non commit (temporaire).</li>
					<li><strong>rebase</strong> : rejouer des commits sur une autre base pour un historique plus
						linéaire.</li>
					<li><strong>fetch</strong> : télécharger les changements distants sans les fusionner (juste les
						voir).</li>
					<li><strong>fork</strong> : copier un dépôt (souvent sur GitHub) dans son espace perso.</li>
					<li><strong>cherry-pick</strong> : prendre un commit précis d’une autre branche et l’ajouter à la
						nôtre.</li>
					<li><strong>tag</strong> : étiquette (nom) sur un commit (souvent pour marquer une version stable).
					</li>
				</ul>
			</section>

			<!-- CONCLUSION -->
			<section id="conclusion">
				<h2 class="card-header text-primary">Conclusion</h2>
				<p>
					Vous avez vu ici toutes les bases de Git, plus des parties avancées (rebase, stash, etc.).
					Entraînez-vous régulièrement pour retenir les commandes.
				</p>
				<p>
					Git est très puissant et utile quand on travaille à plusieurs ou qu’on veut garder une trace
					de chaque changement dans son projet.
				</p>
				<p><strong>Bonne pratique de Git et bon code !</strong></p>

			</section>

			<!-- (24) GIT WORKFLOWS -->
			<section id="workflows">
				<h2 class="card-header text-primary">24. Git Workflows</h2>
				<h3>Introduction aux Workflows Git</h3>
				<p>Un workflow Git (ou flux de travail Git) est un ensemble de conventions, de recommandations et de stratégies sur la manière d'utiliser Git efficacement au sein d'un projet ou d'une équipe. Choisir un workflow adapté permet de structurer le développement, de faciliter la collaboration, de gérer les versions et de maintenir un historique de projet propre et compréhensible. Il n'existe pas de workflow universel ; le choix dépendra souvent de la taille de l'équipe, de la nature du projet (ex: application web, bibliothèque), du cycle de release, et des outils de CI/CD utilisés.</p>
				<p>Les workflows définissent typiquement :</p>
				<ul>
					<li>La structure des branches (quelles branches sont utilisées et leur rôle).</li>
					<li>Quand et comment les branches sont créées, fusionnées ou rebasées.</li>
					<li>Comment les versions et les releases sont gérées.</li>
					<li>Les conventions de nommage pour les branches et les commits.</li>
				</ul>
				<p>Nous allons explorer quelques workflows populaires.</p>

				<h3>Gitflow Workflow</h3>
				<p>Proposé par Vincent Driessen en 2010, Gitflow est un modèle de branching robuste, conçu pour des projets avec un cycle de release planifié. Il est particulièrement populaire pour les logiciels qui ont des versions distinctes (ex: v1.0, v1.1, v2.0).</p>
				<h5>Branches Principales :</h5>
				<ul>
					<li><code>main</code> (ou <code>master</code>) : Contient le code de production stable, prêt à être déployé. Chaque commit sur <code>main</code> est une nouvelle version et devrait être tagué avec un numéro de version.</li>
					<li><code>develop</code> : Sert de branche d'intégration principale pour les fonctionnalités. C'est ici que le code de la prochaine release est accumulé. Lorsque <code>develop</code> atteint un état stable et est prête pour une release, elle est mergée dans <code>main</code> et taguée.</li>
				</ul>
				<h5>Branches de Support :</h5>
				<ul>
					<li><strong>Branches de fonctionnalité (<code>feature/*</code>) :</strong>
						<ul>
							<li>Créées à partir de : <code>develop</code>.</li>
							<li>Doivent être mergées dans : <code>develop</code>.</li>
							<li>Convention de nommage : <code>feature/nom-de-la-fonction</code> (ex: <code>feature/user-authentication</code>).</li>
							<li>But : Développer de nouvelles fonctionnalités de manière isolée. Ne doivent jamais interagir directement avec <code>main</code>.</li>
						</ul>
					</li>
					<li><strong>Branches de release (<code>release/*</code>) :</strong>
						<ul>
							<li>Créées à partir de : <code>develop</code> (quand <code>develop</code> est prête pour une release).</li>
							<li>Doivent être mergées dans : <code>develop</code> ET <code>main</code>.</li>
							<li>Convention de nommage : <code>release/v1.0.1</code>.</li>
							<li>But : Préparer une nouvelle release de production. Permet de faire des corrections de dernière minute, de la documentation, etc., sans interrompre le flux sur <code>develop</code>. Une fois prête, la branche de release est mergée dans <code>main</code> (et taguée) et aussi dans <code>develop</code> (pour y reporter les corrections de dernière minute).</li>
						</ul>
					</li>
					<li><strong>Branches de correctif (<code>hotfix/*</code>) :</strong>
						<ul>
							<li>Créées à partir de : <code>main</code> (depuis le tag de la version à corriger).</li>
							<li>Doivent être mergées dans : <code>develop</code> ET <code>main</code>.</li>
							<li>Convention de nommage : <code>hotfix/description-du-correctif</code> (ex: <code>hotfix/security-vulnerability-fix</code>).</li>
							<li>But : Corriger rapidement des bugs critiques en production. Permet de ne pas attendre le prochain cycle de release. Une fois le correctif appliqué, la branche est mergée dans <code>main</code> (et une nouvelle version est taguée) et également dans <code>develop</code>.</li>
						</ul>
					</li>
				</ul>
				<h5>Avantages de Gitflow :</h5>
				<ul>
					<li>Très structuré et clair, surtout pour les projets avec plusieurs versions et des cycles de release définis.</li>
					<li>Bonne isolation entre les nouvelles fonctionnalités, la préparation des releases et les correctifs urgents.</li>
					<li>Le rôle de chaque branche est bien défini.</li>
				</ul>
				<h5>Inconvénients de Gitflow :</h5>
				<ul>
					<li>Peut être perçu comme complexe, surtout pour les petits projets ou les équipes qui pratiquent l'intégration continue et le déploiement continu (CI/CD).</li>
					<li>Le nombre de branches peut devenir important.</li>
					<li>La branche <code>develop</code> peut parfois diverger significativement de <code>main</code> sur de longues périodes.</li>
				</ul>

				<h3>GitHub Flow</h3>
				<p>GitHub Flow est un workflow plus simple et léger, popularisé par GitHub. Il est particulièrement bien adapté aux projets qui pratiquent le déploiement continu ou fréquent (ex: applications web).</p>
				<h5>Principes Clés :</h5>
				<ul>
					<li><code>main</code> est toujours la branche principale et elle est **toujours déployable**. Ce qui est sur <code>main</code> est considéré comme stable et prêt pour la production.</li>
					<li>Pour travailler sur quelque chose de nouveau (fonctionnalité, bugfix), créez une **branche descriptive** à partir de <code>main</code> (ex: <code>feature/user-profile</code>, <code>fix/login-bug</code>).</li>
					<li>Poussez vos commits sur cette branche descriptive régulièrement sur le dépôt distant.</li>
					<li>Lorsque vous avez besoin de feedback ou que la fonctionnalité est prête, ouvrez une **Pull Request (PR)**.</li>
					<li>Après revue et approbation de la PR (et passage des tests automatisés), la branche est **mergée dans <code>main</code>**.</li>
					<li>Une fois mergée dans <code>main</code>, les changements devraient être **déployés immédiatement** (ou très rapidement).</li>
				</ul>
				<h5>Processus Typique :</h5>
				<ol>
					<li>Créez une branche à partir de <code>main</code>: <code>git checkout -b feature/nouvelle-idee main</code></li>
					<li>Faites vos commits sur cette branche.</li>
					<li>Poussez la branche sur le serveur : <code>git push origin feature/nouvelle-idee</code></li>
					<li>Ouvrez une Pull Request sur GitHub (ou GitLab, etc.).</li>
					<li>Discutez, revoyez le code, ajoutez des commits si nécessaire (en poussant sur la même branche).</li>
					<li>Une fois la PR approuvée et les tests CI passés, mergez-la dans <code>main</code> (souvent via l'interface de la plateforme).</li>
					<li>Déployez <code>main</code>.</li>
					<li>Supprimez la branche de fonctionnalité une fois mergée et déployée.</li>
				</ol>
				<h5>Avantages de GitHub Flow :</h5>
				<ul>
					<li>Simple à comprendre et à mettre en œuvre.</li>
					<li>Favorise l'intégration continue et le déploiement continu (CI/CD).</li>
					<li>Les Pull Requests facilitent la revue de code et la discussion avant l'intégration.</li>
					<li><code>main</code> est toujours une source de vérité pour le code stable.</li>
				</ul>
				<h5>Inconvénients de GitHub Flow :</h5>
				<ul>
					<li>Moins adapté si vous avez besoin de gérer plusieurs versions en parallèle ou si vous avez des cycles de release longs et planifiés (Gitflow pourrait être mieux).</li>
					<li>Nécessite une bonne discipline pour s'assurer que <code>main</code> est réellement toujours déployable.</li>
					<li>La gestion des hotfixes peut nécessiter une petite adaptation (souvent, un hotfix suit le même flux : branche à partir de `main`, PR, merge, déploiement).</li>
				</ul>

				<h3>Trunk-Based Development (Mention)</h3>
				<p>Le Trunk-Based Development (TBD) est un workflow où tous les développeurs collaborent sur le code dans une seule branche appelée "trunk" (souvent <code>main</code> ou <code>master</code>). Les changements sont intégrés fréquemment (au moins une fois par jour).</p>
				<ul>
					<li>Les fonctionnalités plus longues ou risquées sont souvent gérées avec des "Feature Flags" (bascules de fonctionnalités) pour permettre d'intégrer le code dans le trunk sans le rendre actif pour les utilisateurs finaux immédiatement.</li>
					<li>Les branches, si utilisées, sont très courtes (quelques commits, durant moins d'un jour ou deux) avant d'être mergées dans le trunk.</li>
					<li>Fortement dépendant d'une suite de tests automatisés robuste et d'une CI/CD performante.</li>
					<li>Objectif : éviter les problèmes de "merge hell" en intégrant continuellement.</li>
				</ul>
				<p>Ce workflow est courant dans les environnements qui visent une très haute vélocité et un déploiement continu.</p>
			</section>

			<!-- (25) HOOKS GIT -->
			<section id="hooks-git">
				<h2 class="card-header text-primary">25. Hooks Git (Crochets Git)</h2>

				<h3>Qu'est-ce qu'un Hook Git ?</h3>
				<p>Les hooks (ou "crochets") Git sont des scripts que Git exécute automatiquement avant ou après certains événements importants de son cycle de vie, tels que la création de commits, le push de modifications, ou le changement de branches. Ils vous permettent de personnaliser le comportement de Git et d'automatiser des tâches spécifiques à votre workflow.</p>
				<p>Par exemple, vous pouvez utiliser un hook pour :</p>
				<ul>
					<li>Vérifier que votre message de commit respecte un format standard.</li>
					<li>Exécuter des tests unitaires avant de permettre un commit.</li>
					<li>Notifier votre équipe d'intégration continue après un push réussi.</li>
					<li>Vérifier la qualité du code (linting) avant qu'il ne soit commité.</li>
				</ul>
				<p>Les hooks sont locaux à chaque dépôt Git ; ils ne sont pas versionnés avec le dépôt lui-même et ne sont donc pas transférés lors d'un clone. Chaque développeur doit configurer ses propres hooks ou utiliser un mécanisme pour les partager au sein de l'équipe (par exemple, en les versionnant dans un dossier du projet et en ayant un script pour les copier/lier dans <code>.git/hooks</code>).</p>

				<h3>Types de Hooks</h3>
				<p>Il existe deux catégories principales de hooks :</p>
				<ul>
					<li><strong>Hooks côté client (Client-Side Hooks) :</strong> Ils sont exécutés sur la machine locale du développeur et affectent son workflow personnel. Ce sont ceux sur lesquels nous allons nous concentrer. Exemples : <code>pre-commit</code>, <code>prepare-commit-msg</code>, <code>commit-msg</code>, <code>post-commit</code>, <code>pre-push</code>.</li>
					<li><strong>Hooks côté serveur (Server-Side Hooks) :</strong> Ils sont exécutés sur le serveur Git distant (par exemple, votre serveur GitHub Enterprise, GitLab, ou un serveur Git auto-hébergé) et sont utiles pour faire respecter des politiques pour le projet, envoyer des notifications, etc. Exemples : <code>pre-receive</code>, <code>update</code>, <code>post-receive</code>. La configuration de ces hooks dépend de la plateforme serveur.</li>
				</ul>

				<h3>Emplacement et Activation des Hooks</h3>
				<p>Les hooks côté client résident dans le répertoire <code>.git/hooks/</code> de votre dépôt. Lorsque vous initialisez un nouveau dépôt avec <code>git init</code>, Git peuple ce dossier avec un ensemble d'exemples de scripts de hooks. Ces fichiers se terminent tous par <code>.sample</code> (par exemple, <code>pre-commit.sample</code>).</p>
				<p>Pour activer un hook, il suffit de :</p>
				<ol>
					<li>Naviguer vers le répertoire <code>.git/hooks/</code>.</li>
					<li>Supprimer l'extension <code>.sample</code> du fichier de hook que vous voulez activer. Par exemple, renommez <code>pre-commit.sample</code> en <code>pre-commit</code>.</li>
					<li>Rendre le script exécutable : <code>chmod +x pre-commit</code> (sur Linux/macOS).</li>
				</ol>
				<p>Vous pouvez écrire vos scripts de hook dans n'importe quel langage de script que votre système peut exécuter (Bash, Perl, Python, Ruby, Node.js, etc.), tant que le script est exécutable et commence par un shebang correct (par exemple, <code>#!/bin/sh</code> ou <code>#!/usr/bin/env python3</code>).</p>
				<p>Si un script de hook retourne un code de sortie non nul (différent de 0), l'action Git correspondante (commit, push, etc.) est généralement annulée.</p>

				<h3>Exemple : Hook <code>pre-commit</code></h3>
				<p>Le hook <code>pre-commit</code> est exécuté juste avant que Git ne crée le commit, après que vous ayez tapé <code>git commit</code> mais avant que l'éditeur de message de commit ne s'ouvre (sauf si vous utilisez <code>-m</code>).</p>
				<p>Il est idéal pour effectuer des vérifications sur le code que vous êtes sur le point de commiter. Si le script <code>pre-commit</code> sort avec un code non nul, le commit est avorté.</p>
				<p><strong>Scénario :</strong> S'assurer qu'aucun fichier ne contient de marqueurs de conflit de fusion (<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>) oubliés.</p>
				<p>Créez le fichier <code>.git/hooks/pre-commit</code> (et rendez-le exécutable) avec le contenu suivant :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de hook pre-commit">Copier</button>
	<code>#!/bin/sh

	# Vérifier les fichiers staged pour les marqueurs de conflit
	if git diff --cached --name-only --diff-filter=ACM | xargs grep -E -q -s '<<<<<<<|=======|>>>>>>>'; then
	  echo "ERREUR : Marqueurs de conflit de fusion détectés dans les fichiers staged."
	  echo "Veuillez résoudre les conflits avant de commiter."
	  exit 1
	fi

	# Un autre exemple : interdire les commits directs sur la branche main (simple vérification)
	BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)
	if [ "$BRANCH_NAME" = "main" ]; then
	  # echo "ERREUR : Les commits directs sur la branche 'main' ne sont pas autorisés."
	  # echo "Veuillez utiliser une branche de fonctionnalité et une Pull Request."
	  # exit 1 # Décommentez pour activer cette règle
	fi

	# Si tout va bien, sortir avec 0 pour permettre le commit
	exit 0</code></pre>
				<p>Ce script vérifie d'abord les conflits. La partie commentée montre comment vous pourriez ajouter une règle pour interdire les commits sur `main`.</p>

				<h3>Exemple : Hook <code>commit-msg</code></h3>
				<p>Le hook <code>commit-msg</code> prend un argument : le chemin vers un fichier temporaire qui contient le message de commit que vous avez rédigé. Il est exécuté après que vous ayez fermé l'éditeur de message de commit (ou après avoir fourni un message avec <code>-m</code>).</p>
				<p>Il est utilisé pour valider ou reformater le message de commit. S'il sort avec un code non nul, le commit est avorté.</p>
				<p><strong>Scénario :</strong> S'assurer que le message de commit respecte un format simple (par exemple, ne commence pas par "WIP", a une longueur minimale).</p>
				<p>Créez <code>.git/hooks/commit-msg</code> (et rendez-le exécutable) :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de hook commit-msg">Copier</button>
	<code>#!/bin/sh

	COMMIT_MSG_FILE=$1
	COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

	# Vérifier si le message commence par "WIP" (Work In Progress)
	if echo "$COMMIT_MSG" | grep -qE '^WIP:'; then
	  echo "ATTENTION : Le message de commit commence par 'WIP:'."
	  echo "Ceci est permis, mais n'oubliez pas de le finaliser plus tard."
	  # Ne pas faire exit 1 ici si on veut juste avertir
	fi

	# Vérifier une longueur minimale (par exemple, 10 caractères, sans compter les commentaires)
	ACTUAL_MSG=$(echo "$COMMIT_MSG" | grep -v '^#') # Ignorer les lignes de commentaire
	if [ ${#ACTUAL_MSG} -lt 10 ]; then
	  echo "ERREUR : Le message de commit est trop court (moins de 10 caractères)."
	  echo "Veuillez fournir un message plus descriptif."
	  exit 1
	fi

	# Vérifier la présence d'un ticket ID (exemple: [PROJECT-123])
	# if ! echo "$COMMIT_MSG" | grep -qE '\[[A-Z]+-[0-9]+\]'; then
	#   echo "ERREUR : Le message de commit doit inclure un ID de ticket (ex: [PROJECT-123])."
	#   exit 1
	# fi


	# Si tout va bien
	exit 0</code></pre>
				<p>Ce script vérifie quelques règles simples. Vous pouvez l'adapter pour des formats plus stricts comme <a href="#commit-conventions">Conventional Commits</a>.</p>

				<h3>Autres Hooks Utiles (Client-Side)</h3>
				<ul>
					<li><strong><code>prepare-commit-msg</code> :</strong> Exécuté avant l'éditeur de message de commit mais après la création du message par défaut. Utile pour insérer un modèle de message ou modifier le message généré automatiquement (par exemple, pour les commits de merge ou squash).</li>
					<li><strong><code>post-commit</code> :</strong> Exécuté juste après qu'un commit a été effectué avec succès. Utile pour des notifications ou des tâches de nettoyage.</li>
					<li><strong><code>pre-rebase</code> :</strong> Exécuté avant que <code>git rebase</code> ne commence. Peut être utilisé pour empêcher le rebase de certaines branches.</li>
					<li><strong><code>post-checkout</code> :</strong> Exécuté après un <code>git checkout</code> réussi. Utile pour nettoyer le répertoire de travail, installer des dépendances si un certain fichier a changé, etc.</li>
					<li><strong><code>pre-push</code> :</strong> Exécuté avant que <code>git push</code> n'envoie les commits au distant. C'est un excellent endroit pour exécuter des tests d'intégration plus longs ou des vérifications finales avant de partager votre code. S'il échoue, le push est annulé.</li>
				</ul>

				<h3>Langages pour les Hooks</h3>
				<p>Comme mentionné, vous pouvez utiliser la plupart des langages de script. Le Shell (Bash, sh) est courant pour sa simplicité et sa portabilité sur les systèmes Unix-like. Python, Ruby, Perl et Node.js sont également de bons choix, surtout si la logique du hook devient plus complexe ou si vous voulez utiliser des bibliothèques existantes.</p>
				<p>N'oubliez pas le shebang (<code>#!</code>) au début de votre script pour indiquer l'interpréteur et de rendre le fichier de hook exécutable.</p>
				<div class="alert alert-info" role="alert">
					<strong>Conseil :</strong> Il existe des outils et des frameworks (comme <a href="https://pre-commit.com/" target="_blank" rel="noopener noreferrer">pre-commit.com</a>) qui aident à gérer et partager des hooks Git pré-construits ou personnalisés au sein d'une équipe, simplifiant leur installation et leur maintenance.
				</div>
			</section>

			<!-- (26) FINS DE LIGNE & .GITATTRIBUTES -->
			<section id="gitattributes">
				<h2 class="card-header text-primary">26. Fins de Ligne & <code>.gitattributes</code></h2>

				<h3>Le Problème des Fins de Ligne (CRLF vs LF)</h3>
				<p>L'un des problèmes les plus courants et frustrants lorsque l'on travaille en équipe sur différents systèmes d'exploitation est la gestion des fins de ligne. Les systèmes Windows utilisent une séquence de deux caractères : retour chariot (Carriage Return, CR) et saut de ligne (Line Feed, LF), souvent notée CRLF. Les systèmes Unix (Linux, macOS) utilisent uniquement un saut de ligne (LF).</p>
				<p>Si les développeurs d'une équipe utilisent des systèmes différents sans configuration appropriée, Git peut :</p>
				<ul>
					<li>Signaler des modifications sur chaque ligne d'un fichier alors que seul le type de fin de ligne a changé.</li>
					<li>Corrompre les fins de ligne, rendant les scripts non exécutables sur certains systèmes ou causant des problèmes avec certains outils.</li>
				</ul>

				<h3>Configuration Globale (<code>core.autocrlf</code>)</h3>
				<p>Git tente de gérer ce problème avec le paramètre de configuration <code>core.autocrlf</code>. Il a trois valeurs possibles :</p>
				<ul>
					<li><strong><code>true</code> (Windows) :</strong>
						<code>git config --global core.autocrlf true</code>
						<br>Sur checkout (récupération) : Git convertit les fins de ligne LF en CRLF.
						<br>Sur commit (validation) : Git convertit les fins de ligne CRLF en LF.
						<br>C'est la configuration recommandée pour les utilisateurs Windows.
					</li>
					<li><strong><code>input</code> (macOS/Linux) :</strong>
						<code>git config --global core.autocrlf input</code>
						<br>Sur checkout : Git ne fait rien.
						<br>Sur commit : Git convertit les fins de ligne CRLF en LF.
						<br>C'est la configuration recommandée pour les utilisateurs macOS et Linux.
					</li>
					<li><strong><code>false</code> :</strong>
						<code>git config --global core.autocrlf false</code>
						<br>Git ne fait aucune conversion. Les fins de ligne sont commitées telles quelles. Non recommandé pour les projets multi-OS.
					</li>
				</ul>
				<p>Bien que <code>core.autocrlf</code> aide, il n'est pas toujours suffisant et peut être source de confusion car il dépend de la configuration locale de chaque développeur. Une solution plus robuste et centralisée est d'utiliser un fichier <code>.gitattributes</code>.</p>

				<h3>Le Fichier <code>.gitattributes</code> : Introduction</h3>
				<p>Le fichier <code>.gitattributes</code> permet de déclarer des attributs spécifiques pour des chemins (fichiers ou répertoires) dans votre dépôt. Ces attributs indiquent à Git comment traiter ces chemins. Contrairement à <code>.gitignore</code> qui spécifie les fichiers à ignorer, <code>.gitattributes</code> définit des comportements pour les fichiers suivis par Git.</p>
				<p>Ce fichier doit être commité dans votre dépôt pour que ses règles s'appliquent de manière cohérente à tous les collaborateurs. Il est généralement placé à la racine du projet.</p>
				<p>Chaque ligne du fichier <code>.gitattributes</code> suit le format :<br>
					<code>pattern attr1 attr2 ...</code><br>
					Où <code>pattern</code> est un motif de fichier (similaire à ceux de <code>.gitignore</code>, ex: <code>*.txt</code>, <code>src/*.js</code>) et <code>attr1</code>, <code>attr2</code> sont les attributs que vous assignez.</p>

				<h3>Gérer les Fins de Ligne via <code>.gitattributes</code></h3>
				<p>L'attribut le plus important pour la gestion des fins de ligne est <code>text</code>. Combiné avec <code>eol</code>, il offre un contrôle précis :</p>
				<ul>
					<li><strong><code>* text=auto</code></strong>
						<p>C'est la configuration la plus courante et recommandée pour commencer. Pour tous les fichiers (<code>*</code>), Git essaiera de deviner s'il s'agit de fichiers texte. Si c'est le cas, il normalisera les fins de ligne en LF dans le dépôt et les convertira aux fins de ligne natives du système d'exploitation de l'utilisateur lors du checkout (CRLF pour Windows, LF pour macOS/Linux).</p>
					</li>
					<li><strong><code>*.txt text</code></strong>
						<p>Traite tous les fichiers <code>.txt</code> comme des fichiers texte et normalise leurs fins de ligne (LF dans le dépôt).</p>
					</li>
					<li><strong><code>*.sh text eol=lf</code></strong>
						<p>Traite tous les scripts shell (<code>.sh</code>) comme des fichiers texte et s'assure qu'ils utilisent des fins de ligne LF, que ce soit dans le dépôt ou dans le répertoire de travail, quel que soit le système d'exploitation. C'est crucial car les scripts shell avec des fins de ligne CRLF ne fonctionnent pas correctement sur les systèmes Unix.</p>
					</li>
					<li><strong><code>*.bat text eol=crlf</code></strong>
						<p>Traite tous les scripts batch Windows (<code>.bat</code>) comme des fichiers texte et s'assure qu'ils utilisent des fins de ligne CRLF.</p>
					</li>
				</ul>
				<p><strong>Exemple de fichier <code>.gitattributes</code> :</strong></p>
				<pre class="language-text">
	<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de fichier .gitattributes">Copier</button>
	<code># Définit le comportement par défaut pour tous les fichiers
	* text=auto

	# Force les fins de ligne LF pour les types de fichiers sensibles
	*.js    text eol=lf
	*.jsx   text eol=lf
	*.json  text eol=lf
	*.css   text eol=lf
	*.html  text eol=lf
	*.sh    text eol=lf
	*.py    text eol=lf
	*.md    text eol=lf
	*.xml   text eol=lf
	*.yml   text eol=lf
	*.yaml  text eol=lf

	# Pour les fichiers Windows spécifiques, forcer CRLF
	*.bat   text eol=crlf
	*.cmd   text eol=crlf
	*.sln   text eol=crlf
	*.vcproj text eol=crlf

	# Marquer les fichiers binaires (Git ne tentera pas de les convertir ou de les differ)
	*.png   binary
	*.jpg   binary
	*.jpeg  binary
	*.gif   binary
	*.pdf   binary
	*.zip   binary
	*.exe   binary
	*.dll   binary
	*.o     binary
	*.a     binary
	*.obj   binary
	*.so    binary</code></pre>
				<p>Après avoir ajouté ou modifié un fichier <code>.gitattributes</code>, il est possible que vous deviez rafraîchir les fichiers de votre répertoire de travail pour que les nouvelles règles s'appliquent. Git ne modifie pas automatiquement les fichiers déjà présents. Vous pouvez le faire en :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier les commandes pour rafraîchir les fichiers après modification de .gitattributes">Copier</button>
	<code>git add . --renormalize</code></pre>
				<p>Puis commitez les changements si Git détecte des normalisations de fins de ligne.</p>

				<h3>Marquer les Fichiers Binaires</h3>
				<p>Il est important d'indiquer à Git quels fichiers sont binaires. Git essaiera de ne pas modifier les fins de ligne de ces fichiers et ne tentera pas de générer des diffs textuels pour eux.</p>
				<p>Vous pouvez le faire avec l'attribut <code>binary</code> ou en spécifiant <code>-text</code> :</p>
				<ul>
					<li><code>*.png binary</code></li>
					<li><code>*.jpg -text</code> (signifie "pas un fichier texte")</li>
				</ul>
				<p>Cela empêche la corruption de fichiers binaires par les conversions de fins de ligne et rend les opérations comme <code>git diff</code> plus performantes pour ces fichiers.</p>
				<div class="alert alert-info" role="alert">
					Utiliser un fichier <code>.gitattributes</code> bien configuré est une bonne pratique pour tout projet, surtout ceux impliquant plusieurs collaborateurs ou systèmes d'exploitation, afin d'éviter les problèmes liés aux fins de ligne et de s'assurer que Git traite correctement les différents types de fichiers.
				</div>
			</section>

			<!-- (27) GIT RERERE -->
			<section id="git-rerere">
				<h2 class="card-header text-primary">27. <code>git rerere</code> (Reuse Recorded Resolution)</h2>

				<h3>Le Problème : Résoudre les Mêmes Conflits Répétitivement</h3>
				<p>Lorsque vous travaillez sur des branches qui vivent longtemps et que vous rebasez fréquemment sur une branche principale active (comme <code>main</code> ou <code>develop</code>), ou lorsque vous effectuez des merges répétitifs entre les mêmes branches, vous pouvez vous retrouver à résoudre les mêmes conflits de fusion encore et encore. Cela peut être fastidieux et source d'erreurs.</p>
				<p>Par exemple, si vous avez une branche de fonctionnalité et que vous la rebasez sur <code>main</code>, vous résolvez des conflits. Si, quelques jours plus tard, vous rebasez à nouveau cette même branche sur une version plus récente de <code>main</code>, il est probable que beaucoup des mêmes conflits réapparaissent.</p>

				<h3>Qu'est-ce que <code>git rerere</code> et Comment Ça Marche ?</h3>
				<p><code>rerere</code> signifie "<strong>re</strong>use <strong>re</strong>corded <strong>re</strong>solution" (réutiliser la résolution enregistrée). C'est une fonctionnalité de Git qui observe comment vous résolvez les conflits de hunk (morceaux de code en conflit) et enregistre ces résolutions. Si Git rencontre à nouveau exactement le même conflit, il peut automatiquement appliquer la résolution que vous aviez précédemment fournie.</p>
				<p>Lorsqu'un conflit de fusion se produit et que <code>rerere</code> est activé :</p>
				<ol>
					<li>Git vérifie si ce conflit exact a déjà été résolu et enregistré.</li>
					<li>S'il trouve un enregistrement correspondant, il utilise la résolution précédente pour modifier les fichiers dans votre répertoire de travail. Les fichiers peuvent alors apparaître comme résolus (ou partiellement résolus si de nouveaux conflits sont présents).</li>
					<li>Si le conflit est nouveau, Git enregistre l'état pré-résolution du conflit. Une fois que vous avez résolu le conflit manuellement et que vous avez fait <code>git add</code> sur les fichiers concernés, Git enregistre la manière dont vous l'avez résolu.</li>
				</ol>
				<p>Cela ne signifie pas que vous n'aurez plus jamais à résoudre de conflits, mais cela peut considérablement réduire le nombre de conflits identiques que vous devez traiter manuellement.</p>

				<h3>Activer <code>git rerere</code></h3>
				<p>La fonctionnalité <code>rerere</code> n'est pas activée par défaut. Pour l'activer globalement pour tous vos dépôts :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande pour activer git rerere globalement">Copier</button>
	<code>git config --global rerere.enabled true</code></pre>
				<p>Vous pouvez également l'activer uniquement pour un dépôt spécifique en omettant l'option <code>--global</code> dans le répertoire de ce dépôt.</p>
				<p>Une fois activé, Git créera un répertoire <code>rr-cache</code> dans votre dossier <code>.git</code> pour stocker les résolutions enregistrées. Ce cache est spécifique à votre dépôt local (il n'est pas poussé vers le distant, bien qu'il puisse être partagé manuellement si nécessaire, mais c'est un cas d'usage plus avancé).</p>
				<p>Il existe aussi l'option <code>rerere.autoupdate</code> :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande pour activer rerere.autoupdate">Copier</button>
	<code>git config --global rerere.autoupdate true</code></pre>
				<p>Si <code>rerere.autoupdate</code> est à <code>true</code> (par défaut à <code>false</code>), Git mettra automatiquement à jour l'index (comme si vous aviez fait <code>git add</code>) pour les hunks qu'il a pu résoudre automatiquement grâce à <code>rerere</code>. Cela peut vous faire gagner une étape, mais certains préfèrent vérifier la résolution automatique avant de l'ajouter à l'index.</p>

				<h3>Quand est-ce le plus utile ?</h3>
				<ul>
					<li><strong>Rebases fréquents :</strong> Si vous maintenez une branche de fonctionnalité à jour en la rebasant régulièrement sur une branche cible qui évolue rapidement.</li>
					<li><strong>Branches de longue durée :</strong> Pour les branches qui divergent significativement et qui sont mergées ou rebasées périodiquement.</li>
					<li><strong>Maintenance de plusieurs versions :</strong> Lors du backporting de correctifs sur d'anciennes branches de release, où des conflits similaires peuvent survenir.</li>
					<li><strong>Lors de l'utilisation de <code>git bisect</code> :</strong> Si la recherche binaire implique des merges ou des rebases qui génèrent des conflits répétitifs.</li>
				</ul>

				<h3>Commandes Associées (Optionnel)</h3>
				<p>Bien que <code>rerere</code> fonctionne principalement en arrière-plan, quelques commandes peuvent être utiles pour interagir avec le cache <code>rr-cache</code> :</p>
				<ul>
					<li><code>git rerere status</code> : Affiche les conflits que <code>rerere</code> suit actuellement.</li>
					<li><code>git rerere diff</code> : Affiche les diffs des résolutions enregistrées.</li>
					<li><code>git rerere remaining</code> : Affiche les conflits qui nécessitent encore une résolution manuelle (si <code>rerere.autoupdate</code> est false ou si certains hunks n'ont pas pu être résolus).</li>
					<li><code>git rerere clear</code> : Supprime tous les enregistrements du cache <code>rr-cache</code> pour le dépôt courant (utile si vous pensez qu'une résolution incorrecte a été enregistrée).</li>
					<li><code>git rerere gc</code> : Effectue un nettoyage (garbage collection) des anciennes résolutions enregistrées qui ne sont plus pertinentes.</li>
				</ul>
				<p>En général, vous n'aurez pas besoin d'utiliser ces commandes fréquemment, car l'avantage principal de <code>rerere</code> est son automatisation silencieuse.</p>
				<div class="alert alert-success" role="alert">
					<strong>En résumé :</strong> <code>git rerere</code> est un outil discret mais puissant qui apprend de vos résolutions de conflits passées pour vous faire gagner du temps sur des conflits identiques à l'avenir. Activez-le et laissez-le travailler en arrière-plan !
				</div>
			</section>

			<!-- (28) COLLABORATION AVANCEE SUR PLATEFORMES -->
			<section id="collaboration-plateformes">
				<h2 class="card-header text-primary">28. Collaboration Avancée sur Plateformes</h2>

				<h3>Introduction : Au-delà du <code>push</code> et <code>pull</code></h3>
				<p>Si les commandes Git de base comme <code>push</code>, <code>pull</code>, <code>commit</code>, et <code>branch</code> sont essentielles pour le travail individuel et la synchronisation simple, la collaboration moderne sur des projets logiciels, en particulier avec des équipes ou sur des projets open source, s'appuie fortement sur les fonctionnalités offertes par les plateformes d'hébergement Git telles que GitHub, GitLab, Bitbucket, etc. Ces plateformes fournissent des outils et des workflows qui facilitent la revue de code, la discussion, le suivi des tâches et l'intégration des contributions de manière structurée.</p>

				<h3>Pull Requests (PRs) / Merge Requests (MRs) : Le Cœur de la Collaboration</h3>
				<p>Les Pull Requests (terme utilisé par GitHub et Bitbucket) ou Merge Requests (terme utilisé par GitLab) sont le mécanisme central de la collaboration sur ces plateformes. Une PR/MR est une proposition formelle d'intégrer les changements d'une branche (par exemple, une branche de fonctionnalité) dans une autre (souvent la branche principale comme <code>main</code> ou <code>develop</code>).</p>
				<h5>Bonnes pratiques pour la création de PRs/MRs :</h5>
				<ul>
					<li><strong>Titre clair et concis :</strong> Le titre doit résumer l'objectif de la PR/MR. Beaucoup d'équipes utilisent des préfixes (ex: <code>feat:</code>, <code>fix:</code>, <code>docs:</code>) inspirés des Conventional Commits.</li>
					<li><strong>Description détaillée :</strong> Expliquez le <em>pourquoi</em> des changements, le problème résolu ou la fonctionnalité ajoutée. Incluez des liens vers les issues/tickets concernés. Si des changements d'interface utilisateur sont impliqués, des captures d'écran ou des GIFs sont très utiles.</li>
					<li><strong>Commits atomiques et propres :</strong> La branche source de la PR/MR devrait avoir un historique de commits propre et compréhensible. Chaque commit devrait représenter une étape logique. Utilisez le <a href="#rebase">rebase interactif</a> pour nettoyer votre historique local avant de créer la PR/MR ou de la mettre à jour.</li>
					<li><strong>Petites PRs/MRs ciblées :</strong> Privilégiez des PRs/MRs de petite taille, focalisées sur un seul objectif. Elles sont plus faciles et rapides à réviser, à tester et à merger.</li>
					<li><strong>Auto-revue :</strong> Relisez votre propre code et la description de votre PR/MR avant de la soumettre ou de demander des revues. Vous trouverez souvent des erreurs ou des améliorations vous-même.</li>
				</ul>
				<h5>Le processus de revue de code :</h5>
				<p>La revue de code est une étape cruciale pour améliorer la qualité du code, partager les connaissances et détecter les bugs tôt. Voici quelques conseils :</p>
				<ul>
					<li><strong>Pour le réviseur :</strong>
						<ul>
							<li>Soyez constructif et respectueux. Le but est d'améliorer le code, pas de critiquer l'auteur.</li>
							<li>Comprenez le contexte et l'objectif des changements.</li>
							<li>Vérifiez la logique, la clarté, la performance, la sécurité, la maintenabilité, et la conformité aux conventions du projet.</li>
							<li>Posez des questions plutôt que d'affirmer. Suggérez des améliorations au lieu d'imposer des changements.</li>
							<li>Utilisez les outils de la plateforme (commentaires en ligne, suggestions de code).</li>
						</ul>
					</li>
					<li><strong>Pour l'auteur :</strong>
						<ul>
							<li>Ne prenez pas le feedback personnellement. Considérez-le comme une opportunité d'apprendre et d'améliorer.</li>
							<li>Répondez aux commentaires, expliquez vos choix si nécessaire, ou indiquez que vous allez appliquer les suggestions.</li>
							<li>Poussez de nouveaux commits sur votre branche pour adresser le feedback. La PR/MR se mettra à jour automatiquement.</li>
							<li>Remerciez les réviseurs pour leur temps.</li>
						</ul>
					</li>
				</ul>
				<p>La discussion continue jusqu'à ce que la PR/MR soit approuvée et prête à être mergée.</p>

				<h3>Gestion des Issues / Tickets</h3>
				<p>Les plateformes Git fournissent des systèmes de suivi des "issues" (problèmes, tâches, bugs, demandes de fonctionnalités). Une bonne gestion des issues est essentielle pour l'organisation du projet.</p>
				<ul>
					<li><strong>Création d'issues claires :</strong> Une issue bien décrite comprend un titre explicite, des étapes pour reproduire un bug (si applicable), le comportement attendu vs. le comportement observé, et toute information contextuelle pertinente (version du logiciel, environnement, etc.).</li>
					<li><strong>Liaison Issues - Commits - PRs/MRs :</strong> La plupart des plateformes permettent de lier les issues au travail effectué. En incluant des mots-clés comme <code>fixes #123</code>, <code>closes #123</code>, ou <code>resolves #123</code> dans vos messages de commit ou descriptions de PR/MR, l'issue #123 sera automatiquement fermée lorsque la PR/MR sera mergée dans la branche par défaut. Vous pouvez aussi simplement mentionner une issue (<code>ref #123</code>) pour créer un lien sans la fermer.</li>
					<li><strong>Labels (Étiquettes) :</strong> Utilisez des labels pour catégoriser les issues (ex: <code>bug</code>, <code>enhancement</code>, <code>documentation</code>, <code>priority:high</code>, <code>good first issue</code>). Cela aide à filtrer et à prioriser le travail.</li>
					<li><strong>Milestones (Jalons) :</strong> Regroupez des issues et des PRs/MRs en milestones pour suivre l'avancement vers une version ou un objectif spécifique.</li>
					<li><strong>Assignations :</strong> Assignez des issues aux membres de l'équipe pour clarifier qui est responsable de quoi.</li>
				</ul>

				<h3>Stratégies de Merge des PRs/MRs sur les Plateformes</h3>
				<p>Lorsque une PR/MR est prête, les plateformes offrent généralement plusieurs options pour l'intégrer :</p>
				<ul>
					<li><strong>Merge Commit (Créer un commit de fusion) :</strong>
						<ul>
							<li>C'est l'option par défaut sur beaucoup de plateformes (ex: le bouton "Merge pull request" de GitHub).</li>
							<li>Tous les commits de la branche de fonctionnalité sont conservés, et un nouveau commit de merge est créé sur la branche cible pour lier les historiques.</li>
							<li><strong>Avantages :</strong> Préserve tout l'historique de la branche de fonctionnalité, y compris les commits individuels. Le point de merge est clairement identifiable.</li>
							<li><strong>Inconvénients :</strong> Peut rendre l'historique de la branche principale plus "bruyant" avec de nombreux commits de merge si les branches de fonctionnalités ont beaucoup de petits commits intermédiaires.</li>
						</ul>
					</li>
					<li><strong>Squash and Merge (Écraser et fusionner) :</strong>
						<ul>
							<li>Combine tous les commits de la branche de fonctionnalité en un seul commit sur la branche cible. Le message de ce commit unique peut être édité à partir des messages des commits originaux.</li>
							<li><strong>Avantages :</strong> Maintient un historique de la branche principale très propre et linéaire, avec un seul commit par fonctionnalité ou PR mergée.</li>
							<li><strong>Inconvénients :</strong> Perd la granularité de l'historique de la branche de fonctionnalité (les commits individuels de développement ne sont plus visibles sur la branche principale).</li>
						</ul>
					</li>
					<li><strong>Rebase and Merge (Rebaser et fusionner) :</strong>
						<ul>
							<li>Prend tous les commits de la branche de fonctionnalité, les rebase sur la dernière version de la branche cible, puis les ajoute à la branche cible sans créer de commit de merge (effectue un fast-forward si possible).</li>
							<li><strong>Avantages :</strong> Crée un historique parfaitement linéaire sur la branche principale, sans commits de merge. Les commits individuels de la fonctionnalité sont préservés.</li>
							<li><strong>Inconvénients :</strong> Réécrit l'historique des commits de la branche de fonctionnalité (nouveaux SHA). Peut rendre plus complexe le suivi de quand exactement une branche a été "mergée" si l'on ne regarde que le graphe. Nécessite que les contributeurs soient à l'aise avec le rebase de leurs branches.</li>
						</ul>
					</li>
				</ul>
				<p>Le choix de la stratégie dépend des préférences de l'équipe et du projet. Beaucoup d'équipes optent pour "Squash and Merge" ou "Rebase and Merge" pour garder un historique <code>main</code> propre, tout en s'assurant que les PRs elles-mêmes contiennent des commits bien structurés.</p>

				<h3>Forks et Contribution à des Projets Externes</h3>
				<p>Lorsque vous voulez contribuer à un projet open source auquel vous n'avez pas les droits de push directs, le workflow typique est "Fork & Pull Request" :</p>
				<ol>
					<li><strong>Forker le dépôt :</strong> Sur la plateforme (GitHub, GitLab), créez une copie personnelle (un "fork") du dépôt original sous votre propre compte.</li>
					<li><strong>Cloner votre fork :</strong> Clonez votre fork sur votre machine locale : <code>git clone https://github.com/VOTRE_NOM_UTILISATEUR/nom-du-projet.git</code></li>
					<li><strong>Configurer un remote <code>upstream</code> :</strong> Ajoutez le dépôt original comme un remote pour pouvoir récupérer ses mises à jour : <code>git remote add upstream https://github.com/PROPRIETAIRE_ORIGINAL/nom-du-projet.git</code></li>
					<li><strong>Créer une branche de fonctionnalité :</strong> Travaillez toujours sur une branche dédiée : <code>git checkout -b ma-contribution</code></li>
					<li><strong>Faire vos modifications et commits.</strong></li>
					<li><strong>Pousser votre branche sur votre fork :</strong> <code>git push origin ma-contribution</code></li>
					<li><strong>Ouvrir une Pull Request :</strong> Depuis votre fork sur la plateforme, ouvrez une PR ciblant la branche appropriée du dépôt <code>upstream</code> (original).</li>
					<li><strong>Maintenir son fork et sa branche à jour :</strong> Pendant que votre PR est en revue, le projet <code>upstream</code> peut évoluer. Pour mettre votre branche à jour :
						<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier les commandes pour mettre à jour un fork">Copier</button>
	<code>git checkout main # ou la branche principale de votre fork
	git fetch upstream
	git merge upstream/main # Mettre à jour votre main local avec le main de l'upstream
	git checkout ma-contribution
	git rebase main # Rebaser votre branche de contribution sur votre main à jour
	git push origin ma-contribution --force-with-lease # Mettre à jour la PR (force-push nécessaire après rebase)</code></pre>
					</li>
				</ol>

				<h3>Utilisation des "Draft PRs" / "WIP PRs"</h3>
				<p>La plupart des plateformes permettent de créer des Pull Requests en mode "Brouillon" (Draft) ou de les marquer comme "Work In Progress" (WIP) dans leur titre. C'est utile lorsque :</p>
				<ul>
					<li>Vous voulez obtenir un feedback préliminaire sur une idée ou une approche avant que le code ne soit finalisé.</li>
					<li>Vous voulez utiliser l'intégration continue (CI) de la PR pour lancer des tests sur votre branche, même si elle n'est pas prête pour une revue complète.</li>
					<li>Cela signale aux réviseurs potentiels que la PR n'est pas encore prête à être mergée.</li>
				</ul>
				<p>Une fois prête, vous pouvez convertir la Draft PR en une PR normale pour une revue formelle.</p>
			</section>

		</div><!-- Fin .container -->
	</div><!-- Fin .contentWithToc -->

	<footer>
		<div class="container">
			<p class="m-0">Cours réalisé par <strong>G.G. Paterne</strong> - Tous droits réservés</p>
		</div>
	</footer>

	<!-- Bouton Scroll to Top -->
	<button type="button" class="btn btn-danger btn-floating" id="btnScrollTop" data-mdb-ripple-color="light">
		↑
	</button>

	<!-- MDB JavaScript -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/8.1.0/mdb.min.js">
	</script>

	<!-- Prism.js pour coloration syntaxique -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js">
	</script>
	<!-- Custom JavaScript -->
	<script src="script.js"></script>
</body>

</html>