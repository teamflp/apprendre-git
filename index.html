<!DOCTYPE html>
<html lang="fr">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="author" content="G.G. Paterne" />
	<meta name="description" content="Cours complet Git avec fonctionnalités avancées">
	<title>Cours Complet Git - G.G. Paterne</title>

	<!-- MDB CSS (Material Design for Bootstrap) -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/8.1.0/mdb.min.css" />
	<!-- Prism.js CSS pour coloration syntaxique -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
	<!-- Font Awesome (icônes) -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" />
	<!-- Custom CSS -->
	<link rel="stylesheet" href="styles.css" />
</head>

<body>

	<!-- Barre de progression -->
	<div id="readingProgress"></div>

	<!-- Barre top mobile -->
	<nav class="navbar navbar-light bg-light d-md-none" id="menuTopBar">
		<div class="container-fluid">
			<!-- Titre / Logo -->
			<span class="navbar-brand fw-bold">Cours Git</span>

			<!-- Bouton Hamburger -->
			<button class="navbar-toggler" type="button" id="hamburgerBtn" style="border:none; background:none;" aria-label="Ouvrir/fermer le menu de navigation" aria-expanded="false" aria-controls="navbarTOC">
				<i class="fas fa-bars" aria-hidden="true"></i>
			</button>
		</div>
	</nav>

	<!-- Menu Table des Matières (Responsive) -->
	<nav id="navbarTOC"> <!-- The ID is used by aria-controls -->
		<h5>Table des Matières</h5>
		<a href="#introduction">1. Introduction</a>
		<a href="#installation">2. Installation & Config</a>
		<a href="#depots">3. Dépôts</a>
		<a href="#modifications">4. Suivi & Commit</a>
		<a href="#branches">5. Branches</a>
		<a href="#fusion">6. Merge & Conflits</a>
		<a href="#rebase">7. Rebase</a>
		<a href="#comparaison">8. Comparaison & Analyse</a>
		<a href="#annuler">9. Annuler/Commits</a>
		<a href="#stash">10. Stash</a>
		<a href="#depots-distants">11. Distants & Collab</a>
		<a href="#tags">12. Tags</a>
		<a href="#submodules">13. Submodules</a>
		<a href="#avancees">14. Avancées & Utilitaires</a>
		<a href="#bonnes-pratiques">15. Bonnes Pratiques</a>
		<a href="#commandes-avancees-git">16. Commandes Avancées de Git</a>
		<a href="#tableau-commands">17. Tableau Complet</a>
		<a href="#exemples">18. Exemples Concrets</a>
		<a href="#exercices-pieges">19. Exercices & Pièges</a>
		<a href="#commit-conventions">20. Conventions Commit</a>
		<a href="#github-actions">21. CI/CD GitHub</a>
		<a href="#glossaire">22. Glossaire Git</a>
		<a href="#conclusion">23. Conclusion</a>
		<a href="#workflows">24. Git Workflows</a>
		<a href="#hooks-git">25. Hooks Git</a>
		<a href="#gitattributes">26. Fins de Ligne & .gitattributes</a>
		<a href="#git-rerere">27. `git rerere`</a>
		<a href="#collaboration-plateformes">28. Collaboration Avancée sur Plateformes</a>

		<hr />
		<button class="btn btn-sm btn-dark" id="toggleDarkMode" aria-pressed="false" aria-label="Basculer le mode d'affichage entre clair et sombre">Dark Mode</button>
	</nav>


	<!-- Contenu principal (décalé par rapport au menu) -->
	<div class="contentWithToc">

		<!-- Hero -->
		<div class="hero">
			<div class="container">
				<h1 class="fw-bold">Apprendre à utiliser les commandes Git</h1>
				<p class="fst-italic">Par <strong>G.G. Paterne</strong></p>
			</div>
		</div>

		<div class="container my-4">

			<!-- Recherche code -->
			<input type="text" class="form-control" id="searchBar" placeholder="Filtrer les snippets de code…" />

			<!-- (1) INTRODUCTION -->
			<section id="introduction">
				<h2>1. Introduction à Git</h2>
				<h3>Qu’est-ce que Git ?</h3>
				<p>
					Git est un outil (logiciel) pour suivre les changements dans le code.
					Il permet de créer un historique de toutes les modifications.
					On peut aussi travailler à plusieurs dessus, sans se marcher sur les pieds.
				</p>
				<p><strong>Pourquoi utiliser Git ?</strong></p>
				<ul>
					<li>Revenir à une version antérieure si on casse quelque chose.</li>
					<li>Travailler à plusieurs sur le même projet, mais sur différentes branches.</li>
					<li>Garder un historique de tous les commits (changements).</li>
				</ul>


				<!-- Bouton de téléchargement -->
				<a href="Apprendre-git-par-la-pratique.pdf" class="btn btn-primary mt-3" download="CoursCompletGit">
					<i class="fas fa-download"></i>Télécharger le cours complet (PDF)
				</a>

				<hr />
			</section>

			<!-- (2) INSTALLATION & CONFIG -->
			<section id="installation">
				<h2>2. Installation et configuration</h2>
				<h3>Installation</h3>
				<p>
					Pour utiliser Git, on doit l’installer sur l’ordinateur.
					Sur Linux Ubuntu/Debian, on peut faire :
				</p>
				<p>
					Sur Windows ou Mac, on peut télécharger l’installeur sur le site officiel :
					<a href="https://git-scm.com/download" target="_blank">https://git-scm.com/download</a>
				</p>

<pre class="language-bash">
	<div>
		<button class="btn btn-light copy-btn" aria-label="Copier le bloc de code d'installation">Copier</button>
	</div>
	
<code>
sudo apt update
sudo apt install git
</code>
</pre>

	<p>Ces deux commandes mettent à jour la liste des paquets et installent Git.</p>


				<h3>Configuration globale</h3>
				<p>Donner son nom et email pour que Git sache qui fait les commits :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier le bloc de code de configuration globale">Copier</button>
<code>
git config --global user.name "Votre Nom" 
git config --global user.email "votre.email@example.com"</code>
</pre>
				<p>On peut choisir son éditeur préféré, comme nano ou vim :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git config --global core.editor "nano"</code>
</pre>
<p>	
	Cette commande configure nano comme éditeur par défaut.
</p>
				<p>Pour voir toutes les configs :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git config --list</code>
</pre>
			</section>

			<!-- (3) DEPOTS -->
			<section id="depots">
				<h2>3. Initialiser et gérer un dépôt</h2>
				<h3>Initialiser un nouveau dépôt</h3>
				<p>
					Pour commencer à suivre un projet avec Git, on fait :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git init</code>
</pre>
				<p>
					Cela crée un dossier caché <code>.git</code> qui contient toutes les infos de suivi (commits,
					historique...).
				</p>

				<h3>Cloner un dépôt existant</h3>
				<p>
					Si un projet existe déjà sur GitHub ou ailleurs, on peut le copier localement :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git clone https://github.com/utilisateur/projet.git</code>
</pre>
				<p>
					Cela crée un dossier avec tout le code et l’historique.
				</p>

				<h3>Ajouter un dépôt distant</h3>
				<p>
					Pour lier son dossier local à un dépôt en ligne (ex: GitHub), on utilise :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git remote add origin https://github.com/utilisateur/projet.git</code>
</pre>

				<h3>Lister / Renommer / Supprimer un dépôt distant</h3>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git remote -v              # Voir les dépôts distants
git remote rename origin old   # Renommer 'origin' en 'old'
git remote remove origin       # Supprimer le remote 'origin'</code>
</pre>
			</section>

			<!-- (4) SUIVI & COMMIT -->
			<section id="modifications">
				<h2>4. Suivi et validation des modifications</h2>
				<h3>Vérifier l'état</h3>
				<p>Pour voir quels fichiers sont modifiés ou non suivis :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git status</code>
</pre>

				<h3>Ajouter des fichiers</h3>
				<p>
					Avant de faire un commit, on doit ajouter les fichiers dans la “zone de staging” :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git add fichier.txt
git add .</code>
</pre>
				<p>
					Le premier ajoute un seul fichier, le second ajoute tout ce qui est modifié/nouveau.
				</p>

				<h3>Créer un commit</h3>
				<p>
					Pour enregistrer définitivement les changements dans l’historique :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git commit -m "Description du changement"</code>
</pre>
				<p>On peut tout faire d’un coup (pour les fichiers déjà suivis) : <code>git commit -am "message"</code>
				</p>

				<h3>Afficher l’historique</h3>
				<p>Voir la liste de tous les commits déjà faits :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git log
git log --oneline
git log --graph --decorate --oneline</code>
</pre>
			</section>

			<!-- (5) BRANCHES -->
			<section id="branches">
				<h2>5. Branches et navigation</h2>
				<h3>Créer et lister</h3>
				<p>Pour voir ou créer une branche :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git branch
git branch nouvelle-branche</code>
</pre>

				<h3>Changer de branche</h3>
				<p>On se déplace sur une branche existante :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git checkout nouvelle-branche</code>
</pre>
				<p>Ou on la crée et on y va d’un coup :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git checkout -b nouvelle-branche</code>
</pre>

				<h3>Renommer / Supprimer une branche</h3>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git branch -m ancien_nom nouveau_nom   # Renommer
git branch -d branche            # Supprimer une branche fusionnée
git branch -D branche            # Supprimer quand pas fusionnée</code>
</pre>
			</section>

			<!-- (6) MERGE & CONFLITS -->
			<section id="fusion">
				<h2>6. Merge (Fusion) et Conflits</h2>
				<h3>Fusionner deux branches</h3>
				<p>
					On se place sur la branche où on veut intégrer les changements (souvent main ou master), puis on
					merge :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git checkout main
git merge nouvelle-branche</code>
</pre>

				<h3>Conflits</h3>
				<p>
					S’il y a des conflits, Git arrête le merge et on doit résoudre à la main :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git add fichier_conflit.txt
git commit -m "Résolution du conflit"</code>
</pre>

				<h3>Merge “no fast-forward”</h3>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git merge --no-ff nouvelle-branche</code>
</pre>
				<p>
					Crée un commit de merge même si on peut faire un fast-forward, pour garder une trace.
				</p>
			</section>

			<!-- (7) REBASE -->
			<section id="rebase">
				<h2>7. Rebase (Réécriture de l’historique)</h2>

				<h3>7.1. Qu’est-ce que <code>git rebase</code> ?</h3>
				<p>
					La commande <code>git rebase</code> est l'une des fonctionnalités les plus puissantes de Git, mais aussi l'une de celles qui nécessitent le plus de prudence. Son objectif principal est de **réécrire l'historique des commits** pour le rendre plus linéaire, propre et compréhensible.
				</p>
				<p>
					Conceptuellement, un rebase prend une série de commits d'une branche et les "rejoue" un par un sur une autre base (un autre commit, souvent la tête d'une autre branche). Cela contraste avec <code>git merge</code>, qui intègre les changements en créant un nouveau commit de fusion qui relie les deux historiques.
				</p>
				<h4>Avantages du Rebase :</h4>
				<ul>
					<li><strong>Historique linéaire et propre :</strong> Le principal avantage est un historique de projet sans les "bulles" ou les ramifications créées par les commits de merge. Cela rend le log plus facile à lire et à analyser.</li>
					<li><strong>Nettoyage des commits locaux :</strong> Avant de partager votre travail (par exemple, via une Pull Request), vous pouvez utiliser le rebase interactif pour réorganiser, fusionner, modifier ou supprimer vos commits locaux, présentant ainsi un ensemble de changements cohérents et bien décrits.</li>
					<li><strong>Facilite la revue de code :</strong> Des Pull Requests (PRs) avec un historique propre et linéaire sont plus faciles à examiner pour les relecteurs.</li>
				</ul>
				<h4>Quand utiliser <code>git rebase</code> ?</h4>
				<ul>
					<li>Principalement sur vos **branches de fonctionnalités locales** avant de les fusionner dans une branche principale (comme `main` ou `develop`).</li>
					<li>Pour **mettre à jour votre branche de fonctionnalité** avec les derniers changements de la branche principale.</li>
					<li>Pour **nettoyer votre historique local** avant de le pousser vers un dépôt partagé.</li>
				</ul>
				<div class="alert alert-warning" role="alert">
					<strong>Note importante :</strong> Le rebase réécrit l'historique. Cela signifie que les SHA-1 des commits rebasés changent. C'est la raison pour laquelle il faut être très prudent avec les branches qui ont déjà été partagées (voir <a href="#rebase-golden-rule">La Règle d'Or du Rebase</a>).
				</div>

				<h3>7.2. Rebase Simple : Mettre à jour votre branche</h3>
				<p>
					Le cas d'usage le plus courant du rebase est de mettre à jour votre branche de fonctionnalité avec les derniers changements de la branche principale (par exemple, `main`). Cela permet d'intégrer les nouveautés avant de continuer votre travail ou de proposer une fusion.
				</p>
				<p>Supposons que vous travaillez sur une branche <code>feature/ma-nouvelle-fonction</code> et que la branche <code>main</code> a reçu de nouveaux commits :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier le code pour un rebase simple">Copier</button>
<code># 1. Assurez-vous que votre branche principale locale (main) est à jour
git checkout main
git pull origin main

# 2. Retournez sur votre branche de fonctionnalité
git checkout feature/ma-nouvelle-fonction

# 3. Rebasez votre branche sur main
git rebase main</code></pre>
				<p>
					Git va alors prendre tous les commits de <code>feature/ma-nouvelle-fonction</code> qui ne sont pas déjà dans <code>main</code>, les mettre de côté temporairement, avancer la tête de <code>feature/ma-nouvelle-fonction</code> pour qu'elle pointe sur le dernier commit de <code>main</code>, puis réappliquer vos commits un par un.
				</p>
				<h4>Utilisation de <code>git pull --rebase</code></h4>
				<p>
					Lorsque vous travaillez sur une branche locale (qui peut ou non suivre une branche distante) et que vous voulez récupérer les mises à jour de la branche distante correspondante, utiliser <code>git pull --rebase</code> est souvent préférable à un simple <code>git pull</code> (qui effectue un merge par défaut).
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git pull --rebase">Copier</button>
<code># Sur votre branche locale, pour la mettre à jour depuis son équivalent distant
git pull --rebase origin nom-de-la-branche</code></pre>
				<p>
					Cela va d'abord récupérer les commits distants (fetch), puis rebaser vos commits locaux (ceux qui ne sont pas encore sur le distant) par-dessus les nouveaux commits récupérés. Cela évite la création d'un commit de merge local non nécessaire et maintient un historique linéaire. C'est une pratique très courante pour les branches de fonctionnalités personnelles.
				</p>
				<p>Vous pouvez configurer Git pour que `pull` utilise `--rebase` par défaut pour certaines branches ou globalement :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la configuration pour pull --rebase par défaut">Copier</button>
<code># Pour la branche courante
git config pull.rebase true

# Globalement pour toutes les nouvelles branches (attention, impacte tous vos projets)
# git config --global pull.rebase true</code></pre>


				<h3>7.3. Rebase Interactif (<code>git rebase -i</code>) : Peaufiner vos commits</h3>
				<p>
					Le rebase interactif est un outil extrêmement puissant pour nettoyer et réorganiser votre historique de commits local avant de le partager. Il vous permet de modifier des messages de commit, de fusionner des commits, de les supprimer, de les réordonner, etc.
				</p>
				<p>Pour lancer un rebase interactif, vous spécifiez la base sur laquelle vous voulez rebaser. Cela peut être un nom de branche, un SHA de commit, ou une référence comme `HEAD~N` (où N est le nombre de commits à partir de HEAD que vous voulez inclure dans le rebase).</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande de base pour un rebase interactif">Copier</button>
<code># Rebaser interactivement les 3 derniers commits
git rebase -i HEAD~3

# Rebaser interactivement tous les commits depuis la branche 'main' (exclus)
git rebase -i main</code></pre>
				<p>
					Après avoir lancé cette commande, votre éditeur de texte configuré s'ouvrira avec une liste des commits qui sont sur le point d'être rebasés. Chaque ligne représente un commit, commençant par le mot-clé `pick` :
				</p>
<pre class="language-text">
	<button class="btn btn-light copy-btn" aria-label="Copier l'exemple d'écran de rebase interactif">Copier</button>
<code>pick a1b2c3d Ajout fonctionnalité X (partie 1)
pick e4f5g6h Commit de travail intermédiaire
pick i7j8k9l Finalisation fonctionnalité X

# Rebase 1234567..i7j8k9l onto 1234567 (3 commands)
#
# Commands:
# p, pick <commit> = use commit
# r, reword <commit> = use commit, but edit the commit message
# e, edit <commit> = use commit, but stop for amending
# s, squash <commit> = use commit, but meld into previous commit
# f, fixup <commit> = like "squash", but discard this commit's log message
# x, exec <command> = run command (the rest of the line) using shell
# b, break = stop here (continue rebase later with 'git rebase --continue')
# d, drop <commit> = remove commit
# l, label <label> = label current HEAD with a name
# t, reset <label> = reset HEAD to a label
# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]
# .       create a merge commit using the original merge commit's
# .       message (or the oneline, if no original merge commit was
# .       specified). Use -c <commit> to re-create the merge commit
# .       using the same log message as <commit>.
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#</code></pre>
				<p>En bas de cette liste, vous trouverez des instructions sur les commandes (actions) que vous pouvez utiliser. Voici les plus courantes :</p>
				<ul>
					<li><strong><code>pick</code> (ou <code>p</code>) : Utiliser le commit.</strong>
						<p>C'est l'action par défaut. Le commit sera inclus dans l'historique rebasé tel quel.</p>
					</li>
					<li><strong><code>reword</code> (ou <code>r</code>) : Modifier le message du commit.</strong>
						<p>Si vous marquez un commit avec <code>reword</code>, Git s'arrêtera après avoir appliqué ce commit et vous invitera à modifier son message. Très utile pour corriger des typos ou clarifier un message de commit.</p>
						<p><em>Exemple :</em> Changez <code>pick</code> en <code>reword</code> sur la ligne du commit souhaité. Sauvegardez et fermez. Git ouvrira l'éditeur pour ce message de commit.</p>
					</li>
					<li><strong><code>edit</code> (ou <code>e</code>) : Modifier le contenu du commit.</strong>
						<p>Utilisez <code>edit</code> si vous voulez amender les changements introduits par ce commit (ajouter des fichiers, modifier du code) ou même scinder le commit en plusieurs plus petits.</p>
						<p>Lorsque Git rencontre un commit marqué <code>edit</code>, le processus de rebase s'interrompt. Vous pouvez alors faire vos modifications (ex: <code>git add ...</code>, <code>git commit --amend</code>), puis continuer le rebase avec <code>git rebase --continue</code>.</p>
					</li>
					<li><strong><code>squash</code> (ou <code>s</code>) : Fusionner le commit avec le commit précédent.</strong>
						<p>Le commit marqué <code>squash</code> est fusionné dans le commit qui le précède. Git ouvrira ensuite un éditeur pour vous permettre de combiner les messages des commits (ou d'en écrire un nouveau).</p>
						<p>Parfait pour combiner plusieurs petits commits ("WIP", "typo") en un seul commit de fonctionnalité cohérent.</p>
						<p><em>Exemple :</em></p>
<pre class="language-text">
	<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de squash">Copier</button>
<code>pick a1b2c3d Ajout de la fonctionnalité X (partie 1)
s e4f5g6h Correction typo sur X
s i7j8k9l Ajustements mineurs sur X</code></pre>
						<p>Ces trois commits deviendront un seul. Git vous demandera de fournir le message final.</p>
					</li>
					<li><strong><code>fixup</code> (ou <code>f</code>) : Fusionner avec le précédent, ignorer le message.</strong>
						<p>Similaire à <code>squash</code>, mais <code>fixup</code> jette le message du commit "fixup" et utilise uniquement le message du commit précédent. Le message du commit "fixé" n'est même pas présenté pour édition.</p>
						<p>Très pratique pour des petites corrections rapides où le message du commit original est suffisant.</p>
						<p><em>Exemple :</em></p>
<pre class="language-text">
	<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de fixup">Copier</button>
<code>pick a1b2c3d Ajout fonctionnalité Y
f b2c3d4e Oups, oubli d'un fichier pour Y</code></pre>
						<p>Le deuxième commit sera intégré au premier, et seul le message "Ajout fonctionnalité Y" sera conservé.</p>
					</li>
					<li><strong><code>drop</code> (ou <code>d</code>) : Supprimer complètement le commit.</strong>
						<p>Si un commit n'est plus nécessaire, vous pouvez le supprimer avec <code>drop</code> (ou en supprimant simplement sa ligne). Le commit et ses changements disparaîtront de l'historique. À utiliser avec précaution.</p>
					</li>
					<li><strong>Réordonner les commits :</strong>
						<p>Vous pouvez simplement changer l'ordre des lignes dans le fichier de rebase interactif pour changer l'ordre dans lequel les commits sont appliqués.</p>
					</li>
				</ul>
				<div class="alert alert-info" role="alert">
					<strong>Conseils pour le rebase interactif :</strong>
					<ul>
						<li>Ne modifiez que les actions (<code>pick</code>, <code>squash</code>, etc.) ou l'ordre des lignes. Ne supprimez pas les SHA des commits.</li>
						<li>Si vous faites une erreur en éditant le fichier d'instructions, vous pouvez généralement fermer l'éditeur sans sauvegarder, et Git annulera le rebase (ou utilisez <code>git rebase --abort</code>).</li>
						<li>Après avoir sauvegardé et fermé le fichier, Git appliquera les actions. Soyez prêt à <a href="#rebase-conflict-resolution">résoudre des conflits</a>.</li>
					</ul>
				</div>

				<h3 id="rebase-conflict-resolution">7.4. Gestion des Conflits pendant un Rebase</h3>
				<p>
					Des conflits peuvent survenir pendant un rebase si les changements que vous essayez de réappliquer entrent en conflit avec des changements sur la branche de base, ou même avec des changements de vos propres commits précédents qui ont été modifiés (par exemple, si vous réordonnez des commits qui touchent aux mêmes lignes).
				</p>
				<p>Lorsque Git rencontre un conflit, le processus de rebase s'interrompt et vous informe du fichier (ou des fichiers) en conflit. La procédure de résolution est la suivante :</p>
				<ol>
					<li>
						<strong>Identifier et résoudre le conflit :</strong> Ouvrez le(s) fichier(s) concerné(s). Git y aura inséré les marqueurs de conflit habituels (<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>). Modifiez le fichier pour obtenir le résultat souhaité, puis supprimez les marqueurs.
					</li>
					<li>
						<strong>Ajouter le fichier résolu au staging :</strong>
						<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git add après résolution de conflit de rebase">Copier</button>
<code>git add &lt;fichier_resolu_1&gt; [fichier_resolu_2...]</code></pre>
					</li>
					<li>
						<strong>Poursuivre le rebase :</strong>
						<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git rebase --continue">Copier</button>
<code>git rebase --continue</code></pre>
						<p>Git tentera alors d'appliquer le reste des commits.</p>
					</li>
				</ol>
				<h4>Options en cas de problème majeur lors d'un conflit :</h4>
				<ul>
					<li>
						<strong>Annuler complètement le rebase :</strong> Si la résolution des conflits devient trop complexe ou si vous n'êtes pas sûr de ce que vous faites, vous pouvez toujours revenir à l'état d'avant le rebase :
						<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git rebase --abort">Copier</button>
<code>git rebase --abort</code></pre>
					</li>
					<li>
						<strong>Sauter un commit (avec prudence) :</strong> Si un commit particulier cause des problèmes insolubles et que vous décidez qu'il n'est pas essentiel (ou que vous le réintroduirez différemment plus tard), vous pouvez dire à Git de l'ignorer et de continuer :
						<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git rebase --skip">Copier</button>
<code>git rebase --skip</code></pre>
						<p><strong>Attention :</strong> Utiliser <code>--skip</code> signifie que les changements de ce commit seront perdus. Utilisez cette option avec une extrême prudence.</p>
					</li>
				</ul>
				<h4>Stratégies de résolution automatique (<code>-Xours</code> ou <code>-Xtheirs</code>)</h4>
				<p>
					Lors d'un rebase (ou d'un merge), vous pouvez indiquer à Git une stratégie pour résoudre automatiquement les conflits en privilégiant "votre" version (<code>ours</code>, c'est-à-dire les changements de la branche que vous rebasez) ou "leur" version (<code>theirs</code>, c'est-à-dire les changements de la branche sur laquelle vous rebasez).
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande de rebase avec stratégie de résolution">Copier</button>
<code># Pendant un rebase, si des conflits surviennent sur un commit,
# et que vous voulez automatiquement accepter les changements de la branche de base (main) :
git checkout --theirs chemin/vers/le/fichier_en_conflit.txt
git add chemin/vers/le/fichier_en_conflit.txt
# Puis git rebase --continue

# Ou pour privilégier systématiquement "theirs" lors d'un rebase (risqué si non compris) :
# git rebase -Xtheirs main
# (Cette option est passée à la commande rebase initiale, pas pendant la résolution)</code></pre>
				<p>Ces options sont puissantes mais peuvent masquer des problèmes si elles sont utilisées sans discernement. Il est souvent préférable de résoudre les conflits manuellement pour s'assurer de l'intégrité du code.</p>


				<h3>7.5. Rebase Avancé avec <code>--onto</code></h3>
				<p>
					L'option <code>--onto</code> est l'une des formes les plus flexibles du rebase. Elle vous permet de spécifier explicitement où les commits doivent être déplacés, indépendamment de la position actuelle de HEAD ou de la branche de base implicite.
				</p>
				<p>La syntaxe générale est :</p>
				<code>git rebase --onto &lt;nouvelle_base&gt; &lt;ancienne_base_exclusive&gt; [&lt;branche_ou_commit_a_rebaser_inclusif&gt;]</code>
				<ul>
					<li><code>&lt;nouvelle_base&gt;</code> : Le commit sur lequel les nouveaux commits seront basés.</li>
					<li><code>&lt;ancienne_base_exclusive&gt;</code> : Le commit "jusqu'auquel" (mais non inclus) les commits de la branche d'origine sont ignorés. Les commits qui viennent *après* celui-ci seront ceux rebasés.</li>
					<li><code>&lt;branche_ou_commit_a_rebaser_inclusif&gt;</code> : (Optionnel) Le commit ou la branche jusqu'où (inclus) les commits doivent être pris. Si omis, Git utilise HEAD (le commit actuel de la branche sur laquelle vous êtes).</li>
				</ul>
				<h4>Cas d'usage de <code>--onto</code> :</h4>
				<p><strong>1. Déplacer une série de commits d'une branche à une autre (transplantation) :</strong></p>
				<p>Imaginez la situation suivante :</p>
				<pre>A - B - C - D (main)
     \
      E - F - G (featureA)
           \
            H - I (featureB, basée sur F de featureA)</pre>
				<p>Vous réalisez que <code>featureB</code> (commits H et I) devrait en fait être basée directement sur <code>main</code> (commit D) plutôt que sur <code>featureA</code>. Vous voulez déplacer H et I.</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de git rebase --onto pour transplanter">Copier</button>
<code># Sur la branche featureB (ou en spécifiant featureB à la fin)
git rebase --onto main featureA featureB
# Ou plus précisément, si featureA est sur F et featureB sur I:
# git rebase --onto D F I
# (en utilisant les SHA des commits ou noms de branches/tags)
</code></pre>
				<p>Cela signifie : "Prends les commits de `featureB` qui viennent après `featureA` (donc H et I), et rejoue-les sur `main`."</p>
				<p>L'historique deviendrait :</p>
				<pre>A - B - C - D (main)
     \           \
      \           H' - I' (featureB)
       \
        E - F - G (featureA)</pre>

				<p><strong>2. Réorganiser une branche en excluant des commits du milieu :</strong></p>
				<p>Si votre branche <code>feature</code> a des commits <code>X-Y-Z</code> et vous voulez la rebaser sur `main` mais seulement avec `X` et `Z`, en omettant `Y` :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de git rebase --onto pour exclure">Copier</button>
<code># Supposons que feature est sur Z.
# Pour rebaser X sur main, puis Z sur ce nouveau X' :
# D'abord, rebaser X sur main:
git rebase --onto main Y X  # (Rebase le commit X, qui est après Y (exclu), sur main)
# Cela crée X'. HEAD est maintenant sur X'.
# Ensuite, rebaser Z sur X':
git rebase --onto HEAD X Z # (Rebase le commit Z, qui est après X (exclu), sur HEAD (X'))
</code></pre>
				<p>Cependant, pour ce type d'opération (supprimer un commit du milieu), un <a href="#rebase-interactive">rebase interactif</a> avec l'action <code>drop</code> sur le commit Y est généralement plus simple.</p>
				<p><code>--onto</code> est particulièrement utile lorsque vous avez besoin de "greffer" une séquence de commits d'un endroit à un autre de manière très ciblée, souvent en conjonction avec des SHA de commits spécifiques.</p>


				<h3 id="rebase-golden-rule">7.6. La Règle d'Or du Rebase : Les Dangers et Précautions</h3>
				<p>
					La flexibilité du rebase vient avec une responsabilité majeure, encapsulée dans ce qu'on appelle souvent la **"Règle d'Or du Rebase"** :
				</p>
				<div class="alert alert-danger" role="alert">
					<strong>Ne JAMAIS rebaser des commits qui ont déjà été poussés sur un dépôt partagé et sur lesquels d'autres personnes pourraient avoir basé leur travail.</strong>
				</div>
				<h4>Pourquoi cette règle est-elle si cruciale ?</h4>
				<p>
					Lorsque vous rebasez, vous réécrivez l'historique. Même si les changements de code (le "patch") sont les mêmes, les commits rebasés sont de nouveaux commits avec de nouveaux SHA-1.
				</p>
				<p>Si vous rebasez une branche que d'autres ont déjà clonée ou pullée :</p>
				<ul>
					<li>Leur historique local devient **divergent** par rapport au nouvel historique que vous venez de créer.</li>
					<li>S'ils essaient de puller vos changements rebasés, Git verra deux historiques différents et tentera de les fusionner, créant des doublons de commits et un historique très confus.</li>
					<li>Pour "corriger" cela de votre côté après avoir rebasé une branche poussée, vous seriez obligé d'utiliser <code>git push --force</code> (ou <code>--force-with-lease</code>). Cela écrase l'historique sur le dépôt distant avec votre version réécrite.</li>
					<li>Si vos collaborateurs ont basé leur propre travail sur l'ancien historique (avant votre rebase forcé), ils devront alors eux-mêmes effectuer des opérations complexes (souvent un autre rebase de leur travail sur votre nouvel historique) pour resynchroniser, ce qui est source d'erreurs et de frustration.</li>
				</ul>
				<h4>Quand le rebase est-il sûr et recommandé ?</h4>
				<ul>
					<li><strong>Sur vos commits locaux, non encore poussés :</strong> C'est le cas d'usage principal. Nettoyez votre historique autant que vous le souhaitez avant de le partager.</li>
					<li><strong>Sur une branche de fonctionnalité que vous êtes le seul à utiliser :</strong> Même si elle est poussée sur le distant (par exemple, pour une sauvegarde ou pour une PR pas encore mergée), si personne d'autre ne l'utilise comme base, vous *pouvez* la rebaser (mais vous devrez forcer le push).</li>
					<li><strong>Après communication et accord explicite avec votre équipe :</strong> Dans certains workflows d'équipe, il peut être acceptable de rebaser des branches partagées sous conditions strictes et avec une bonne coordination.</li>
				</ul>
				<h4>Que faire si vous avez rebasé une branche poussée par erreur ?</h4>
				<p>Si vous avez poussé la branche avant le rebase, puis l'avez rebasée et voulez maintenant la pousser à nouveau :</p>
				<ul>
					<li><strong><code>git push --force-with-lease origin nom-de-la-branche</code></strong> : C'est une alternative plus sûre à <code>git push --force</code>. Elle ne forcera la mise à jour que si la branche distante est dans l'état où vous pensez qu'elle est (c'est-à-dire, personne d'autre n'a poussé de nouveaux commits entre-temps). Si quelqu'un d'autre a poussé, le push sera rejeté, vous alertant d'un potentiel problème.</li>
					<li><strong><code>git push --force origin nom-de-la-branche</code></strong> : À utiliser en dernier recours et seulement si vous êtes absolument sûr que personne d'autre n'a pullé l'ancienne version de la branche ou si vous avez coordonné avec eux.</li>
				</ul>
				<p>En résumé, traitez l'historique des branches publiques (comme `main`, `develop`) et des branches de fonctionnalités partagées comme immuable une fois poussé. Réservez le rebase pour votre travail local ou pour des branches dont vous avez le contrôle total.</p>


				<h3>7.7. Se Rétablir d'un Rebase Problématique : <code>git reflog</code> à la Rescousse</h3>
				<p>
					Parfois, un rebase peut mal tourner : vous supprimez accidentellement un commit important, la résolution de conflits introduit des erreurs, ou l'historique devient confus. Heureusement, Git conserve un journal de toutes les positions de HEAD, appelé le **reflog**. C'est votre filet de sécurité.
				</p>
				<p>Pour voir le reflog :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git reflog">Copier</button>
<code>git reflog</code></pre>
				<p>Cela affichera une liste de toutes les opérations qui ont modifié HEAD, y compris les commits, les merges, les resets, et les rebases. Chaque entrée a un identifiant (par exemple, <code>HEAD@{2}</code>) et un SHA de commit.</p>
				<p><strong>Exemple de récupération :</strong></p>
				<p>Supposons que vous venez de terminer un rebase interactif, mais vous réalisez que vous avez fait une erreur. Vous lancez <code>git reflog</code> :</p>
<pre class="language-text">
	<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de sortie de git reflog">Copier</button>
<code>a1b2c3d HEAD@{0}: rebase -i (finish): returning to refs/heads/ma-branche
a1b2c3d HEAD@{1}: rebase -i (squash): Mon commit squashe
e4f5g6h HEAD@{2}: rebase -i (reword): Ancien message avant reword
i7j8k9l HEAD@{3}: rebase -i (start): checkout main
b0c1d2e HEAD@{4}: commit: Mon travail avant le rebase catastrophique
...</code></pre>
				<p>
					Vous pouvez voir l'état avant le début du rebase (par exemple, à <code>HEAD@{4}</code> avec le commit <code>b0c1d2e</code>). Pour revenir à cet état :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git reset --hard pour récupérer via reflog">Copier</button>
<code>git reset --hard HEAD@{4}
# Ou, de manière plus sûre, si vous voulez juste inspecter d'abord :
# git checkout HEAD@{4}
# (cela vous met en mode HEAD détachée, puis vous pouvez créer une nouvelle branche si besoin)</code></pre>
				<p>
					<code>git reset --hard</code> ramènera votre branche et votre répertoire de travail exactement à l'état où ils étaient au commit <code>b0c1d2e</code>. Le reflog est une bouée de sauvetage, mais il est spécifique à votre dépôt local et n'est pas partagé.
				</p>


				<h3>7.8. Rebase vs. Merge : Quelle Stratégie Choisir ?</h3>
				<p>
					Le débat "rebase ou merge ?" est l'un des plus courants dans le monde de Git. Les deux stratégies ont pour but d'intégrer des changements d'une branche à une autre, mais elles le font de manières différentes, avec des implications distinctes pour l'historique de votre projet.
				</p>
				<h4><code>git rebase</code></h4>
				<ul>
					<li><strong>Avantages :</strong>
						<ul>
							<li>Crée un historique linéaire, propre et facile à suivre.</li>
							<li>Évite les commits de merge "inutiles" qui peuvent polluer le log.</li>
							<li>Permet de nettoyer et d'organiser les commits d'une branche de fonctionnalité avant l'intégration.</li>
						</ul>
					</li>
					<li><strong>Inconvénients :</strong>
						<ul>
							<li>Réécrit l'historique (les SHA des commits changent). Dangereux si utilisé sur des branches partagées (voir <a href="#rebase-golden-rule">Règle d'Or</a>).</li>
							<li>Peut rendre plus difficile la compréhension du moment exact où une branche de fonctionnalité a été intégrée, car le contexte du merge est perdu.</li>
							<li>Les conflits doivent être résolus commit par commit, ce qui peut être fastidieux si la branche rebasée est longue et diverge beaucoup.</li>
						</ul>
					</li>
				</ul>

				<h4><code>git merge</code> (typiquement avec <code>--no-ff</code> pour préserver un commit de merge)</h4>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git merge --no-ff">Copier</button>
<code>git checkout main
git merge --no-ff ma-branche-feature</code></pre>
				<ul>
					<li><strong>Avantages :</strong>
						<ul>
							<li>Préserve l'historique exact tel qu'il s'est produit. Chaque intégration de branche est clairement marquée par un commit de merge.</li>
							<li>Est non destructif pour l'historique existant. Les SHA des commits originaux sont conservés.</li>
							<li>Plus simple à comprendre et à utiliser, surtout pour les débutants.</li>
							<li>Les conflits sont résolus une seule fois, au moment du merge.</li>
						</ul>
					</li>
					<li><strong>Inconvénients :</strong>
						<ul>
							<li>Peut rendre l'historique du projet "bruyant" et difficile à lire avec de nombreux commits de merge, surtout sur des projets avec beaucoup de branches et de contributeurs. Le graphe du log peut devenir complexe.</li>
							<li>Sans discipline (par exemple, squasher les commits d'une PR avant de la merger), l'historique principal peut se remplir de petits commits intermédiaires.</li>
						</ul>
					</li>
				</ul>

				<h4>Recommandations Générales et Approches Courantes :</h4>
				<ol>
					<li>
						<strong>Pour le travail local / branches de fonctionnalités personnelles :</strong>
						<ul>
							<li>Utilisez <code>git rebase</code> (et <code>git rebase -i</code>) fréquemment pour garder votre branche à jour avec la branche principale et pour nettoyer votre propre historique de commits avant de le partager.</li>
							<li>Utilisez <code>git pull --rebase</code> pour mettre à jour vos branches locales depuis le distant.</li>
						</ul>
					</li>
					<li>
						<strong>Pour l'intégration dans les branches principales (<code>main</code>, <code>develop</code>) :</strong>
						<ul>
							<li>**Option 1 (Workflow privilégiant le rebase) :** Avant de fusionner une branche de fonctionnalité dans `main`, rebasez-la interactivement pour nettoyer les commits, puis rebasez-la sur la dernière version de `main`. Ensuite, effectuez un fast-forward merge sur `main` (ou un merge simple qui sera fast-forward si possible). Cela maintient `main` complètement linéaire. C'est souvent fait via des Pull/Merge Requests où on demande au contributeur de rebaser sa branche.</li>
							<li>**Option 2 (Workflow privilégiant le merge) :** Fusionnez les branches de fonctionnalités dans `main` en utilisant explicitement <code>git merge --no-ff</code>. Cela crée un commit de merge qui documente l'intégration de la fonctionnalité. L'historique de la branche de fonctionnalité reste intact. C'est la stratégie par défaut de plateformes comme GitHub lors du clic sur "Merge pull request".</li>
							<li>**Option 3 (Workflow "Squash and Merge") :** Lors de l'intégration d'une Pull Request, tous les commits de la branche de fonctionnalité sont "squashés" en un seul commit sur la branche principale. Cela garde l'historique principal très propre (un commit par fonctionnalité/PR) mais perd la granularité de l'historique de la branche de fonctionnalité.</li>
						</ul>
					</li>
					<li>
						<strong>Cohérence d'équipe :</strong> Le plus important est que l'équipe se mette d'accord sur un workflow et s'y tienne. Les deux approches (rebase ou merge pour l'intégration) sont valides et ont leurs adeptes.
					</li>
				</ol>


				<h3>7.9. Options de Rebase Spécifiques</h3>
				<p>Outre les options déjà vues, quelques autres peuvent être utiles dans des cas spécifiques :</p>
				<ul>
					<li>
						<strong><code>--rebase-merges</code> (ou <code>-r</code>) :</strong>
						<p>
							Cette option, disponible dans les versions plus récentes de Git, permet de rebaser une branche qui contient elle-même des commits de merge. Contrairement au rebase standard qui "aplatit" l'historique en ne rejouant que les commits non-merge, <code>--rebase-merges</code> tente de recréer la structure de merge de votre branche par-dessus la nouvelle base. C'est utile si vous avez une branche de fonctionnalité complexe avec des merges intentionnels que vous souhaitez préserver.
						</p>
						<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git rebase --rebase-merges">Copier</button>
<code>git rebase -r main
# ou
git rebase --rebase-merges main</code></pre>
						<p>C'est une alternative plus moderne et souvent plus robuste à l'ancienne option <code>--preserve-merges</code> (maintenant dépréciée).</p>
					</li>
					<li>
						<strong><code>--autostash</code> :</strong>
						<p>Si vous avez des modifications non commitées dans votre répertoire de travail lorsque vous lancez un rebase, Git refusera de démarrer. L'option <code>--autostash</code> va automatiquement créer un stash temporaire de vos modifications, effectuer le rebase, puis réappliquer le stash.</p>
						<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git rebase --autostash">Copier</button>
<code>git rebase main --autostash</code></pre>
					</li>
				</ul>
				<p>
					La maîtrise de <code>git rebase</code> demande de la pratique et une bonne compréhension de ses implications. Commencez par l'utiliser sur des branches locales et des dépôts de test pour vous familiariser avec son comportement avant de l'appliquer dans des contextes collaboratifs plus complexes.
				</p>

			</section>

			<!-- (8) COMPARAISON & ANALYSE -->
			<section id="comparaison">
				<h2>8. Comparaison & Analyse</h2>
				<p>
					Quelques commandes utiles pour comparer ou analyser l’historique :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git diff                # Voir ce qui a changé avant commit
git diff --staged       # Voir ce qui est prêt à commit
git blame fichier       # Savoir qui a modifié chaque ligne
git bisect start        # Commencer la recherche binaire d’un bug
git bisect bad HEAD
git bisect good <commit_ou_tag>
git log -p              # Voir les changements en détail par commit
</code>
</pre>
			</section>

			<!-- (9) ANNULER/COMMITS -->
			<section id="annuler">
				<h2>9. Annuler ou corriger des commits</h2>
				<h3>Revert</h3>
				<p>
					Crée un commit inverse pour annuler un commit précédent :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git revert <commit_hash></code>
</pre>

				<h3>Reset</h3>
				<p>
					Reculer dans l’historique, avec la possibilité de garder ou non les changements :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
# Garde les modifs mais enlève le commit
git reset --soft HEAD~1

# Efface complètement les modifs du dernier commit
git reset --hard HEAD~1</code>
</pre>

				<h3>Amend</h3>
				<p>
					Pour modifier le dernier commit (changer son message ou ajouter un fichier oublié) :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git commit --amend</code>
</pre>
			</section>

			<!-- (10) STASH -->
			<section id="stash">
				<h2>10. Stash : mettre de côté des modifs</h2>
				<p>
					On peut sauvegarder temporairement son travail sans faire de commit final :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git stash
git stash list
git stash pop
git stash apply</code>
</pre>
			</section>

			<!-- (11) DISTANTS & COLLAB -->
			<section id="depots-distants">
				<h2>11. Dépôts Distants & Collaboration</h2>
				<p>
					Quelques commandes pour synchroniser avec un serveur (GitHub, GitLab…) :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git fetch
git pull
git push
git push -u origin branche</code>
</pre>
				<p>
					<strong>Fork & Pull Request :</strong> sur GitHub, vous pouvez forker un repo, faire vos modifs,
					puis ouvrir une Pull Request pour proposer vos changements au projet d’origine.
				</p>
			</section>

			<!-- (12) TAGS -->
			<section id="tags">
				<h2>12. Gestion des tags</h2>
				<p>
					Les tags servent souvent à marquer des versions (v1.0, v2.0…).
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git tag
git tag -a v1.0 -m "Version stable"
git push origin --tags</code>
</pre>
			</section>

			<!-- (13) SUBMODULES -->
			<section id="submodules">
				<h2>13. Submodules (Sous-modules)</h2>
				<p>
					On peut inclure un autre dépôt Git à l’intérieur du nôtre (ex: librairie partagée).
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git submodule add <URL>
git submodule init
git submodule update</code>
</pre>
			</section>

			<!-- (14) AVANCEES & UTILITAIRES -->
			<section id="avancees">
				<h2>14. Commandes avancées & utilitaires</h2>
				<p>
					Voici quelques commandes plus “spéciales” :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git cherry-pick <commit>      # Prendre un commit précis d’une autre branche
git reflog                  # Historique caché de toutes les actions
git gc                      # Nettoyer et compresser le repo
git archive --format=zip HEAD > code.zip  # Exporter le code sans l'historique
git shortlog               # Liste des commits regroupés par auteur
</code>
</pre>
			</section>

			<!-- (15) BONNES PRATIQUES -->
			<section id="bonnes-pratiques">
				<h2>15. Bonnes pratiques</h2>
				<ol>
					<li>Commits fréquents & atomiques (petites étapes faciles à comprendre).</li>
					<li>Messages de commit clairs (expliquez “pourquoi” et pas juste “ce qui a changé”).</li>
					<li>Utiliser des branches descriptives (ex: <code>feature/login</code>, <code>fix/bug-42</code>).
					</li>
					<li>Revue de code via Pull Requests (pour un avis extérieur, moins de bugs). </li>
					<li>Éviter de réécrire l’historique partagé (risque de casser le repo de l’équipe). </li>
					<li>Maintenir un <code>.gitignore</code> (exclure fichiers inutiles, logs, etc.). </li>
				</ol>
			</section>

			<!-- (16) COMMANDES AVANCÉES DE GIT -->
			<section id="commandes-avancees-git">
				<h2>16. Les Commandes Avancées de Git</h2>
				<p>
					Git propose de nombreuses commandes avancées permettant de gérer finement l’historique du dépôt, de résoudre des problèmes complexes ou d’automatiser certaines tâches. Voici quelques-unes de ces commandes avec leurs explications détaillées :
				</p>

				<h3>1. Git Rebase</h3>
				<p>
					<strong>Description :</strong> La commande <code>git rebase</code> est un outil puissant pour réécrire l'historique des commits, permettant de créer un historique plus linéaire et propre. Elle déplace ou réapplique une série de commits sur une nouvelle base.
				</p>
				<p>
					Pour une explication détaillée, des exemples concrets, les cas d'usage (rebase simple, interactif, <code>--onto</code>), la gestion des conflits, les dangers à éviter (la "Règle d'Or"), et la comparaison avec <code>git merge</code>, veuillez vous référer à la <a href="#rebase">Section 7 : Rebase (Réécriture de l’historique)</a>.
				</p>

				<h3>2. Git Cherry-pick</h3>
				<p>
					<strong>Description :</strong> <code>git cherry-pick</code> permet d’extraire un ou plusieurs commits spécifiques depuis une autre branche et de les appliquer sur la branche courante.
				</p>
				<p><strong>Utilisation typique :</strong> Par exemple, pour appliquer une correction critique directement sur la branche de production :</p>
				<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git checkout production
git cherry-pick &lt;commit_hash&gt;
</code>
  </pre>

				<h3>3. Git Bisect</h3>
				<p>
					<strong>Description :</strong> <code>git bisect</code> est un outil de recherche dichotomique qui aide à identifier le commit précis ayant introduit un bug ou une régression.
				</p>
				<p><strong>Processus :</strong></p>
				<ol>
					<li>
						Démarrer la recherche :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git bisect start
</code>
      </pre>
					</li>
					<li>
						Marquer le commit avec le bug :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git bisect bad
</code>
      </pre>
					</li>
					<li>
						Marquer un commit fonctionnel :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git bisect good &lt;commit_hash&gt;
</code>
      </pre>
					</li>
					<li>
						Une fois identifié, réinitialiser le bisect :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git bisect reset
</code>
      </pre>
					</li>
				</ol>
				<p><em>Astuce :</em> Vous pouvez automatiser ce processus en créant un script de test retournant 0 en cas de succès et 1 en cas d’échec.</p>

				<h3>4. Git Stash</h3>
				<p>
					<strong>Description :</strong> La commande <code>git stash</code> sauvegarde temporairement des modifications non committées, permettant de nettoyer l’espace de travail sans perdre votre travail en cours.
				</p>
				<ul>
					<li>
						Sauvegarder avec un message :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git stash save "Travail en cours sur feature X"
</code>
      </pre>
					</li>
					<li>
						Lister les stashes :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git stash list
</code>
      </pre>
					</li>
					<li>
						Appliquer ou supprimer un stash spécifique :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git stash apply stash@{2}
git stash drop stash@{2}
</code>
      </pre>
					</li>
				</ul>

				<h3>5. Git Reflog</h3>
				<p>
					<strong>Description :</strong> <code>git reflog</code> conserve l’historique des déplacements de <code>HEAD</code>, permettant de retrouver des commits "perdus" ou de revenir à un état antérieur.
				</p>
				<p><strong>Utilisation :</strong></p>
				<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git reflog
</code>
  </pre>
				<p>Pour revenir à un commit précis, par exemple :</p>
				<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git reset --hard HEAD@{3}
</code>
  </pre>

				<h3>6. Git Reset</h3>
				<p>
					<strong>Description :</strong> <code>git reset</code> modifie la position de <code>HEAD</code> et, selon l’option choisie, peut modifier l’index et le répertoire de travail.
				</p>
				<ul>
					<li>
						<em>Soft (--soft) :</em> Déplace <code>HEAD</code> sans modifier l’index ni le répertoire de travail :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git reset --soft &lt;commit_hash&gt;
</code>
      </pre>
					</li>
					<li>
						<em>Mixed (par défaut) :</em> Réinitialise l’index sans toucher au répertoire de travail :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git reset &lt;commit_hash&gt;
</code>
      </pre>
					</li>
					<li>
						<em>Hard (--hard) :</em> Réinitialise <code>HEAD</code>, l’index et le répertoire de travail, supprimant toutes les modifications non committées :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git reset --hard &lt;commit_hash&gt;
</code>
      </pre>
					</li>
				</ul>
				<p><em>Conseil :</em> Utilisez <code>--hard</code> avec précaution, surtout sur des branches partagées.</p>

				<h3>7. Git Clean</h3>
				<p>
					<strong>Description :</strong> <code>git clean</code> supprime les fichiers non suivis dans le répertoire de travail, permettant de nettoyer votre environnement.
				</p>
				<ul>
					<li>
						Voir ce qui sera supprimé (mode test) :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git clean -n
</code>
      </pre>
					</li>
					<li>
						Supprimer les fichiers non suivis :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git clean -f
</code>
      </pre>
					</li>
					<li>
						Supprimer également les répertoires non suivis :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git clean -fd
</code>
      </pre>
					</li>
				</ul>
				<p><em>Astuce :</em> Utilisez toujours l’option <code>-n</code> pour une simulation avant de supprimer définitivement.</p>

				<h3>8. Git Filter-branch et Git Filter-repo</h3>
				<p>
					<strong>Description :</strong> Ces commandes permettent de réécrire l’historique complet du dépôt, ce qui est utile pour supprimer des fichiers sensibles ou nettoyer l’historique.
				</p>
				<ul>
					<li>
						<em>git filter-branch :</em> Bien que puissant, il peut être lent et complexe pour de gros dépôts.
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch chemin/du/fichier' --prune-empty --tag-name-filter cat -- --all
</code>
      </pre>
					</li>
					<li>
						<em>git filter-repo :</em> Une alternative moderne et performante. Exemple pour supprimer un fichier de l’historique :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git filter-repo --path chemin/du/fichier --invert-paths
</code>
      </pre>
						<p><em>Astuce :</em> Sauvegardez toujours votre dépôt avant d’effectuer une réécriture historique.</p>
					</li>
				</ul>

				<h3>9. Git Submodule</h3>
				<p>
					<strong>Description :</strong> La commande <code>git submodule</code> permet d’intégrer et de gérer un dépôt Git externe au sein d’un projet, ce qui est utile pour gérer des dépendances ou bibliothèques de manière autonome.
				</p>
				<p><strong>Utilisation typique :</strong></p>
				<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git submodule add &lt;URL_du_dépôt&gt; chemin/destination
git submodule update --init --recursive
</code>
  </pre>

				<h3>10. Git Worktree</h3>
				<p>
					<strong>Description :</strong> La commande <code>git worktree</code> permet de travailler simultanément sur plusieurs branches dans des répertoires distincts sans avoir à cloner le dépôt plusieurs fois.
				</p>
				<p><strong>Utilisation :</strong> Pour créer un nouveau worktree pour une branche :</p>
				<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git worktree add ../chemin/vers/nouveau_worktree featureX
</code>
  </pre>
				<p>
					<em>Avantages :</em> Tester ou développer sur une branche tout en gardant la branche principale intacte. Idéal pour des tests, builds ou débogages sur des versions parallèles.<br />
					<em>Conseil :</em> Pour revenir à la gestion normale, supprimez le worktree avec :
				</p>
				<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git worktree remove ../chemin/vers/nouveau_worktree
</code>
  </pre>

				<h3>Conclusion</h3>
				<p>
					Ces commandes avancées offrent une flexibilité considérable pour gérer l’historique, résoudre des problèmes complexes et optimiser votre flux de travail. Leur maîtrise vous permet de :
				</p>
				<ul>
					<li><strong>Gérer des workflows complexes :</strong> Adaptez l’historique avec <code>rebase</code>, <code>cherry-pick</code> et <code>reset</code>.</li>
					<li><strong>Identifier et corriger des erreurs :</strong> Utilisez <code>bisect</code> et <code>reflog</code> pour retrouver des commits problématiques.</li>
					<li><strong>Optimiser l’environnement de développement :</strong> Grâce à <code>stash</code>, <code>clean</code>, <code>submodule</code> et <code>worktree</code> pour maintenir un espace de travail organisé.</li>
				</ul>
				<p>
					En pratiquant ces commandes sur des dépôts de test, vous gagnerez en confiance et serez mieux préparé pour gérer des projets complexes.
				</p>
			</section>


			<!-- TABLEAU COMPLET DES COMMANDES -->
			<section id="tableau-commands">
				<div class="table-responsive mt-3">
					<h2>Tableau complet des commandes Git</h2>
					<p>Retrouvez ci-dessous un récapitulatif complet :</p>
					<div class="table-responsive mt-3">
						<table class="table table-bordered table-hover align-middle">
							<thead class="table-dark">
								<tr>
									<th>Commande</th>
									<th>Utilisation</th>
									<th>Explication</th>
									<th>Avantage ✅</th>
									<th>Inconvénient 🚨</th>
								</tr>
							</thead>
							<tbody>
								<!-- Liste COMPLETE (non tronquée) -->
								<tr>
									<td><strong>git init</strong></td>
									<td><code>git init</code></td>
									<td>Initialise un nouveau dépôt Git (création du dossier <code>.git/</code>).</td>
									<td>Démarrer facilement un nouveau projet.</td>
									<td>Crée un dépôt vide (peut nécessiter config/dépôt distant).</td>
								</tr>
								<tr>
									<td><strong>git clone</strong></td>
									<td><code>git clone URL [dossier]</code></td>
									<td>Copie un dépôt distant (ou local) dans un nouveau dossier.</td>
									<td>Récupération rapide d’un projet existant et de son historique.</td>
									<td>Peut être volumineux si le repo est très gros.</td>
								</tr>
								<tr>
									<td><strong>git remote add</strong></td>
									<td><code>git remote add &lt;nom&gt; &lt;URL&gt;</code></td>
									<td>Associe un dépôt distant (ex: <code>origin</code>) à l’URL spécifiée.</td>
									<td>Permet de pousser/puller vers un dépôt en ligne (GitHub...).</td>
									<td>Erreur possible si l’on se trompe d’URL.</td>
								</tr>
								<tr>
									<td><strong>git remote rename</strong></td>
									<td><code>git remote rename &lt;old&gt; &lt;new&gt;</code></td>
									<td>Renomme un dépôt distant (ex. <code>origin</code> → <code>oldorigin</code>).
									</td>
									<td>Clarifie le nom (en cas de multiples remotes).</td>
									<td>Scripts/CI peuvent être impactés si le nom change.</td>
								</tr>
								<tr>
									<td><strong>git remote remove</strong></td>
									<td><code>git remote remove &lt;nom&gt;</code></td>
									<td>Supprime un dépôt distant de la configuration Git.</td>
									<td>Nettoie la liste des remotes inutiles.</td>
									<td>Plus de push/pull possible vers ce remote si besoin.</td>
								</tr>
								<tr>
									<td><strong>git status</strong></td>
									<td><code>git status</code></td>
									<td>Affiche l’état des fichiers : suivis, non suivis, prêts à être commit, etc.</td>
									<td>Vue rapide et claire des changements.</td>
									<td>Aucun inconvénient majeur.</td>
								</tr>
								<tr>
									<td><strong>git add</strong></td>
									<td><code>git add fichier</code> / <code>git add .</code></td>
									<td>Ajoute des fichiers dans la zone de staging (préparation au commit).</td>
									<td>Contrôle précis sur ce qu’on veut commiter.</td>
									<td>Si on oublie un fichier, il ne sera pas dans le commit.</td>
								</tr>
								<tr>
									<td><strong>git commit</strong></td>
									<td><code>git commit -m "msg"</code></td>
									<td>Crée un instantané (commit) des changements validés.</td>
									<td>Construit l’historique avec un message descriptif.</td>
									<td>Un mauvais message gêne la compréhension de l’historique.</td>
								</tr>
								<tr>
									<td><strong>git commit -am</strong></td>
									<td><code>git commit -am "msg"</code></td>
									<td>Combine l’ajout et le commit pour les fichiers déjà suivis.</td>
									<td>Gain de temps pour modifications rapides.</td>
									<td>Ne gère pas les nouveaux fichiers non suivis.</td>
								</tr>
								<tr>
									<td><strong>git commit --amend</strong></td>
									<td><code>git commit --amend</code></td>
									<td>Modifie le dernier commit (message ou fichiers).</td>
									<td>Corrige un oubli ou un message trop vague.</td>
									<td>Réécrit l’historique, déconseillé si déjà poussé.</td>
								</tr>
								<tr>
									<td><strong>git log</strong></td>
									<td><code>git log</code>, <code>git log --oneline</code></td>
									<td>Affiche l’historique des commits (détaillé ou succinct).</td>
									<td>Bonne vision de l’évolution du projet.</td>
									<td>Peut être verbeux sur gros projets.</td>
								</tr>
								<tr>
									<td><strong>git checkout</strong></td>
									<td><code>git checkout &lt;branche&gt;</code> /
										<code>git checkout -- &lt;fichier&gt;</code></td>
									<td>Change de branche OU annule les modifs d’un fichier local.</td>
									<td>Navigation aisée entre branches.</td>
									<td>Perte possible de changements non commit si on oublie de stasher.</td>
								</tr>
								<tr>
									<td><strong>git branch</strong></td>
									<td><code>git branch &lt;nom&gt;</code></td>
									<td>Crée une branche ou liste les branches (si pas d’argument).</td>
									<td>Organise le travail (nouvelles fonctionnalités).</td>
									<td>Trop de branches peuvent créer la confusion.</td>
								</tr>
								<tr>
									<td><strong>git branch -m</strong></td>
									<td><code>git branch -m &lt;ancien&gt; &lt;nouveau&gt;</code></td>
									<td>Renomme une branche locale.</td>
									<td>Corrige un nom mal choisi.</td>
									<td>Peut troubler d’autres si la branche est partagée.</td>
								</tr>
								<tr>
									<td><strong>git branch -d</strong></td>
									<td><code>git branch -d &lt;nom&gt;</code></td>
									<td>Supprime une branche locale (fusionnée).</td>
									<td>Nettoyage des branches terminées.</td>
									<td>Impossible si non fusionnée (risque de perte).</td>
								</tr>
								<tr>
									<td><strong>git branch -D</strong></td>
									<td><code>git branch -D &lt;nom&gt;</code></td>
									<td>Supprime une branche locale sans vérification.</td>
									<td>Forcer la suppression d’une branche obsolète.</td>
									<td>Risque de perte définitive de commits.</td>
								</tr>
								<tr>
									<td><strong>git merge</strong></td>
									<td><code>git merge &lt;branche&gt;</code></td>
									<td>Fusionne la branche spécifiée dans la branche courante.</td>
									<td>Combine facilement plusieurs flux de travail.</td>
									<td>Peut générer des conflits, crée un commit de merge.</td>
								</tr>
								<tr>
									<td><strong>git merge --no-ff</strong></td>
									<td><code>git merge --no-ff &lt;branche&gt;</code></td>
									<td>Fusion sans fast-forward, garde un commit de merge dédié.</td>
									<td>Historique plus lisible (commit de merge conservé).</td>
									<td>Même si un fast-forward était possible, on force un commit supplémentaire.</td>
								</tr>
								<tr>
									<td><strong>git rebase</strong></td>
									<td><code>git rebase &lt;branche&gt;</code></td>
									<td>“Rejoue” les commits de la branche courante sur une autre branche.</td>
									<td>Historique linéaire et propre (pas de commit de merge).</td>
									<td>Réécrit l’historique (dangereux si partagé).</td>
								</tr>
								<tr>
									<td><strong>git rebase -i</strong></td>
									<td><code>git rebase -i HEAD~n</code></td>
									<td>Rebase interactif (modifier l’ordre, fusionner, renommer des commits).</td>
									<td>Historique très propre, possibilité de “squasher”.</td>
									<td>Complexe, risque de collisions ou pertes.</td>
								</tr>
								<tr>
									<td><strong>git rebase --continue</strong></td>
									<td><code>git rebase --continue</code></td>
									<td>Poursuit le rebase après résolution de conflit.</td>
									<td>Finalise le rebase proprement.</td>
									<td>Faut résoudre tous les conflits un par un.</td>
								</tr>
								<tr>
									<td><strong>git rebase --abort</strong></td>
									<td><code>git rebase --abort</code></td>
									<td>Annule le rebase en cours et revient à l’état initial.</td>
									<td>Utile si trop de conflits.</td>
									<td>Annule tout le travail du rebase.</td>
								</tr>
								<tr>
									<td><strong>git diff</strong></td>
									<td><code>git diff</code>, <code>git diff --staged</code></td>
									<td>Compare les différences non validées ou indexées.</td>
									<td>Repère précisément les lignes modifiées.</td>
									<td>Peut être long à lire sur gros projets.</td>
								</tr>
								<tr>
									<td><strong>git blame</strong></td>
									<td><code>git blame &lt;fichier&gt;</code></td>
									<td>Montre, ligne par ligne, qui a modifié le fichier et quand.</td>
									<td>Pratique pour attribuer un changement précis.</td>
									<td>Peu lisible si gros fichier avec multiples auteurs.</td>
								</tr>
								<tr>
									<td><strong>git bisect</strong></td>
									<td><code>git bisect start</code>, <code>git bisect bad</code>,
										<code>git bisect good</code></td>
									<td>Recherche binaire d’un commit fautif.</td>
									<td>Méthode puissante pour isoler un bug.</td>
									<td>Processus parfois long.</td>
								</tr>
								<tr>
									<td><strong>git revert</strong></td>
									<td><code>git revert &lt;commit&gt;</code></td>
									<td>Crée un commit annulant un autre commit.</td>
									<td>Historique conservé sans tout écraser.</td>
									<td>Peut allonger l’historique si nombreux revert.</td>
								</tr>
								<tr>
									<td><strong>git reset --soft</strong></td>
									<td><code>git reset --soft HEAD~1</code></td>
									<td>Reculer un commit en gardant les modifications dans le staging.</td>
									<td>Permet de refaire un commit propre.</td>
									<td>Réécrit l’historique (dangereux si déjà poussé).</td>
								</tr>
								<tr>
									<td><strong>git reset --hard</strong></td>
									<td><code>git reset --hard HEAD~1</code></td>
									<td>Reculer un commit en supprimant définitivement les modifs.</td>
									<td>Retour rapide à un état stable.</td>
									<td>Perte irréversible des changements.</td>
								</tr>
								<tr>
									<td><strong>git stash</strong></td>
									<td><code>git stash</code></td>
									<td>Met de côté les modifs non commitées.</td>
									<td>Utile pour passer sur une autre branche sans perdre son travail.</td>
									<td>On peut oublier les stash si on ne les liste pas.</td>
								</tr>
								<tr>
									<td><strong>git stash pop</strong></td>
									<td><code>git stash pop</code></td>
									<td>Récupère et supprime le dernier stash.</td>
									<td>Permet de reprendre rapidement son travail mis en attente.</td>
									<td>Conflits possibles si code très différent entre-temps.</td>
								</tr>
								<tr>
									<td><strong>git stash apply</strong></td>
									<td><code>git stash apply [stash@{n}]</code></td>
									<td>Applique un stash (sans le supprimer).</td>
									<td>Peut réutiliser plusieurs fois le même stash.</td>
									<td>Attention aux duplications si on l’applique plusieurs fois.</td>
								</tr>
								<tr>
									<td><strong>git stash list</strong></td>
									<td><code>git stash list</code></td>
									<td>Affiche la liste de tous les stashes mis de côté.</td>
									<td>Visualise rapidement les réserves de code.</td>
									<td>Pas d’inconvénient notable.</td>
								</tr>
								<tr>
									<td><strong>git fetch</strong></td>
									<td><code>git fetch [remote] [branche]</code></td>
									<td>Récupère les nouveautés sans les fusionner.</td>
									<td>Voir ce qui a changé avant d’intégrer.</td>
									<td>Étape supplémentaire (pull ou merge) pour la fusion finale.</td>
								</tr>
								<tr>
									<td><strong>git pull</strong></td>
									<td><code>git pull</code></td>
									<td>Récupère et fusionne directement les modifications du dépôt distant.</td>
									<td>Simple pour rester à jour.</td>
									<td>Peut engendrer des conflits si modifs simultanées.</td>
								</tr>
								<tr>
									<td><strong>git push</strong></td>
									<td><code>git push</code></td>
									<td>Envoie les commits locaux vers la branche distante.</td>
									<td>Partage facile avec l’équipe.</td>
									<td>Conflits possibles si historique local en retard.</td>
								</tr>
								<tr>
									<td><strong>git push -u</strong></td>
									<td><code>git push -u origin &lt;branche&gt;</code></td>
									<td>Pousse la branche locale et la configure avec le dépôt distant.</td>
									<td>Simplifie les futurs push/pull.</td>
									<td>Peut créer plusieurs branches distantes si mal utilisé.</td>
								</tr>
								<tr>
									<td><strong>git push --force</strong></td>
									<td><code>git push --force</code> ou <code>git push --force-with-lease</code></td>
									<td>Force la réécriture de l’historique distant.</td>
									<td>Utile après un rebase ou amend déjà poussé.</td>
									<td>Risque de perdre le travail d’autres contributeurs.</td>
								</tr>
								<tr>
									<td><strong>git tag</strong></td>
									<td><code>git tag &lt;nom&gt;</code></td>
									<td>Crée un tag léger (non annoté) sur le commit courant.</td>
									<td>Identifier rapidement une version.</td>
									<td>Pas de message ni métadonnées.</td>
								</tr>
								<tr>
									<td><strong>git tag -a</strong></td>
									<td><code>git tag -a v1.0 -m "message"</code></td>
									<td>Crée un tag annoté (avec message).</td>
									<td>Historique complet sur la version (auteur, date, message).</td>
									<td>Trop de tags peut devenir confus.</td>
								</tr>
								<tr>
									<td><strong>git push origin --tags</strong></td>
									<td><code>git push origin --tags</code></td>
									<td>Envoie tous les tags locaux vers le dépôt distant.</td>
									<td>Partage public des différentes versions marquées.</td>
									<td>Peut pousser des tags créés par erreur.</td>
								</tr>
								<tr>
									<td><strong>git submodule add</strong></td>
									<td><code>git submodule add &lt;URL&gt;</code></td>
									<td>Ajoute un dépôt Git comme sous-module dans le projet.</td>
									<td>Gère plusieurs projets dans un seul repo principal.</td>
									<td>Gestion parfois complexe si sous-modules changent souvent.</td>
								</tr>
								<tr>
									<td><strong>git submodule init</strong></td>
									<td><code>git submodule init</code></td>
									<td>Initialise les sous-modules d’un projet déjà cloné.</td>
									<td>Indispensable après un clone contenant des submodules.</td>
									<td>Étape supplémentaire qui peut être oubliée.</td>
								</tr>
								<tr>
									<td><strong>git submodule update</strong></td>
									<td><code>git submodule update</code></td>
									<td>Met à jour les sous-modules à la version indiquée dans le repo principal.</td>
									<td>Garde les sous-modules cohérents avec la référence choisie.</td>
									<td>Parfois besoin de <code>--recursive</code> (sous-sous-modules).</td>
								</tr>
								<tr>
									<td><strong>git clone --recurse-submodules</strong></td>
									<td><code>git clone --recurse-submodules &lt;URL&gt;</code></td>
									<td>Clone un projet et initialise les sous-modules en une seule commande.</td>
									<td>Pratique pour un projet multi-modules complet.</td>
									<td>Sinon il faut <code>init</code> et <code>update</code> manuellement.</td>
								</tr>
								<tr>
									<td><strong>git cherry-pick</strong></td>
									<td><code>git cherry-pick &lt;commit&gt;</code></td>
									<td>Copie un commit précis (d’une autre branche) dans la branche courante.</td>
									<td>Importe une correction ou fonctionnalité sans fusionner toute la branche.</td>
									<td>Conflits possibles si dépendances entre commits.</td>
								</tr>
								<tr>
									<td><strong>git reflog</strong></td>
									<td><code>git reflog</code></td>
									<td>Historique détaillé des actions (commits, checkout...) même effacées du log.
									</td>
									<td>Permet de récupérer un commit perdu.</td>
									<td>Lecture parfois confuse pour les débutants.</td>
								</tr>
								<tr>
									<td><strong>git gc</strong></td>
									<td><code>git gc</code></td>
									<td>Nettoie/optimise la base de données Git (compression, purge objets obsolètes).
									</td>
									<td>Réduit la taille du repo, améliore la performance.</td>
									<td>À utiliser avec précaution (peut effacer définitivement certains objets).</td>
								</tr>
								<tr>
									<td><strong>git archive</strong></td>
									<td><code>git archive --format=zip HEAD &gt; code.zip</code></td>
									<td>Crée une archive du contenu (sans l’historique complet).</td>
									<td>Utile pour exporter une version rapidement.</td>
									<td>Aucun suivi de l’historique dans l’archive.</td>
								</tr>
								<tr>
									<td><strong>git shortlog</strong></td>
									<td><code>git shortlog</code></td>
									<td>Résumé des commits groupés par auteur.</td>
									<td>Vision rapide de la contribution de chacun.</td>
									<td>Manque de détails sur les changements eux-mêmes.</td>
								</tr>
							</tbody>
						</table>
					</div>
					<p><strong>Remarques :</strong></p>
					<ul>
						<li>Certaines commandes ont des variantes (ex. <code>-m</code>, <code>-p</code>,
							<code>--stat</code>).</li>
						<li>Les avantages/inconvénients dépendent du contexte (projet solo/équipe, etc.).</li>
					</ul>
			</section>

			<!-- EXEMPLES CONCRETS -->
			<section id="exemples">
				<h2>Exemples Concrets</h2>
				<h4>1. Annuler le dernier commit en gardant les modifs</h4>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git reset --soft HEAD~1
# Les fichiers restent modifiés
</code>
</pre>

				<h4>2. Rebaser sa branche sur main</h4>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git checkout ma-branche
git pull origin main
git rebase main
</code>
</pre>
			</section>

			<!-- EXERCICES & PIEGES -->
			<section id="exercices-pieges">
				<h2>Exercices & pièges courants</h2>
				<h3>Exercices pratiques</h3>
				<ul>
					<li><strong>Exercice 1 :</strong> Créer un dépôt local, y faire deux commits et pousser sur GitHub.
					</li>
					<li><strong>Exercice 2 :</strong> Créer une branche, y faire une modif, provoquer un conflit et le
						résoudre.</li>
					<li><strong>Exercice 3 :</strong> Faire un stash avant de changer de branche, puis le récupérer.
					</li>
				</ul>

				<h3>Pièges courants à éviter</h3>
				<ul>
					<li><strong>Forcer un push</strong> : <code>git push --force</code> sans précaution risque d’écraser
						le travail d’autrui.</li>
					<li><strong>Réécrire l’historique partagé</strong> : rebase ou reset sur une branche déjà utilisée
						par d’autres.</li>
					<li><strong>Oublier stash</strong> : si on change de branche sans stasher, on peut perdre ses
						modifs.</li>
					<li><strong>Merge mal résolu</strong> : bien faire <code>git add</code> et <code>git commit</code>
						après le conflit.</li>
				</ul>
			</section>

			<!-- CONVENTIONS DE COMMIT -->
			<section id="commit-conventions">
				<h2>Conventions Commit</h2>
				<p>
					Parfois on suit des règles pour les messages de commit (ex. <em>Conventional Commits</em>),
					afin de générer des changelogs automatiques, d’avoir une structure claire, etc.
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
feat: ajout fonctionnalité
fix: correction bug
docs: mise à jour doc
</code>
	</pre>
			</section>

			<!-- CI/CD GITHUB ACTIONS -->
			<section id="github-actions">
				<h2>CI/CD (GitHub Actions)</h2>
				<p>
					Pour automatiser des tests ou un déploiement, on peut créer un fichier
					<code>.github/workflows/ci.yml</code> comme ceci :
				</p>
				<pre class="language-yaml">
			  <button class="btn btn-light copy-btn">Copier</button>
<code>
name: CI

on:
	push:
	branches: [ "main" ]
	pull_request:
	branches: [ "main" ]

jobs:
	build:
	runs-on: ubuntu-latest
	steps:
		- uses: actions/checkout@v2
		- name: Installer dépendances
		run: npm install
		- name: Lancer les tests
		run: npm test
</code>
	</pre>
			</section>

			<!-- GLOSSAIRE GIT -->
			<section id="glossaire">
				<h2>Glossaire Git</h2>
				<ul>
					<li><strong>stash</strong> : mettre de côté des modifications non commit (temporaire).</li>
					<li><strong>rebase</strong> : rejouer des commits sur une autre base pour un historique plus
						linéaire.</li>
					<li><strong>fetch</strong> : télécharger les changements distants sans les fusionner (juste les
						voir).</li>
					<li><strong>fork</strong> : copier un dépôt (souvent sur GitHub) dans son espace perso.</li>
					<li><strong>cherry-pick</strong> : prendre un commit précis d’une autre branche et l’ajouter à la
						nôtre.</li>
					<li><strong>tag</strong> : étiquette (nom) sur un commit (souvent pour marquer une version stable).
					</li>
				</ul>
			</section>

			<!-- CONCLUSION -->
			<section id="conclusion">
				<h2>Conclusion</h2>
				<p>
					Vous avez vu ici toutes les bases de Git, plus des parties avancées (rebase, stash, etc.).
					Entraînez-vous régulièrement pour retenir les commandes.
				</p>
				<p>
					Git est très puissant et utile quand on travaille à plusieurs ou qu’on veut garder une trace
					de chaque changement dans son projet.
				</p>
				<p><strong>Bonne pratique de Git et bon code !</strong></p>

			</section>

			<!-- (24) GIT WORKFLOWS -->
			<section id="workflows">
				<h2>24. Git Workflows</h2>

				<h3>Introduction aux Workflows Git</h3>
				<p>Un workflow Git (ou flux de travail Git) est un ensemble de conventions, de recommandations et de stratégies sur la manière d'utiliser Git efficacement au sein d'un projet ou d'une équipe. Choisir un workflow adapté permet de structurer le développement, de faciliter la collaboration, de gérer les versions et de maintenir un historique de projet propre et compréhensible. Il n'existe pas de workflow universel ; le choix dépendra souvent de la taille de l'équipe, de la nature du projet (ex: application web, bibliothèque), du cycle de release, et des outils de CI/CD utilisés.</p>
				<p>Les workflows définissent typiquement :</p>
				<ul>
					<li>La structure des branches (quelles branches sont utilisées et leur rôle).</li>
					<li>Quand et comment les branches sont créées, fusionnées ou rebasées.</li>
					<li>Comment les versions et les releases sont gérées.</li>
					<li>Les conventions de nommage pour les branches et les commits.</li>
				</ul>
				<p>Nous allons explorer quelques workflows populaires.</p>

				<h3>Gitflow Workflow</h3>
				<p>Proposé par Vincent Driessen en 2010, Gitflow est un modèle de branching robuste, conçu pour des projets avec un cycle de release planifié. Il est particulièrement populaire pour les logiciels qui ont des versions distinctes (ex: v1.0, v1.1, v2.0).</p>
				<h5>Branches Principales :</h5>
				<ul>
					<li><code>main</code> (ou <code>master</code>) : Contient le code de production stable, prêt à être déployé. Chaque commit sur <code>main</code> est une nouvelle version et devrait être tagué avec un numéro de version.</li>
					<li><code>develop</code> : Sert de branche d'intégration principale pour les fonctionnalités. C'est ici que le code de la prochaine release est accumulé. Lorsque <code>develop</code> atteint un état stable et est prête pour une release, elle est mergée dans <code>main</code> et taguée.</li>
				</ul>
				<h5>Branches de Support :</h5>
				<ul>
					<li><strong>Branches de fonctionnalité (<code>feature/*</code>) :</strong>
						<ul>
							<li>Créées à partir de : <code>develop</code>.</li>
							<li>Doivent être mergées dans : <code>develop</code>.</li>
							<li>Convention de nommage : <code>feature/nom-de-la-fonction</code> (ex: <code>feature/user-authentication</code>).</li>
							<li>But : Développer de nouvelles fonctionnalités de manière isolée. Ne doivent jamais interagir directement avec <code>main</code>.</li>
						</ul>
					</li>
					<li><strong>Branches de release (<code>release/*</code>) :</strong>
						<ul>
							<li>Créées à partir de : <code>develop</code> (quand <code>develop</code> est prête pour une release).</li>
							<li>Doivent être mergées dans : <code>develop</code> ET <code>main</code>.</li>
							<li>Convention de nommage : <code>release/v1.0.1</code>.</li>
							<li>But : Préparer une nouvelle release de production. Permet de faire des corrections de dernière minute, de la documentation, etc., sans interrompre le flux sur <code>develop</code>. Une fois prête, la branche de release est mergée dans <code>main</code> (et taguée) et aussi dans <code>develop</code> (pour y reporter les corrections de dernière minute).</li>
						</ul>
					</li>
					<li><strong>Branches de correctif (<code>hotfix/*</code>) :</strong>
						<ul>
							<li>Créées à partir de : <code>main</code> (depuis le tag de la version à corriger).</li>
							<li>Doivent être mergées dans : <code>develop</code> ET <code>main</code>.</li>
							<li>Convention de nommage : <code>hotfix/description-du-correctif</code> (ex: <code>hotfix/security-vulnerability-fix</code>).</li>
							<li>But : Corriger rapidement des bugs critiques en production. Permet de ne pas attendre le prochain cycle de release. Une fois le correctif appliqué, la branche est mergée dans <code>main</code> (et une nouvelle version est taguée) et également dans <code>develop</code>.</li>
						</ul>
					</li>
				</ul>
				<h5>Avantages de Gitflow :</h5>
				<ul>
					<li>Très structuré et clair, surtout pour les projets avec plusieurs versions et des cycles de release définis.</li>
					<li>Bonne isolation entre les nouvelles fonctionnalités, la préparation des releases et les correctifs urgents.</li>
					<li>Le rôle de chaque branche est bien défini.</li>
				</ul>
				<h5>Inconvénients de Gitflow :</h5>
				<ul>
					<li>Peut être perçu comme complexe, surtout pour les petits projets ou les équipes qui pratiquent l'intégration continue et le déploiement continu (CI/CD).</li>
					<li>Le nombre de branches peut devenir important.</li>
					<li>La branche <code>develop</code> peut parfois diverger significativement de <code>main</code> sur de longues périodes.</li>
				</ul>

				<h3>GitHub Flow</h3>
				<p>GitHub Flow est un workflow plus simple et léger, popularisé par GitHub. Il est particulièrement bien adapté aux projets qui pratiquent le déploiement continu ou fréquent (ex: applications web).</p>
				<h5>Principes Clés :</h5>
				<ul>
					<li><code>main</code> est toujours la branche principale et elle est **toujours déployable**. Ce qui est sur <code>main</code> est considéré comme stable et prêt pour la production.</li>
					<li>Pour travailler sur quelque chose de nouveau (fonctionnalité, bugfix), créez une **branche descriptive** à partir de <code>main</code> (ex: <code>feature/user-profile</code>, <code>fix/login-bug</code>).</li>
					<li>Poussez vos commits sur cette branche descriptive régulièrement sur le dépôt distant.</li>
					<li>Lorsque vous avez besoin de feedback ou que la fonctionnalité est prête, ouvrez une **Pull Request (PR)**.</li>
					<li>Après revue et approbation de la PR (et passage des tests automatisés), la branche est **mergée dans <code>main</code>**.</li>
					<li>Une fois mergée dans <code>main</code>, les changements devraient être **déployés immédiatement** (ou très rapidement).</li>
				</ul>
				<h5>Processus Typique :</h5>
				<ol>
					<li>Créez une branche à partir de <code>main</code>: <code>git checkout -b feature/nouvelle-idee main</code></li>
					<li>Faites vos commits sur cette branche.</li>
					<li>Poussez la branche sur le serveur : <code>git push origin feature/nouvelle-idee</code></li>
					<li>Ouvrez une Pull Request sur GitHub (ou GitLab, etc.).</li>
					<li>Discutez, revoyez le code, ajoutez des commits si nécessaire (en poussant sur la même branche).</li>
					<li>Une fois la PR approuvée et les tests CI passés, mergez-la dans <code>main</code> (souvent via l'interface de la plateforme).</li>
					<li>Déployez <code>main</code>.</li>
					<li>Supprimez la branche de fonctionnalité une fois mergée et déployée.</li>
				</ol>
				<h5>Avantages de GitHub Flow :</h5>
				<ul>
					<li>Simple à comprendre et à mettre en œuvre.</li>
					<li>Favorise l'intégration continue et le déploiement continu (CI/CD).</li>
					<li>Les Pull Requests facilitent la revue de code et la discussion avant l'intégration.</li>
					<li><code>main</code> est toujours une source de vérité pour le code stable.</li>
				</ul>
				<h5>Inconvénients de GitHub Flow :</h5>
				<ul>
					<li>Moins adapté si vous avez besoin de gérer plusieurs versions en parallèle ou si vous avez des cycles de release longs et planifiés (Gitflow pourrait être mieux).</li>
					<li>Nécessite une bonne discipline pour s'assurer que <code>main</code> est réellement toujours déployable.</li>
					<li>La gestion des hotfixes peut nécessiter une petite adaptation (souvent, un hotfix suit le même flux : branche à partir de `main`, PR, merge, déploiement).</li>
				</ul>

				<h3>Trunk-Based Development (Mention)</h3>
				<p>Le Trunk-Based Development (TBD) est un workflow où tous les développeurs collaborent sur le code dans une seule branche appelée "trunk" (souvent <code>main</code> ou <code>master</code>). Les changements sont intégrés fréquemment (au moins une fois par jour).</p>
				<ul>
					<li>Les fonctionnalités plus longues ou risquées sont souvent gérées avec des "Feature Flags" (bascules de fonctionnalités) pour permettre d'intégrer le code dans le trunk sans le rendre actif pour les utilisateurs finaux immédiatement.</li>
					<li>Les branches, si utilisées, sont très courtes (quelques commits, durant moins d'un jour ou deux) avant d'être mergées dans le trunk.</li>
					<li>Fortement dépendant d'une suite de tests automatisés robuste et d'une CI/CD performante.</li>
					<li>Objectif : éviter les problèmes de "merge hell" en intégrant continuellement.</li>
				</ul>
				<p>Ce workflow est courant dans les environnements qui visent une très haute vélocité et un déploiement continu.</p>
			</section>

			<!-- (25) HOOKS GIT -->
			<section id="hooks-git">
				<h2>25. Hooks Git (Crochets Git)</h2>

				<h3>Qu'est-ce qu'un Hook Git ?</h3>
				<p>Les hooks (ou "crochets") Git sont des scripts que Git exécute automatiquement avant ou après certains événements importants de son cycle de vie, tels que la création de commits, le push de modifications, ou le changement de branches. Ils vous permettent de personnaliser le comportement de Git et d'automatiser des tâches spécifiques à votre workflow.</p>
				<p>Par exemple, vous pouvez utiliser un hook pour :</p>
				<ul>
					<li>Vérifier que votre message de commit respecte un format standard.</li>
					<li>Exécuter des tests unitaires avant de permettre un commit.</li>
					<li>Notifier votre équipe d'intégration continue après un push réussi.</li>
					<li>Vérifier la qualité du code (linting) avant qu'il ne soit commité.</li>
				</ul>
				<p>Les hooks sont locaux à chaque dépôt Git ; ils ne sont pas versionnés avec le dépôt lui-même et ne sont donc pas transférés lors d'un clone. Chaque développeur doit configurer ses propres hooks ou utiliser un mécanisme pour les partager au sein de l'équipe (par exemple, en les versionnant dans un dossier du projet et en ayant un script pour les copier/lier dans <code>.git/hooks</code>).</p>

				<h3>Types de Hooks</h3>
				<p>Il existe deux catégories principales de hooks :</p>
				<ul>
					<li><strong>Hooks côté client (Client-Side Hooks) :</strong> Ils sont exécutés sur la machine locale du développeur et affectent son workflow personnel. Ce sont ceux sur lesquels nous allons nous concentrer. Exemples : <code>pre-commit</code>, <code>prepare-commit-msg</code>, <code>commit-msg</code>, <code>post-commit</code>, <code>pre-push</code>.</li>
					<li><strong>Hooks côté serveur (Server-Side Hooks) :</strong> Ils sont exécutés sur le serveur Git distant (par exemple, votre serveur GitHub Enterprise, GitLab, ou un serveur Git auto-hébergé) et sont utiles pour faire respecter des politiques pour le projet, envoyer des notifications, etc. Exemples : <code>pre-receive</code>, <code>update</code>, <code>post-receive</code>. La configuration de ces hooks dépend de la plateforme serveur.</li>
				</ul>

				<h3>Emplacement et Activation des Hooks</h3>
				<p>Les hooks côté client résident dans le répertoire <code>.git/hooks/</code> de votre dépôt. Lorsque vous initialisez un nouveau dépôt avec <code>git init</code>, Git peuple ce dossier avec un ensemble d'exemples de scripts de hooks. Ces fichiers se terminent tous par <code>.sample</code> (par exemple, <code>pre-commit.sample</code>).</p>
				<p>Pour activer un hook, il suffit de :</p>
				<ol>
					<li>Naviguer vers le répertoire <code>.git/hooks/</code>.</li>
					<li>Supprimer l'extension <code>.sample</code> du fichier de hook que vous voulez activer. Par exemple, renommez <code>pre-commit.sample</code> en <code>pre-commit</code>.</li>
					<li>Rendre le script exécutable : <code>chmod +x pre-commit</code> (sur Linux/macOS).</li>
				</ol>
				<p>Vous pouvez écrire vos scripts de hook dans n'importe quel langage de script que votre système peut exécuter (Bash, Perl, Python, Ruby, Node.js, etc.), tant que le script est exécutable et commence par un shebang correct (par exemple, <code>#!/bin/sh</code> ou <code>#!/usr/bin/env python3</code>).</p>
				<p>Si un script de hook retourne un code de sortie non nul (différent de 0), l'action Git correspondante (commit, push, etc.) est généralement annulée.</p>

				<h3>Exemple : Hook <code>pre-commit</code></h3>
				<p>Le hook <code>pre-commit</code> est exécuté juste avant que Git ne crée le commit, après que vous ayez tapé <code>git commit</code> mais avant que l'éditeur de message de commit ne s'ouvre (sauf si vous utilisez <code>-m</code>).</p>
				<p>Il est idéal pour effectuer des vérifications sur le code que vous êtes sur le point de commiter. Si le script <code>pre-commit</code> sort avec un code non nul, le commit est avorté.</p>
				<p><strong>Scénario :</strong> S'assurer qu'aucun fichier ne contient de marqueurs de conflit de fusion (<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>) oubliés.</p>
				<p>Créez le fichier <code>.git/hooks/pre-commit</code> (et rendez-le exécutable) avec le contenu suivant :</p>
				<pre class="language-bash">
<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de hook pre-commit">Copier</button>
<code>#!/bin/sh

# Vérifier les fichiers staged pour les marqueurs de conflit
if git diff --cached --name-only --diff-filter=ACM | xargs grep -E -q -s '<<<<<<<|=======|>>>>>>>'; then
  echo "ERREUR : Marqueurs de conflit de fusion détectés dans les fichiers staged."
  echo "Veuillez résoudre les conflits avant de commiter."
  exit 1
fi

# Un autre exemple : interdire les commits directs sur la branche main (simple vérification)
BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)
if [ "$BRANCH_NAME" = "main" ]; then
  # echo "ERREUR : Les commits directs sur la branche 'main' ne sont pas autorisés."
  # echo "Veuillez utiliser une branche de fonctionnalité et une Pull Request."
  # exit 1 # Décommentez pour activer cette règle
fi

# Si tout va bien, sortir avec 0 pour permettre le commit
exit 0</code></pre>
				<p>Ce script vérifie d'abord les conflits. La partie commentée montre comment vous pourriez ajouter une règle pour interdire les commits sur `main`.</p>

				<h3>Exemple : Hook <code>commit-msg</code></h3>
				<p>Le hook <code>commit-msg</code> prend un argument : le chemin vers un fichier temporaire qui contient le message de commit que vous avez rédigé. Il est exécuté après que vous ayez fermé l'éditeur de message de commit (ou après avoir fourni un message avec <code>-m</code>).</p>
				<p>Il est utilisé pour valider ou reformater le message de commit. S'il sort avec un code non nul, le commit est avorté.</p>
				<p><strong>Scénario :</strong> S'assurer que le message de commit respecte un format simple (par exemple, ne commence pas par "WIP", a une longueur minimale).</p>
				<p>Créez <code>.git/hooks/commit-msg</code> (et rendez-le exécutable) :</p>
				<pre class="language-bash">
<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de hook commit-msg">Copier</button>
<code>#!/bin/sh

COMMIT_MSG_FILE=$1
COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

# Vérifier si le message commence par "WIP" (Work In Progress)
if echo "$COMMIT_MSG" | grep -qE '^WIP:'; then
  echo "ATTENTION : Le message de commit commence par 'WIP:'."
  echo "Ceci est permis, mais n'oubliez pas de le finaliser plus tard."
  # Ne pas faire exit 1 ici si on veut juste avertir
fi

# Vérifier une longueur minimale (par exemple, 10 caractères, sans compter les commentaires)
ACTUAL_MSG=$(echo "$COMMIT_MSG" | grep -v '^#') # Ignorer les lignes de commentaire
if [ ${#ACTUAL_MSG} -lt 10 ]; then
  echo "ERREUR : Le message de commit est trop court (moins de 10 caractères)."
  echo "Veuillez fournir un message plus descriptif."
  exit 1
fi

# Vérifier la présence d'un ticket ID (exemple: [PROJECT-123])
# if ! echo "$COMMIT_MSG" | grep -qE '\[[A-Z]+-[0-9]+\]'; then
#   echo "ERREUR : Le message de commit doit inclure un ID de ticket (ex: [PROJECT-123])."
#   exit 1
# fi


# Si tout va bien
exit 0</code></pre>
				<p>Ce script vérifie quelques règles simples. Vous pouvez l'adapter pour des formats plus stricts comme <a href="#commit-conventions">Conventional Commits</a>.</p>

				<h3>Autres Hooks Utiles (Client-Side)</h3>
				<ul>
					<li><strong><code>prepare-commit-msg</code> :</strong> Exécuté avant l'éditeur de message de commit mais après la création du message par défaut. Utile pour insérer un modèle de message ou modifier le message généré automatiquement (par exemple, pour les commits de merge ou squash).</li>
					<li><strong><code>post-commit</code> :</strong> Exécuté juste après qu'un commit a été effectué avec succès. Utile pour des notifications ou des tâches de nettoyage.</li>
					<li><strong><code>pre-rebase</code> :</strong> Exécuté avant que <code>git rebase</code> ne commence. Peut être utilisé pour empêcher le rebase de certaines branches.</li>
					<li><strong><code>post-checkout</code> :</strong> Exécuté après un <code>git checkout</code> réussi. Utile pour nettoyer le répertoire de travail, installer des dépendances si un certain fichier a changé, etc.</li>
					<li><strong><code>pre-push</code> :</strong> Exécuté avant que <code>git push</code> n'envoie les commits au distant. C'est un excellent endroit pour exécuter des tests d'intégration plus longs ou des vérifications finales avant de partager votre code. S'il échoue, le push est annulé.</li>
				</ul>

				<h3>Langages pour les Hooks</h3>
				<p>Comme mentionné, vous pouvez utiliser la plupart des langages de script. Le Shell (Bash, sh) est courant pour sa simplicité et sa portabilité sur les systèmes Unix-like. Python, Ruby, Perl et Node.js sont également de bons choix, surtout si la logique du hook devient plus complexe ou si vous voulez utiliser des bibliothèques existantes.</p>
				<p>N'oubliez pas le shebang (<code>#!</code>) au début de votre script pour indiquer l'interpréteur et de rendre le fichier de hook exécutable.</p>
				<div class="alert alert-info" role="alert">
				  <strong>Conseil :</strong> Il existe des outils et des frameworks (comme <a href="https://pre-commit.com/" target="_blank" rel="noopener noreferrer">pre-commit.com</a>) qui aident à gérer et partager des hooks Git pré-construits ou personnalisés au sein d'une équipe, simplifiant leur installation et leur maintenance.
				</div>
			</section>

			<!-- (26) FINS DE LIGNE & .GITATTRIBUTES -->
			<section id="gitattributes">
				<h2>26. Fins de Ligne & <code>.gitattributes</code></h2>

				<h3>Le Problème des Fins de Ligne (CRLF vs LF)</h3>
				<p>L'un des problèmes les plus courants et frustrants lorsque l'on travaille en équipe sur différents systèmes d'exploitation est la gestion des fins de ligne. Les systèmes Windows utilisent une séquence de deux caractères : retour chariot (Carriage Return, CR) et saut de ligne (Line Feed, LF), souvent notée CRLF. Les systèmes Unix (Linux, macOS) utilisent uniquement un saut de ligne (LF).</p>
				<p>Si les développeurs d'une équipe utilisent des systèmes différents sans configuration appropriée, Git peut :</p>
				<ul>
					<li>Signaler des modifications sur chaque ligne d'un fichier alors que seul le type de fin de ligne a changé.</li>
					<li>Corrompre les fins de ligne, rendant les scripts non exécutables sur certains systèmes ou causant des problèmes avec certains outils.</li>
				</ul>

				<h3>Configuration Globale (<code>core.autocrlf</code>)</h3>
				<p>Git tente de gérer ce problème avec le paramètre de configuration <code>core.autocrlf</code>. Il a trois valeurs possibles :</p>
				<ul>
					<li><strong><code>true</code> (Windows) :</strong>
						<code>git config --global core.autocrlf true</code>
						<br>Sur checkout (récupération) : Git convertit les fins de ligne LF en CRLF.
						<br>Sur commit (validation) : Git convertit les fins de ligne CRLF en LF.
						<br>C'est la configuration recommandée pour les utilisateurs Windows.
					</li>
					<li><strong><code>input</code> (macOS/Linux) :</strong>
						<code>git config --global core.autocrlf input</code>
						<br>Sur checkout : Git ne fait rien.
						<br>Sur commit : Git convertit les fins de ligne CRLF en LF.
						<br>C'est la configuration recommandée pour les utilisateurs macOS et Linux.
					</li>
					<li><strong><code>false</code> :</strong>
						<code>git config --global core.autocrlf false</code>
						<br>Git ne fait aucune conversion. Les fins de ligne sont commitées telles quelles. Non recommandé pour les projets multi-OS.
					</li>
				</ul>
				<p>Bien que <code>core.autocrlf</code> aide, il n'est pas toujours suffisant et peut être source de confusion car il dépend de la configuration locale de chaque développeur. Une solution plus robuste et centralisée est d'utiliser un fichier <code>.gitattributes</code>.</p>

				<h3>Le Fichier <code>.gitattributes</code> : Introduction</h3>
				<p>Le fichier <code>.gitattributes</code> permet de déclarer des attributs spécifiques pour des chemins (fichiers ou répertoires) dans votre dépôt. Ces attributs indiquent à Git comment traiter ces chemins. Contrairement à <code>.gitignore</code> qui spécifie les fichiers à ignorer, <code>.gitattributes</code> définit des comportements pour les fichiers suivis par Git.</p>
				<p>Ce fichier doit être commité dans votre dépôt pour que ses règles s'appliquent de manière cohérente à tous les collaborateurs. Il est généralement placé à la racine du projet.</p>
				<p>Chaque ligne du fichier <code>.gitattributes</code> suit le format :<br>
				<code>pattern attr1 attr2 ...</code><br>
				Où <code>pattern</code> est un motif de fichier (similaire à ceux de <code>.gitignore</code>, ex: <code>*.txt</code>, <code>src/*.js</code>) et <code>attr1</code>, <code>attr2</code> sont les attributs que vous assignez.</p>

				<h3>Gérer les Fins de Ligne via <code>.gitattributes</code></h3>
				<p>L'attribut le plus important pour la gestion des fins de ligne est <code>text</code>. Combiné avec <code>eol</code>, il offre un contrôle précis :</p>
				<ul>
					<li><strong><code>* text=auto</code></strong>
						<p>C'est la configuration la plus courante et recommandée pour commencer. Pour tous les fichiers (<code>*</code>), Git essaiera de deviner s'il s'agit de fichiers texte. Si c'est le cas, il normalisera les fins de ligne en LF dans le dépôt et les convertira aux fins de ligne natives du système d'exploitation de l'utilisateur lors du checkout (CRLF pour Windows, LF pour macOS/Linux).</p>
					</li>
					<li><strong><code>*.txt text</code></strong>
						<p>Traite tous les fichiers <code>.txt</code> comme des fichiers texte et normalise leurs fins de ligne (LF dans le dépôt).</p>
					</li>
					<li><strong><code>*.sh text eol=lf</code></strong>
						<p>Traite tous les scripts shell (<code>.sh</code>) comme des fichiers texte et s'assure qu'ils utilisent des fins de ligne LF, que ce soit dans le dépôt ou dans le répertoire de travail, quel que soit le système d'exploitation. C'est crucial car les scripts shell avec des fins de ligne CRLF ne fonctionnent pas correctement sur les systèmes Unix.</p>
					</li>
					<li><strong><code>*.bat text eol=crlf</code></strong>
						<p>Traite tous les scripts batch Windows (<code>.bat</code>) comme des fichiers texte et s'assure qu'ils utilisent des fins de ligne CRLF.</p>
					</li>
				</ul>
				<p><strong>Exemple de fichier <code>.gitattributes</code> :</strong></p>
				<pre class="language-text">
<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de fichier .gitattributes">Copier</button>
<code># Définit le comportement par défaut pour tous les fichiers
* text=auto

# Force les fins de ligne LF pour les types de fichiers sensibles
*.js    text eol=lf
*.jsx   text eol=lf
*.json  text eol=lf
*.css   text eol=lf
*.html  text eol=lf
*.sh    text eol=lf
*.py    text eol=lf
*.md    text eol=lf
*.xml   text eol=lf
*.yml   text eol=lf
*.yaml  text eol=lf

# Pour les fichiers Windows spécifiques, forcer CRLF
*.bat   text eol=crlf
*.cmd   text eol=crlf
*.sln   text eol=crlf
*.vcproj text eol=crlf

# Marquer les fichiers binaires (Git ne tentera pas de les convertir ou de les differ)
*.png   binary
*.jpg   binary
*.jpeg  binary
*.gif   binary
*.pdf   binary
*.zip   binary
*.exe   binary
*.dll   binary
*.o     binary
*.a     binary
*.obj   binary
*.so    binary</code></pre>
				<p>Après avoir ajouté ou modifié un fichier <code>.gitattributes</code>, il est possible que vous deviez rafraîchir les fichiers de votre répertoire de travail pour que les nouvelles règles s'appliquent. Git ne modifie pas automatiquement les fichiers déjà présents. Vous pouvez le faire en :</p>
				<pre class="language-bash">
<button class="btn btn-light copy-btn" aria-label="Copier les commandes pour rafraîchir les fichiers après modification de .gitattributes">Copier</button>
<code>git add . --renormalize</code></pre>
				<p>Puis commitez les changements si Git détecte des normalisations de fins de ligne.</p>

				<h3>Marquer les Fichiers Binaires</h3>
				<p>Il est important d'indiquer à Git quels fichiers sont binaires. Git essaiera de ne pas modifier les fins de ligne de ces fichiers et ne tentera pas de générer des diffs textuels pour eux.</p>
				<p>Vous pouvez le faire avec l'attribut <code>binary</code> ou en spécifiant <code>-text</code> :</p>
				<ul>
					<li><code>*.png binary</code></li>
					<li><code>*.jpg -text</code> (signifie "pas un fichier texte")</li>
				</ul>
				<p>Cela empêche la corruption de fichiers binaires par les conversions de fins de ligne et rend les opérations comme <code>git diff</code> plus performantes pour ces fichiers.</p>
				<div class="alert alert-info" role="alert">
					Utiliser un fichier <code>.gitattributes</code> bien configuré est une bonne pratique pour tout projet, surtout ceux impliquant plusieurs collaborateurs ou systèmes d'exploitation, afin d'éviter les problèmes liés aux fins de ligne et de s'assurer que Git traite correctement les différents types de fichiers.
				</div>
			</section>

			<!-- (27) GIT RERERE -->
			<section id="git-rerere">
				<h2>27. <code>git rerere</code> (Reuse Recorded Resolution)</h2>

				<h3>Le Problème : Résoudre les Mêmes Conflits Répétitivement</h3>
				<p>Lorsque vous travaillez sur des branches qui vivent longtemps et que vous rebasez fréquemment sur une branche principale active (comme <code>main</code> ou <code>develop</code>), ou lorsque vous effectuez des merges répétitifs entre les mêmes branches, vous pouvez vous retrouver à résoudre les mêmes conflits de fusion encore et encore. Cela peut être fastidieux et source d'erreurs.</p>
				<p>Par exemple, si vous avez une branche de fonctionnalité et que vous la rebasez sur <code>main</code>, vous résolvez des conflits. Si, quelques jours plus tard, vous rebasez à nouveau cette même branche sur une version plus récente de <code>main</code>, il est probable que beaucoup des mêmes conflits réapparaissent.</p>

				<h3>Qu'est-ce que <code>git rerere</code> et Comment Ça Marche ?</h3>
				<p><code>rerere</code> signifie "<strong>re</strong>use <strong>re</strong>corded <strong>re</strong>solution" (réutiliser la résolution enregistrée). C'est une fonctionnalité de Git qui observe comment vous résolvez les conflits de hunk (morceaux de code en conflit) et enregistre ces résolutions. Si Git rencontre à nouveau exactement le même conflit, il peut automatiquement appliquer la résolution que vous aviez précédemment fournie.</p>
				<p>Lorsqu'un conflit de fusion se produit et que <code>rerere</code> est activé :</p>
				<ol>
					<li>Git vérifie si ce conflit exact a déjà été résolu et enregistré.</li>
					<li>S'il trouve un enregistrement correspondant, il utilise la résolution précédente pour modifier les fichiers dans votre répertoire de travail. Les fichiers peuvent alors apparaître comme résolus (ou partiellement résolus si de nouveaux conflits sont présents).</li>
					<li>Si le conflit est nouveau, Git enregistre l'état pré-résolution du conflit. Une fois que vous avez résolu le conflit manuellement et que vous avez fait <code>git add</code> sur les fichiers concernés, Git enregistre la manière dont vous l'avez résolu.</li>
				</ol>
				<p>Cela ne signifie pas que vous n'aurez plus jamais à résoudre de conflits, mais cela peut considérablement réduire le nombre de conflits identiques que vous devez traiter manuellement.</p>

				<h3>Activer <code>git rerere</code></h3>
				<p>La fonctionnalité <code>rerere</code> n'est pas activée par défaut. Pour l'activer globalement pour tous vos dépôts :</p>
				<pre class="language-bash">
<button class="btn btn-light copy-btn" aria-label="Copier la commande pour activer git rerere globalement">Copier</button>
<code>git config --global rerere.enabled true</code></pre>
				<p>Vous pouvez également l'activer uniquement pour un dépôt spécifique en omettant l'option <code>--global</code> dans le répertoire de ce dépôt.</p>
				<p>Une fois activé, Git créera un répertoire <code>rr-cache</code> dans votre dossier <code>.git</code> pour stocker les résolutions enregistrées. Ce cache est spécifique à votre dépôt local (il n'est pas poussé vers le distant, bien qu'il puisse être partagé manuellement si nécessaire, mais c'est un cas d'usage plus avancé).</p>
				<p>Il existe aussi l'option <code>rerere.autoupdate</code> :</p>
				<pre class="language-bash">
<button class="btn btn-light copy-btn" aria-label="Copier la commande pour activer rerere.autoupdate">Copier</button>
<code>git config --global rerere.autoupdate true</code></pre>
				<p>Si <code>rerere.autoupdate</code> est à <code>true</code> (par défaut à <code>false</code>), Git mettra automatiquement à jour l'index (comme si vous aviez fait <code>git add</code>) pour les hunks qu'il a pu résoudre automatiquement grâce à <code>rerere</code>. Cela peut vous faire gagner une étape, mais certains préfèrent vérifier la résolution automatique avant de l'ajouter à l'index.</p>

				<h3>Quand est-ce le plus utile ?</h3>
				<ul>
					<li><strong>Rebases fréquents :</strong> Si vous maintenez une branche de fonctionnalité à jour en la rebasant régulièrement sur une branche cible qui évolue rapidement.</li>
					<li><strong>Branches de longue durée :</strong> Pour les branches qui divergent significativement et qui sont mergées ou rebasées périodiquement.</li>
					<li><strong>Maintenance de plusieurs versions :</strong> Lors du backporting de correctifs sur d'anciennes branches de release, où des conflits similaires peuvent survenir.</li>
					<li><strong>Lors de l'utilisation de <code>git bisect</code> :</strong> Si la recherche binaire implique des merges ou des rebases qui génèrent des conflits répétitifs.</li>
				</ul>

				<h3>Commandes Associées (Optionnel)</h3>
				<p>Bien que <code>rerere</code> fonctionne principalement en arrière-plan, quelques commandes peuvent être utiles pour interagir avec le cache <code>rr-cache</code> :</p>
				<ul>
					<li><code>git rerere status</code> : Affiche les conflits que <code>rerere</code> suit actuellement.</li>
					<li><code>git rerere diff</code> : Affiche les diffs des résolutions enregistrées.</li>
					<li><code>git rerere remaining</code> : Affiche les conflits qui nécessitent encore une résolution manuelle (si <code>rerere.autoupdate</code> est false ou si certains hunks n'ont pas pu être résolus).</li>
					<li><code>git rerere clear</code> : Supprime tous les enregistrements du cache <code>rr-cache</code> pour le dépôt courant (utile si vous pensez qu'une résolution incorrecte a été enregistrée).</li>
					<li><code>git rerere gc</code> : Effectue un nettoyage (garbage collection) des anciennes résolutions enregistrées qui ne sont plus pertinentes.</li>
				</ul>
				<p>En général, vous n'aurez pas besoin d'utiliser ces commandes fréquemment, car l'avantage principal de <code>rerere</code> est son automatisation silencieuse.</p>
				<div class="alert alert-success" role="alert">
					<strong>En résumé :</strong> <code>git rerere</code> est un outil discret mais puissant qui apprend de vos résolutions de conflits passées pour vous faire gagner du temps sur des conflits identiques à l'avenir. Activez-le et laissez-le travailler en arrière-plan !
				</div>
			</section>

			<!-- (28) COLLABORATION AVANCEE SUR PLATEFORMES -->
			<section id="collaboration-plateformes">
				<h2>28. Collaboration Avancée sur Plateformes</h2>

				<h3>Introduction : Au-delà du <code>push</code> et <code>pull</code></h3>
				<p>Si les commandes Git de base comme <code>push</code>, <code>pull</code>, <code>commit</code>, et <code>branch</code> sont essentielles pour le travail individuel et la synchronisation simple, la collaboration moderne sur des projets logiciels, en particulier avec des équipes ou sur des projets open source, s'appuie fortement sur les fonctionnalités offertes par les plateformes d'hébergement Git telles que GitHub, GitLab, Bitbucket, etc. Ces plateformes fournissent des outils et des workflows qui facilitent la revue de code, la discussion, le suivi des tâches et l'intégration des contributions de manière structurée.</p>

				<h3>Pull Requests (PRs) / Merge Requests (MRs) : Le Cœur de la Collaboration</h3>
				<p>Les Pull Requests (terme utilisé par GitHub et Bitbucket) ou Merge Requests (terme utilisé par GitLab) sont le mécanisme central de la collaboration sur ces plateformes. Une PR/MR est une proposition formelle d'intégrer les changements d'une branche (par exemple, une branche de fonctionnalité) dans une autre (souvent la branche principale comme <code>main</code> ou <code>develop</code>).</p>
				<h5>Bonnes pratiques pour la création de PRs/MRs :</h5>
				<ul>
					<li><strong>Titre clair et concis :</strong> Le titre doit résumer l'objectif de la PR/MR. Beaucoup d'équipes utilisent des préfixes (ex: <code>feat:</code>, <code>fix:</code>, <code>docs:</code>) inspirés des Conventional Commits.</li>
					<li><strong>Description détaillée :</strong> Expliquez le <em>pourquoi</em> des changements, le problème résolu ou la fonctionnalité ajoutée. Incluez des liens vers les issues/tickets concernés. Si des changements d'interface utilisateur sont impliqués, des captures d'écran ou des GIFs sont très utiles.</li>
					<li><strong>Commits atomiques et propres :</strong> La branche source de la PR/MR devrait avoir un historique de commits propre et compréhensible. Chaque commit devrait représenter une étape logique. Utilisez le <a href="#rebase">rebase interactif</a> pour nettoyer votre historique local avant de créer la PR/MR ou de la mettre à jour.</li>
					<li><strong>Petites PRs/MRs ciblées :</strong> Privilégiez des PRs/MRs de petite taille, focalisées sur un seul objectif. Elles sont plus faciles et rapides à réviser, à tester et à merger.</li>
					<li><strong>Auto-revue :</strong> Relisez votre propre code et la description de votre PR/MR avant de la soumettre ou de demander des revues. Vous trouverez souvent des erreurs ou des améliorations vous-même.</li>
				</ul>
				<h5>Le processus de revue de code :</h5>
				<p>La revue de code est une étape cruciale pour améliorer la qualité du code, partager les connaissances et détecter les bugs tôt. Voici quelques conseils :</p>
				<ul>
					<li><strong>Pour le réviseur :</strong>
						<ul>
							<li>Soyez constructif et respectueux. Le but est d'améliorer le code, pas de critiquer l'auteur.</li>
							<li>Comprenez le contexte et l'objectif des changements.</li>
							<li>Vérifiez la logique, la clarté, la performance, la sécurité, la maintenabilité, et la conformité aux conventions du projet.</li>
							<li>Posez des questions plutôt que d'affirmer. Suggérez des améliorations au lieu d'imposer des changements.</li>
							<li>Utilisez les outils de la plateforme (commentaires en ligne, suggestions de code).</li>
						</ul>
					</li>
					<li><strong>Pour l'auteur :</strong>
						<ul>
							<li>Ne prenez pas le feedback personnellement. Considérez-le comme une opportunité d'apprendre et d'améliorer.</li>
							<li>Répondez aux commentaires, expliquez vos choix si nécessaire, ou indiquez que vous allez appliquer les suggestions.</li>
							<li>Poussez de nouveaux commits sur votre branche pour adresser le feedback. La PR/MR se mettra à jour automatiquement.</li>
							<li>Remerciez les réviseurs pour leur temps.</li>
						</ul>
					</li>
				</ul>
				<p>La discussion continue jusqu'à ce que la PR/MR soit approuvée et prête à être mergée.</p>

				<h3>Gestion des Issues / Tickets</h3>
				<p>Les plateformes Git fournissent des systèmes de suivi des "issues" (problèmes, tâches, bugs, demandes de fonctionnalités). Une bonne gestion des issues est essentielle pour l'organisation du projet.</p>
				<ul>
					<li><strong>Création d'issues claires :</strong> Une issue bien décrite comprend un titre explicite, des étapes pour reproduire un bug (si applicable), le comportement attendu vs. le comportement observé, et toute information contextuelle pertinente (version du logiciel, environnement, etc.).</li>
					<li><strong>Liaison Issues - Commits - PRs/MRs :</strong> La plupart des plateformes permettent de lier les issues au travail effectué. En incluant des mots-clés comme <code>fixes #123</code>, <code>closes #123</code>, ou <code>resolves #123</code> dans vos messages de commit ou descriptions de PR/MR, l'issue #123 sera automatiquement fermée lorsque la PR/MR sera mergée dans la branche par défaut. Vous pouvez aussi simplement mentionner une issue (<code>ref #123</code>) pour créer un lien sans la fermer.</li>
					<li><strong>Labels (Étiquettes) :</strong> Utilisez des labels pour catégoriser les issues (ex: <code>bug</code>, <code>enhancement</code>, <code>documentation</code>, <code>priority:high</code>, <code>good first issue</code>). Cela aide à filtrer et à prioriser le travail.</li>
					<li><strong>Milestones (Jalons) :</strong> Regroupez des issues et des PRs/MRs en milestones pour suivre l'avancement vers une version ou un objectif spécifique.</li>
					<li><strong>Assignations :</strong> Assignez des issues aux membres de l'équipe pour clarifier qui est responsable de quoi.</li>
				</ul>

				<h3>Stratégies de Merge des PRs/MRs sur les Plateformes</h3>
				<p>Lorsque une PR/MR est prête, les plateformes offrent généralement plusieurs options pour l'intégrer :</p>
				<ul>
					<li><strong>Merge Commit (Créer un commit de fusion) :</strong>
						<ul>
							<li>C'est l'option par défaut sur beaucoup de plateformes (ex: le bouton "Merge pull request" de GitHub).</li>
							<li>Tous les commits de la branche de fonctionnalité sont conservés, et un nouveau commit de merge est créé sur la branche cible pour lier les historiques.</li>
							<li><strong>Avantages :</strong> Préserve tout l'historique de la branche de fonctionnalité, y compris les commits individuels. Le point de merge est clairement identifiable.</li>
							<li><strong>Inconvénients :</strong> Peut rendre l'historique de la branche principale plus "bruyant" avec de nombreux commits de merge si les branches de fonctionnalités ont beaucoup de petits commits intermédiaires.</li>
						</ul>
					</li>
					<li><strong>Squash and Merge (Écraser et fusionner) :</strong>
						<ul>
							<li>Combine tous les commits de la branche de fonctionnalité en un seul commit sur la branche cible. Le message de ce commit unique peut être édité à partir des messages des commits originaux.</li>
							<li><strong>Avantages :</strong> Maintient un historique de la branche principale très propre et linéaire, avec un seul commit par fonctionnalité ou PR mergée.</li>
							<li><strong>Inconvénients :</strong> Perd la granularité de l'historique de la branche de fonctionnalité (les commits individuels de développement ne sont plus visibles sur la branche principale).</li>
						</ul>
					</li>
					<li><strong>Rebase and Merge (Rebaser et fusionner) :</strong>
						<ul>
							<li>Prend tous les commits de la branche de fonctionnalité, les rebase sur la dernière version de la branche cible, puis les ajoute à la branche cible sans créer de commit de merge (effectue un fast-forward si possible).</li>
							<li><strong>Avantages :</strong> Crée un historique parfaitement linéaire sur la branche principale, sans commits de merge. Les commits individuels de la fonctionnalité sont préservés.</li>
							<li><strong>Inconvénients :</strong> Réécrit l'historique des commits de la branche de fonctionnalité (nouveaux SHA). Peut rendre plus complexe le suivi de quand exactement une branche a été "mergée" si l'on ne regarde que le graphe. Nécessite que les contributeurs soient à l'aise avec le rebase de leurs branches.</li>
						</ul>
					</li>
				</ul>
				<p>Le choix de la stratégie dépend des préférences de l'équipe et du projet. Beaucoup d'équipes optent pour "Squash and Merge" ou "Rebase and Merge" pour garder un historique <code>main</code> propre, tout en s'assurant que les PRs elles-mêmes contiennent des commits bien structurés.</p>

				<h3>Forks et Contribution à des Projets Externes</h3>
				<p>Lorsque vous voulez contribuer à un projet open source auquel vous n'avez pas les droits de push directs, le workflow typique est "Fork & Pull Request" :</p>
				<ol>
					<li><strong>Forker le dépôt :</strong> Sur la plateforme (GitHub, GitLab), créez une copie personnelle (un "fork") du dépôt original sous votre propre compte.</li>
					<li><strong>Cloner votre fork :</strong> Clonez votre fork sur votre machine locale : <code>git clone https://github.com/VOTRE_NOM_UTILISATEUR/nom-du-projet.git</code></li>
					<li><strong>Configurer un remote <code>upstream</code> :</strong> Ajoutez le dépôt original comme un remote pour pouvoir récupérer ses mises à jour : <code>git remote add upstream https://github.com/PROPRIETAIRE_ORIGINAL/nom-du-projet.git</code></li>
					<li><strong>Créer une branche de fonctionnalité :</strong> Travaillez toujours sur une branche dédiée : <code>git checkout -b ma-contribution</code></li>
					<li><strong>Faire vos modifications et commits.</strong></li>
					<li><strong>Pousser votre branche sur votre fork :</strong> <code>git push origin ma-contribution</code></li>
					<li><strong>Ouvrir une Pull Request :</strong> Depuis votre fork sur la plateforme, ouvrez une PR ciblant la branche appropriée du dépôt <code>upstream</code> (original).</li>
					<li><strong>Maintenir son fork et sa branche à jour :</strong> Pendant que votre PR est en revue, le projet <code>upstream</code> peut évoluer. Pour mettre votre branche à jour :
						<pre class="language-bash">
<button class="btn btn-light copy-btn" aria-label="Copier les commandes pour mettre à jour un fork">Copier</button>
<code>git checkout main # ou la branche principale de votre fork
git fetch upstream
git merge upstream/main # Mettre à jour votre main local avec le main de l'upstream
git checkout ma-contribution
git rebase main # Rebaser votre branche de contribution sur votre main à jour
git push origin ma-contribution --force-with-lease # Mettre à jour la PR (force-push nécessaire après rebase)</code></pre>
					</li>
				</ol>

				<h3>Utilisation des "Draft PRs" / "WIP PRs"</h3>
				<p>La plupart des plateformes permettent de créer des Pull Requests en mode "Brouillon" (Draft) ou de les marquer comme "Work In Progress" (WIP) dans leur titre. C'est utile lorsque :</p>
				<ul>
					<li>Vous voulez obtenir un feedback préliminaire sur une idée ou une approche avant que le code ne soit finalisé.</li>
					<li>Vous voulez utiliser l'intégration continue (CI) de la PR pour lancer des tests sur votre branche, même si elle n'est pas prête pour une revue complète.</li>
					<li>Cela signale aux réviseurs potentiels que la PR n'est pas encore prête à être mergée.</li>
				</ul>
				<p>Une fois prête, vous pouvez convertir la Draft PR en une PR normale pour une revue formelle.</p>
			</section>

		</div><!-- Fin .container -->
	</div><!-- Fin .contentWithToc -->

	<footer>
		<div class="container">
			<p class="m-0">Cours réalisé par <strong>G.G. Paterne</strong> - Tous droits réservés</p>
		</div>
	</footer>

	<!-- Bouton Scroll to Top -->
	<button type="button" class="btn btn-danger btn-floating" id="btnScrollTop" data-mdb-ripple-color="light" aria-label="Retourner en haut de la page">
		↑
	</button>

	<!-- Visually hidden span for screen reader announcements -->
	<span class="visually-hidden" id="sr-feedback" aria-live="polite" aria-atomic="true"></span>

	<!-- MDB JavaScript -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/8.1.0/mdb.min.js">
	</script>

	<!-- Prism.js pour coloration syntaxique -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js">
	</script>
	<!-- Custom JavaScript -->
	<script src="script.js"></script>
</body>

</html>