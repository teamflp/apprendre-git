<!DOCTYPE html>
<html lang="fr">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="author" content="G.G. Paterne" />
	<meta name="description" content="Cours complet Git avec fonctionnalités avancées">
	<title>Cours Complet Git - G.G. Paterne</title>

	<!-- MDB CSS (Material Design for Bootstrap) -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/8.1.0/mdb.min.css" />
	<!-- Prism.js CSS pour coloration syntaxique -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
	<!-- Font Awesome (icônes) -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" />
	<!-- Custom CSS -->
	<link rel="stylesheet" href="styles.css" />
</head>

<body>

	<!-- Barre de progression -->
	<div id="readingProgress"></div>

	<!-- Barre top mobile -->
	<nav class="navbar navbar-light bg-light d-md-none" id="menuTopBar">
		<div class="container-fluid">
			<!-- Titre / Logo -->
			<span class="navbar-brand fw-bold">Cours Git</span>

			<!-- Bouton Hamburger -->
			<button class="navbar-toggler" type="button" id="hamburgerBtn" style="border:none; background:none;" aria-label="Ouvrir/fermer le menu de navigation" aria-expanded="false" aria-controls="navbarTOC">
				<i class="fas fa-bars" aria-hidden="true"></i>
			</button>
		</div>
	</nav>

	<!-- Menu Table des Matières (Responsive) -->
	<nav id="navbarTOC"> <!-- The ID is used by aria-controls -->
		<h5>Table des Matières</h5>
		<a href="#introduction">1. Introduction</a>
		<a href="#installation">2. Installation & Config</a>
		<a href="#depots">3. Dépôts</a>
		<a href="#modifications">4. Suivi & Commit</a>
		<a href="#branches">5. Branches</a>
		<a href="#fusion">6. Merge & Conflits</a>
		<a href="#rebase">7. Rebase</a>
		<a href="#comparaison">8. Comparaison & Analyse</a>
		<a href="#annuler">9. Annuler/Commits</a>
		<a href="#stash">10. Stash</a>
		<a href="#depots-distants">11. Distants & Collab</a>
		<a href="#tags">12. Tags</a>
		<a href="#submodules">13. Submodules</a>
		<a href="#avancees">14. Avancées & Utilitaires</a>
		<a href="#bonnes-pratiques">15. Bonnes Pratiques</a>
		<a href="#commandes-avancees-git">16. Commandes Avancées de Git</a>
		<a href="#tableau-commands">17. Tableau Complet</a>
		<a href="#exemples">18. Exemples Concrets</a>
		<a href="#exercices-pieges">19. Exercices & Pièges</a>
		<a href="#commit-conventions">20. Conventions Commit</a>
		<a href="#github-actions">21. CI/CD GitHub</a>
		<a href="#glossaire">22. Glossaire Git</a>
		<a href="#conclusion">23. Conclusion</a>

		<hr />
		<button class="btn btn-sm btn-dark" id="toggleDarkMode" aria-pressed="false" aria-label="Basculer le mode d'affichage entre clair et sombre">Dark Mode</button>
	</nav>


	<!-- Contenu principal (décalé par rapport au menu) -->
	<div class="contentWithToc">

		<!-- Hero -->
		<div class="hero">
			<div class="container">
				<h1 class="fw-bold">Apprendre à utiliser les commandes Git</h1>
				<p class="fst-italic">Par <strong>G.G. Paterne</strong></p>
			</div>
		</div>

		<div class="container my-4">

			<!-- Recherche code -->
			<input type="text" class="form-control" id="searchBar" placeholder="Filtrer les snippets de code…" />

			<!-- (1) INTRODUCTION -->
			<section id="introduction">
				<h2>1. Introduction à Git</h2>
				<h3>Qu’est-ce que Git ?</h3>
				<p>
					Git est un outil (logiciel) pour suivre les changements dans le code.
					Il permet de créer un historique de toutes les modifications.
					On peut aussi travailler à plusieurs dessus, sans se marcher sur les pieds.
				</p>
				<p><strong>Pourquoi utiliser Git ?</strong></p>
				<ul>
					<li>Revenir à une version antérieure si on casse quelque chose.</li>
					<li>Travailler à plusieurs sur le même projet, mais sur différentes branches.</li>
					<li>Garder un historique de tous les commits (changements).</li>
				</ul>


				<!-- Bouton de téléchargement -->
				<a href="Apprendre-git-par-la-pratique.pdf" class="btn btn-primary mt-3" download="CoursCompletGit">
					<i class="fas fa-download"></i>Télécharger le cours complet (PDF)
				</a>

				<hr />
			</section>

			<!-- (2) INSTALLATION & CONFIG -->
			<section id="installation">
				<h2>2. Installation et configuration</h2>
				<h3>Installation</h3>
				<p>
					Pour utiliser Git, on doit l’installer sur l’ordinateur.
					Sur Linux Ubuntu/Debian, on peut faire :
				</p>
				<p>
					Sur Windows ou Mac, on peut télécharger l’installeur sur le site officiel :
					<a href="https://git-scm.com/download" target="_blank">https://git-scm.com/download</a>
				</p>

<pre class="language-bash">
	<div>
		<button class="btn btn-light copy-btn" aria-label="Copier le bloc de code d'installation">Copier</button>
	</div>
	
<code>
sudo apt update
sudo apt install git
</code>
</pre>

	<p>Ces deux commandes mettent à jour la liste des paquets et installent Git.</p>


				<h3>Configuration globale</h3>
				<p>Donner son nom et email pour que Git sache qui fait les commits :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier le bloc de code de configuration globale">Copier</button>
<code>
git config --global user.name "Votre Nom" 
git config --global user.email "votre.email@example.com"</code>
</pre>
				<p>On peut choisir son éditeur préféré, comme nano ou vim :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git config --global core.editor "nano"</code>
</pre>
<p>	
	Cette commande configure nano comme éditeur par défaut.
</p>
				<p>Pour voir toutes les configs :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git config --list</code>
</pre>
			</section>

			<!-- (3) DEPOTS -->
			<section id="depots">
				<h2>3. Initialiser et gérer un dépôt</h2>
				<h3>Initialiser un nouveau dépôt</h3>
				<p>
					Pour commencer à suivre un projet avec Git, on fait :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git init</code>
</pre>
				<p>
					Cela crée un dossier caché <code>.git</code> qui contient toutes les infos de suivi (commits,
					historique...).
				</p>

				<h3>Cloner un dépôt existant</h3>
				<p>
					Si un projet existe déjà sur GitHub ou ailleurs, on peut le copier localement :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git clone https://github.com/utilisateur/projet.git</code>
</pre>
				<p>
					Cela crée un dossier avec tout le code et l’historique.
				</p>

				<h3>Ajouter un dépôt distant</h3>
				<p>
					Pour lier son dossier local à un dépôt en ligne (ex: GitHub), on utilise :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git remote add origin https://github.com/utilisateur/projet.git</code>
</pre>

				<h3>Lister / Renommer / Supprimer un dépôt distant</h3>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git remote -v              # Voir les dépôts distants
git remote rename origin old   # Renommer 'origin' en 'old'
git remote remove origin       # Supprimer le remote 'origin'</code>
</pre>
			</section>

			<!-- (4) SUIVI & COMMIT -->
			<section id="modifications">
				<h2>4. Suivi et validation des modifications</h2>
				<h3>Vérifier l'état</h3>
				<p>Pour voir quels fichiers sont modifiés ou non suivis :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git status</code>
</pre>

				<h3>Ajouter des fichiers</h3>
				<p>
					Avant de faire un commit, on doit ajouter les fichiers dans la “zone de staging” :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git add fichier.txt
git add .</code>
</pre>
				<p>
					Le premier ajoute un seul fichier, le second ajoute tout ce qui est modifié/nouveau.
				</p>

				<h3>Créer un commit</h3>
				<p>
					Pour enregistrer définitivement les changements dans l’historique :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git commit -m "Description du changement"</code>
</pre>
				<p>On peut tout faire d’un coup (pour les fichiers déjà suivis) : <code>git commit -am "message"</code>
				</p>

				<h3>Afficher l’historique</h3>
				<p>Voir la liste de tous les commits déjà faits :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git log
git log --oneline
git log --graph --decorate --oneline</code>
</pre>
			</section>

			<!-- (5) BRANCHES -->
			<section id="branches">
				<h2>5. Branches et navigation</h2>
				<h3>Créer et lister</h3>
				<p>Pour voir ou créer une branche :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git branch
git branch nouvelle-branche</code>
</pre>

				<h3>Changer de branche</h3>
				<p>On se déplace sur une branche existante :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git checkout nouvelle-branche</code>
</pre>
				<p>Ou on la crée et on y va d’un coup :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git checkout -b nouvelle-branche</code>
</pre>

				<h3>Renommer / Supprimer une branche</h3>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git branch -m ancien_nom nouveau_nom   # Renommer
git branch -d branche            # Supprimer une branche fusionnée
git branch -D branche            # Supprimer quand pas fusionnée</code>
</pre>
			</section>

			<!-- (6) MERGE & CONFLITS -->
			<section id="fusion">
				<h2>6. Merge (Fusion) et Conflits</h2>
				<h3>Fusionner deux branches</h3>
				<p>
					On se place sur la branche où on veut intégrer les changements (souvent main ou master), puis on
					merge :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git checkout main
git merge nouvelle-branche</code>
</pre>

				<h3>Conflits</h3>
				<p>
					S’il y a des conflits, Git arrête le merge et on doit résoudre à la main :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git add fichier_conflit.txt
git commit -m "Résolution du conflit"</code>
</pre>

				<h3>Merge “no fast-forward”</h3>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git merge --no-ff nouvelle-branche</code>
</pre>
				<p>
					Crée un commit de merge même si on peut faire un fast-forward, pour garder une trace.
				</p>
			</section>

			<!-- (7) REBASE -->
			<section id="rebase">
				<h2>7. Rebase (Réécriture de l’historique)</h2>

				<h3>7.1. Qu’est-ce que <code>git rebase</code> ?</h3>
				<p>
					La commande <code>git rebase</code> est l'une des fonctionnalités les plus puissantes de Git, mais aussi l'une de celles qui nécessitent le plus de prudence. Son objectif principal est de **réécrire l'historique des commits** pour le rendre plus linéaire, propre et compréhensible.
				</p>
				<p>
					Conceptuellement, un rebase prend une série de commits d'une branche et les "rejoue" un par un sur une autre base (un autre commit, souvent la tête d'une autre branche). Cela contraste avec <code>git merge</code>, qui intègre les changements en créant un nouveau commit de fusion qui relie les deux historiques.
				</p>
				<h4>Avantages du Rebase :</h4>
				<ul>
					<li><strong>Historique linéaire et propre :</strong> Le principal avantage est un historique de projet sans les "bulles" ou les ramifications créées par les commits de merge. Cela rend le log plus facile à lire et à analyser.</li>
					<li><strong>Nettoyage des commits locaux :</strong> Avant de partager votre travail (par exemple, via une Pull Request), vous pouvez utiliser le rebase interactif pour réorganiser, fusionner, modifier ou supprimer vos commits locaux, présentant ainsi un ensemble de changements cohérents et bien décrits.</li>
					<li><strong>Facilite la revue de code :</strong> Des Pull Requests (PRs) avec un historique propre et linéaire sont plus faciles à examiner pour les relecteurs.</li>
				</ul>
				<h4>Quand utiliser <code>git rebase</code> ?</h4>
				<ul>
					<li>Principalement sur vos **branches de fonctionnalités locales** avant de les fusionner dans une branche principale (comme `main` ou `develop`).</li>
					<li>Pour **mettre à jour votre branche de fonctionnalité** avec les derniers changements de la branche principale.</li>
					<li>Pour **nettoyer votre historique local** avant de le pousser vers un dépôt partagé.</li>
				</ul>
				<div class="alert alert-warning" role="alert">
					<strong>Note importante :</strong> Le rebase réécrit l'historique. Cela signifie que les SHA-1 des commits rebasés changent. C'est la raison pour laquelle il faut être très prudent avec les branches qui ont déjà été partagées (voir <a href="#rebase-golden-rule">La Règle d'Or du Rebase</a>).
				</div>

				<h3>7.2. Rebase Simple : Mettre à jour votre branche</h3>
				<p>
					Le cas d'usage le plus courant du rebase est de mettre à jour votre branche de fonctionnalité avec les derniers changements de la branche principale (par exemple, `main`). Cela permet d'intégrer les nouveautés avant de continuer votre travail ou de proposer une fusion.
				</p>
				<p>Supposons que vous travaillez sur une branche <code>feature/ma-nouvelle-fonction</code> et que la branche <code>main</code> a reçu de nouveaux commits :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier le code pour un rebase simple">Copier</button>
<code># 1. Assurez-vous que votre branche principale locale (main) est à jour
git checkout main
git pull origin main

# 2. Retournez sur votre branche de fonctionnalité
git checkout feature/ma-nouvelle-fonction

# 3. Rebasez votre branche sur main
git rebase main</code></pre>
				<p>
					Git va alors prendre tous les commits de <code>feature/ma-nouvelle-fonction</code> qui ne sont pas déjà dans <code>main</code>, les mettre de côté temporairement, avancer la tête de <code>feature/ma-nouvelle-fonction</code> pour qu'elle pointe sur le dernier commit de <code>main</code>, puis réappliquer vos commits un par un.
				</p>
				<h4>Utilisation de <code>git pull --rebase</code></h4>
				<p>
					Lorsque vous travaillez sur une branche locale (qui peut ou non suivre une branche distante) et que vous voulez récupérer les mises à jour de la branche distante correspondante, utiliser <code>git pull --rebase</code> est souvent préférable à un simple <code>git pull</code> (qui effectue un merge par défaut).
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git pull --rebase">Copier</button>
<code># Sur votre branche locale, pour la mettre à jour depuis son équivalent distant
git pull --rebase origin nom-de-la-branche</code></pre>
				<p>
					Cela va d'abord récupérer les commits distants (fetch), puis rebaser vos commits locaux (ceux qui ne sont pas encore sur le distant) par-dessus les nouveaux commits récupérés. Cela évite la création d'un commit de merge local non nécessaire et maintient un historique linéaire. C'est une pratique très courante pour les branches de fonctionnalités personnelles.
				</p>
				<p>Vous pouvez configurer Git pour que `pull` utilise `--rebase` par défaut pour certaines branches ou globalement :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la configuration pour pull --rebase par défaut">Copier</button>
<code># Pour la branche courante
git config pull.rebase true

# Globalement pour toutes les nouvelles branches (attention, impacte tous vos projets)
# git config --global pull.rebase true</code></pre>


				<h3>7.3. Rebase Interactif (<code>git rebase -i</code>) : Peaufiner vos commits</h3>
				<p>
					Le rebase interactif est un outil extrêmement puissant pour nettoyer et réorganiser votre historique de commits local avant de le partager. Il vous permet de modifier des messages de commit, de fusionner des commits, de les supprimer, de les réordonner, etc.
				</p>
				<p>Pour lancer un rebase interactif, vous spécifiez la base sur laquelle vous voulez rebaser. Cela peut être un nom de branche, un SHA de commit, ou une référence comme `HEAD~N` (où N est le nombre de commits à partir de HEAD que vous voulez inclure dans le rebase).</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande de base pour un rebase interactif">Copier</button>
<code># Rebaser interactivement les 3 derniers commits
git rebase -i HEAD~3

# Rebaser interactivement tous les commits depuis la branche 'main' (exclus)
git rebase -i main</code></pre>
				<p>
					Après avoir lancé cette commande, votre éditeur de texte configuré s'ouvrira avec une liste des commits qui sont sur le point d'être rebasés. Chaque ligne représente un commit, commençant par le mot-clé `pick` :
				</p>
<pre class="language-text">
	<button class="btn btn-light copy-btn" aria-label="Copier l'exemple d'écran de rebase interactif">Copier</button>
<code>pick a1b2c3d Ajout fonctionnalité X (partie 1)
pick e4f5g6h Commit de travail intermédiaire
pick i7j8k9l Finalisation fonctionnalité X

# Rebase 1234567..i7j8k9l onto 1234567 (3 commands)
#
# Commands:
# p, pick <commit> = use commit
# r, reword <commit> = use commit, but edit the commit message
# e, edit <commit> = use commit, but stop for amending
# s, squash <commit> = use commit, but meld into previous commit
# f, fixup <commit> = like "squash", but discard this commit's log message
# x, exec <command> = run command (the rest of the line) using shell
# b, break = stop here (continue rebase later with 'git rebase --continue')
# d, drop <commit> = remove commit
# l, label <label> = label current HEAD with a name
# t, reset <label> = reset HEAD to a label
# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]
# .       create a merge commit using the original merge commit's
# .       message (or the oneline, if no original merge commit was
# .       specified). Use -c <commit> to re-create the merge commit
# .       using the same log message as <commit>.
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#</code></pre>
				<p>En bas de cette liste, vous trouverez des instructions sur les commandes (actions) que vous pouvez utiliser. Voici les plus courantes :</p>
				<ul>
					<li><strong><code>pick</code> (ou <code>p</code>) : Utiliser le commit.</strong>
						<p>C'est l'action par défaut. Le commit sera inclus dans l'historique rebasé tel quel.</p>
					</li>
					<li><strong><code>reword</code> (ou <code>r</code>) : Modifier le message du commit.</strong>
						<p>Si vous marquez un commit avec <code>reword</code>, Git s'arrêtera après avoir appliqué ce commit et vous invitera à modifier son message. Très utile pour corriger des typos ou clarifier un message de commit.</p>
						<p><em>Exemple :</em> Changez <code>pick</code> en <code>reword</code> sur la ligne du commit souhaité. Sauvegardez et fermez. Git ouvrira l'éditeur pour ce message de commit.</p>
					</li>
					<li><strong><code>edit</code> (ou <code>e</code>) : Modifier le contenu du commit.</strong>
						<p>Utilisez <code>edit</code> si vous voulez amender les changements introduits par ce commit (ajouter des fichiers, modifier du code) ou même scinder le commit en plusieurs plus petits.</p>
						<p>Lorsque Git rencontre un commit marqué <code>edit</code>, le processus de rebase s'interrompt. Vous pouvez alors faire vos modifications (ex: <code>git add ...</code>, <code>git commit --amend</code>), puis continuer le rebase avec <code>git rebase --continue</code>.</p>
					</li>
					<li><strong><code>squash</code> (ou <code>s</code>) : Fusionner le commit avec le commit précédent.</strong>
						<p>Le commit marqué <code>squash</code> est fusionné dans le commit qui le précède. Git ouvrira ensuite un éditeur pour vous permettre de combiner les messages des commits (ou d'en écrire un nouveau).</p>
						<p>Parfait pour combiner plusieurs petits commits ("WIP", "typo") en un seul commit de fonctionnalité cohérent.</p>
						<p><em>Exemple :</em></p>
<pre class="language-text">
	<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de squash">Copier</button>
<code>pick a1b2c3d Ajout de la fonctionnalité X (partie 1)
s e4f5g6h Correction typo sur X
s i7j8k9l Ajustements mineurs sur X</code></pre>
						<p>Ces trois commits deviendront un seul. Git vous demandera de fournir le message final.</p>
					</li>
					<li><strong><code>fixup</code> (ou <code>f</code>) : Fusionner avec le précédent, ignorer le message.</strong>
						<p>Similaire à <code>squash</code>, mais <code>fixup</code> jette le message du commit "fixup" et utilise uniquement le message du commit précédent. Le message du commit "fixé" n'est même pas présenté pour édition.</p>
						<p>Très pratique pour des petites corrections rapides où le message du commit original est suffisant.</p>
						<p><em>Exemple :</em></p>
<pre class="language-text">
	<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de fixup">Copier</button>
<code>pick a1b2c3d Ajout fonctionnalité Y
f b2c3d4e Oups, oubli d'un fichier pour Y</code></pre>
						<p>Le deuxième commit sera intégré au premier, et seul le message "Ajout fonctionnalité Y" sera conservé.</p>
					</li>
					<li><strong><code>drop</code> (ou <code>d</code>) : Supprimer complètement le commit.</strong>
						<p>Si un commit n'est plus nécessaire, vous pouvez le supprimer avec <code>drop</code> (ou en supprimant simplement sa ligne). Le commit et ses changements disparaîtront de l'historique. À utiliser avec précaution.</p>
					</li>
					<li><strong>Réordonner les commits :</strong>
						<p>Vous pouvez simplement changer l'ordre des lignes dans le fichier de rebase interactif pour changer l'ordre dans lequel les commits sont appliqués.</p>
					</li>
				</ul>
				<div class="alert alert-info" role="alert">
					<strong>Conseils pour le rebase interactif :</strong>
					<ul>
						<li>Ne modifiez que les actions (<code>pick</code>, <code>squash</code>, etc.) ou l'ordre des lignes. Ne supprimez pas les SHA des commits.</li>
						<li>Si vous faites une erreur en éditant le fichier d'instructions, vous pouvez généralement fermer l'éditeur sans sauvegarder, et Git annulera le rebase (ou utilisez <code>git rebase --abort</code>).</li>
						<li>Après avoir sauvegardé et fermé le fichier, Git appliquera les actions. Soyez prêt à <a href="#rebase-conflict-resolution">résoudre des conflits</a>.</li>
					</ul>
				</div>

				<h3 id="rebase-conflict-resolution">7.4. Gestion des Conflits pendant un Rebase</h3>
				<p>
					Des conflits peuvent survenir pendant un rebase si les changements que vous essayez de réappliquer entrent en conflit avec des changements sur la branche de base, ou même avec des changements de vos propres commits précédents qui ont été modifiés (par exemple, si vous réordonnez des commits qui touchent aux mêmes lignes).
				</p>
				<p>Lorsque Git rencontre un conflit, le processus de rebase s'interrompt et vous informe du fichier (ou des fichiers) en conflit. La procédure de résolution est la suivante :</p>
				<ol>
					<li>
						<strong>Identifier et résoudre le conflit :</strong> Ouvrez le(s) fichier(s) concerné(s). Git y aura inséré les marqueurs de conflit habituels (<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>). Modifiez le fichier pour obtenir le résultat souhaité, puis supprimez les marqueurs.
					</li>
					<li>
						<strong>Ajouter le fichier résolu au staging :</strong>
						<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git add après résolution de conflit de rebase">Copier</button>
<code>git add &lt;fichier_resolu_1&gt; [fichier_resolu_2...]</code></pre>
					</li>
					<li>
						<strong>Poursuivre le rebase :</strong>
						<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git rebase --continue">Copier</button>
<code>git rebase --continue</code></pre>
						<p>Git tentera alors d'appliquer le reste des commits.</p>
					</li>
				</ol>
				<h4>Options en cas de problème majeur lors d'un conflit :</h4>
				<ul>
					<li>
						<strong>Annuler complètement le rebase :</strong> Si la résolution des conflits devient trop complexe ou si vous n'êtes pas sûr de ce que vous faites, vous pouvez toujours revenir à l'état d'avant le rebase :
						<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git rebase --abort">Copier</button>
<code>git rebase --abort</code></pre>
					</li>
					<li>
						<strong>Sauter un commit (avec prudence) :</strong> Si un commit particulier cause des problèmes insolubles et que vous décidez qu'il n'est pas essentiel (ou que vous le réintroduirez différemment plus tard), vous pouvez dire à Git de l'ignorer et de continuer :
						<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git rebase --skip">Copier</button>
<code>git rebase --skip</code></pre>
						<p><strong>Attention :</strong> Utiliser <code>--skip</code> signifie que les changements de ce commit seront perdus. Utilisez cette option avec une extrême prudence.</p>
					</li>
				</ul>
				<h4>Stratégies de résolution automatique (<code>-Xours</code> ou <code>-Xtheirs</code>)</h4>
				<p>
					Lors d'un rebase (ou d'un merge), vous pouvez indiquer à Git une stratégie pour résoudre automatiquement les conflits en privilégiant "votre" version (<code>ours</code>, c'est-à-dire les changements de la branche que vous rebasez) ou "leur" version (<code>theirs</code>, c'est-à-dire les changements de la branche sur laquelle vous rebasez).
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande de rebase avec stratégie de résolution">Copier</button>
<code># Pendant un rebase, si des conflits surviennent sur un commit,
# et que vous voulez automatiquement accepter les changements de la branche de base (main) :
git checkout --theirs chemin/vers/le/fichier_en_conflit.txt
git add chemin/vers/le/fichier_en_conflit.txt
# Puis git rebase --continue

# Ou pour privilégier systématiquement "theirs" lors d'un rebase (risqué si non compris) :
# git rebase -Xtheirs main
# (Cette option est passée à la commande rebase initiale, pas pendant la résolution)</code></pre>
				<p>Ces options sont puissantes mais peuvent masquer des problèmes si elles sont utilisées sans discernement. Il est souvent préférable de résoudre les conflits manuellement pour s'assurer de l'intégrité du code.</p>


				<h3>7.5. Rebase Avancé avec <code>--onto</code></h3>
				<p>
					L'option <code>--onto</code> est l'une des formes les plus flexibles du rebase. Elle vous permet de spécifier explicitement où les commits doivent être déplacés, indépendamment de la position actuelle de HEAD ou de la branche de base implicite.
				</p>
				<p>La syntaxe générale est :</p>
				<code>git rebase --onto &lt;nouvelle_base&gt; &lt;ancienne_base_exclusive&gt; [&lt;branche_ou_commit_a_rebaser_inclusif&gt;]</code>
				<ul>
					<li><code>&lt;nouvelle_base&gt;</code> : Le commit sur lequel les nouveaux commits seront basés.</li>
					<li><code>&lt;ancienne_base_exclusive&gt;</code> : Le commit "jusqu'auquel" (mais non inclus) les commits de la branche d'origine sont ignorés. Les commits qui viennent *après* celui-ci seront ceux rebasés.</li>
					<li><code>&lt;branche_ou_commit_a_rebaser_inclusif&gt;</code> : (Optionnel) Le commit ou la branche jusqu'où (inclus) les commits doivent être pris. Si omis, Git utilise HEAD (le commit actuel de la branche sur laquelle vous êtes).</li>
				</ul>
				<h4>Cas d'usage de <code>--onto</code> :</h4>
				<p><strong>1. Déplacer une série de commits d'une branche à une autre (transplantation) :</strong></p>
				<p>Imaginez la situation suivante :</p>
				<pre>A - B - C - D (main)
     \
      E - F - G (featureA)
           \
            H - I (featureB, basée sur F de featureA)</pre>
				<p>Vous réalisez que <code>featureB</code> (commits H et I) devrait en fait être basée directement sur <code>main</code> (commit D) plutôt que sur <code>featureA</code>. Vous voulez déplacer H et I.</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de git rebase --onto pour transplanter">Copier</button>
<code># Sur la branche featureB (ou en spécifiant featureB à la fin)
git rebase --onto main featureA featureB
# Ou plus précisément, si featureA est sur F et featureB sur I:
# git rebase --onto D F I
# (en utilisant les SHA des commits ou noms de branches/tags)
</code></pre>
				<p>Cela signifie : "Prends les commits de `featureB` qui viennent après `featureA` (donc H et I), et rejoue-les sur `main`."</p>
				<p>L'historique deviendrait :</p>
				<pre>A - B - C - D (main)
     \           \
      \           H' - I' (featureB)
       \
        E - F - G (featureA)</pre>

				<p><strong>2. Réorganiser une branche en excluant des commits du milieu :</strong></p>
				<p>Si votre branche <code>feature</code> a des commits <code>X-Y-Z</code> et vous voulez la rebaser sur `main` mais seulement avec `X` et `Z`, en omettant `Y` :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de git rebase --onto pour exclure">Copier</button>
<code># Supposons que feature est sur Z.
# Pour rebaser X sur main, puis Z sur ce nouveau X' :
# D'abord, rebaser X sur main:
git rebase --onto main Y X  # (Rebase le commit X, qui est après Y (exclu), sur main)
# Cela crée X'. HEAD est maintenant sur X'.
# Ensuite, rebaser Z sur X':
git rebase --onto HEAD X Z # (Rebase le commit Z, qui est après X (exclu), sur HEAD (X'))
</code></pre>
				<p>Cependant, pour ce type d'opération (supprimer un commit du milieu), un <a href="#rebase-interactive">rebase interactif</a> avec l'action <code>drop</code> sur le commit Y est généralement plus simple.</p>
				<p><code>--onto</code> est particulièrement utile lorsque vous avez besoin de "greffer" une séquence de commits d'un endroit à un autre de manière très ciblée, souvent en conjonction avec des SHA de commits spécifiques.</p>


				<h3 id="rebase-golden-rule">7.6. La Règle d'Or du Rebase : Les Dangers et Précautions</h3>
				<p>
					La flexibilité du rebase vient avec une responsabilité majeure, encapsulée dans ce qu'on appelle souvent la **"Règle d'Or du Rebase"** :
				</p>
				<div class="alert alert-danger" role="alert">
					<strong>Ne JAMAIS rebaser des commits qui ont déjà été poussés sur un dépôt partagé et sur lesquels d'autres personnes pourraient avoir basé leur travail.</strong>
				</div>
				<h4>Pourquoi cette règle est-elle si cruciale ?</h4>
				<p>
					Lorsque vous rebasez, vous réécrivez l'historique. Même si les changements de code (le "patch") sont les mêmes, les commits rebasés sont de nouveaux commits avec de nouveaux SHA-1.
				</p>
				<p>Si vous rebasez une branche que d'autres ont déjà clonée ou pullée :</p>
				<ul>
					<li>Leur historique local devient **divergent** par rapport au nouvel historique que vous venez de créer.</li>
					<li>S'ils essaient de puller vos changements rebasés, Git verra deux historiques différents et tentera de les fusionner, créant des doublons de commits et un historique très confus.</li>
					<li>Pour "corriger" cela de votre côté après avoir rebasé une branche poussée, vous seriez obligé d'utiliser <code>git push --force</code> (ou <code>--force-with-lease</code>). Cela écrase l'historique sur le dépôt distant avec votre version réécrite.</li>
					<li>Si vos collaborateurs ont basé leur propre travail sur l'ancien historique (avant votre rebase forcé), ils devront alors eux-mêmes effectuer des opérations complexes (souvent un autre rebase de leur travail sur votre nouvel historique) pour resynchroniser, ce qui est source d'erreurs et de frustration.</li>
				</ul>
				<h4>Quand le rebase est-il sûr et recommandé ?</h4>
				<ul>
					<li><strong>Sur vos commits locaux, non encore poussés :</strong> C'est le cas d'usage principal. Nettoyez votre historique autant que vous le souhaitez avant de le partager.</li>
					<li><strong>Sur une branche de fonctionnalité que vous êtes le seul à utiliser :</strong> Même si elle est poussée sur le distant (par exemple, pour une sauvegarde ou pour une PR pas encore mergée), si personne d'autre ne l'utilise comme base, vous *pouvez* la rebaser (mais vous devrez forcer le push).</li>
					<li><strong>Après communication et accord explicite avec votre équipe :</strong> Dans certains workflows d'équipe, il peut être acceptable de rebaser des branches partagées sous conditions strictes et avec une bonne coordination.</li>
				</ul>
				<h4>Que faire si vous avez rebasé une branche poussée par erreur ?</h4>
				<p>Si vous avez poussé la branche avant le rebase, puis l'avez rebasée et voulez maintenant la pousser à nouveau :</p>
				<ul>
					<li><strong><code>git push --force-with-lease origin nom-de-la-branche</code></strong> : C'est une alternative plus sûre à <code>git push --force</code>. Elle ne forcera la mise à jour que si la branche distante est dans l'état où vous pensez qu'elle est (c'est-à-dire, personne d'autre n'a poussé de nouveaux commits entre-temps). Si quelqu'un d'autre a poussé, le push sera rejeté, vous alertant d'un potentiel problème.</li>
					<li><strong><code>git push --force origin nom-de-la-branche</code></strong> : À utiliser en dernier recours et seulement si vous êtes absolument sûr que personne d'autre n'a pullé l'ancienne version de la branche ou si vous avez coordonné avec eux.</li>
				</ul>
				<p>En résumé, traitez l'historique des branches publiques (comme `main`, `develop`) et des branches de fonctionnalités partagées comme immuable une fois poussé. Réservez le rebase pour votre travail local ou pour des branches dont vous avez le contrôle total.</p>


				<h3>7.7. Se Rétablir d'un Rebase Problématique : <code>git reflog</code> à la Rescousse</h3>
				<p>
					Parfois, un rebase peut mal tourner : vous supprimez accidentellement un commit important, la résolution de conflits introduit des erreurs, ou l'historique devient confus. Heureusement, Git conserve un journal de toutes les positions de HEAD, appelé le **reflog**. C'est votre filet de sécurité.
				</p>
				<p>Pour voir le reflog :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git reflog">Copier</button>
<code>git reflog</code></pre>
				<p>Cela affichera une liste de toutes les opérations qui ont modifié HEAD, y compris les commits, les merges, les resets, et les rebases. Chaque entrée a un identifiant (par exemple, <code>HEAD@{2}</code>) et un SHA de commit.</p>
				<p><strong>Exemple de récupération :</strong></p>
				<p>Supposons que vous venez de terminer un rebase interactif, mais vous réalisez que vous avez fait une erreur. Vous lancez <code>git reflog</code> :</p>
<pre class="language-text">
	<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de sortie de git reflog">Copier</button>
<code>a1b2c3d HEAD@{0}: rebase -i (finish): returning to refs/heads/ma-branche
a1b2c3d HEAD@{1}: rebase -i (squash): Mon commit squashe
e4f5g6h HEAD@{2}: rebase -i (reword): Ancien message avant reword
i7j8k9l HEAD@{3}: rebase -i (start): checkout main
b0c1d2e HEAD@{4}: commit: Mon travail avant le rebase catastrophique
...</code></pre>
				<p>
					Vous pouvez voir l'état avant le début du rebase (par exemple, à <code>HEAD@{4}</code> avec le commit <code>b0c1d2e</code>). Pour revenir à cet état :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git reset --hard pour récupérer via reflog">Copier</button>
<code>git reset --hard HEAD@{4}
# Ou, de manière plus sûre, si vous voulez juste inspecter d'abord :
# git checkout HEAD@{4}
# (cela vous met en mode HEAD détachée, puis vous pouvez créer une nouvelle branche si besoin)</code></pre>
				<p>
					<code>git reset --hard</code> ramènera votre branche et votre répertoire de travail exactement à l'état où ils étaient au commit <code>b0c1d2e</code>. Le reflog est une bouée de sauvetage, mais il est spécifique à votre dépôt local et n'est pas partagé.
				</p>


				<h3>7.8. Rebase vs. Merge : Quelle Stratégie Choisir ?</h3>
				<p>
					Le débat "rebase ou merge ?" est l'un des plus courants dans le monde de Git. Les deux stratégies ont pour but d'intégrer des changements d'une branche à une autre, mais elles le font de manières différentes, avec des implications distinctes pour l'historique de votre projet.
				</p>
				<h4><code>git rebase</code></h4>
				<ul>
					<li><strong>Avantages :</strong>
						<ul>
							<li>Crée un historique linéaire, propre et facile à suivre.</li>
							<li>Évite les commits de merge "inutiles" qui peuvent polluer le log.</li>
							<li>Permet de nettoyer et d'organiser les commits d'une branche de fonctionnalité avant l'intégration.</li>
						</ul>
					</li>
					<li><strong>Inconvénients :</strong>
						<ul>
							<li>Réécrit l'historique (les SHA des commits changent). Dangereux si utilisé sur des branches partagées (voir <a href="#rebase-golden-rule">Règle d'Or</a>).</li>
							<li>Peut rendre plus difficile la compréhension du moment exact où une branche de fonctionnalité a été intégrée, car le contexte du merge est perdu.</li>
							<li>Les conflits doivent être résolus commit par commit, ce qui peut être fastidieux si la branche rebasée est longue et diverge beaucoup.</li>
						</ul>
					</li>
				</ul>

				<h4><code>git merge</code> (typiquement avec <code>--no-ff</code> pour préserver un commit de merge)</h4>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git merge --no-ff">Copier</button>
<code>git checkout main
git merge --no-ff ma-branche-feature</code></pre>
				<ul>
					<li><strong>Avantages :</strong>
						<ul>
							<li>Préserve l'historique exact tel qu'il s'est produit. Chaque intégration de branche est clairement marquée par un commit de merge.</li>
							<li>Est non destructif pour l'historique existant. Les SHA des commits originaux sont conservés.</li>
							<li>Plus simple à comprendre et à utiliser, surtout pour les débutants.</li>
							<li>Les conflits sont résolus une seule fois, au moment du merge.</li>
						</ul>
					</li>
					<li><strong>Inconvénients :</strong>
						<ul>
							<li>Peut rendre l'historique du projet "bruyant" et difficile à lire avec de nombreux commits de merge, surtout sur des projets avec beaucoup de branches et de contributeurs. Le graphe du log peut devenir complexe.</li>
							<li>Sans discipline (par exemple, squasher les commits d'une PR avant de la merger), l'historique principal peut se remplir de petits commits intermédiaires.</li>
						</ul>
					</li>
				</ul>

				<h4>Recommandations Générales et Approches Courantes :</h4>
				<ol>
					<li>
						<strong>Pour le travail local / branches de fonctionnalités personnelles :</strong>
						<ul>
							<li>Utilisez <code>git rebase</code> (et <code>git rebase -i</code>) fréquemment pour garder votre branche à jour avec la branche principale et pour nettoyer votre propre historique de commits avant de le partager.</li>
							<li>Utilisez <code>git pull --rebase</code> pour mettre à jour vos branches locales depuis le distant.</li>
						</ul>
					</li>
					<li>
						<strong>Pour l'intégration dans les branches principales (<code>main</code>, <code>develop</code>) :</strong>
						<ul>
							<li>**Option 1 (Workflow privilégiant le rebase) :** Avant de fusionner une branche de fonctionnalité dans `main`, rebasez-la interactivement pour nettoyer les commits, puis rebasez-la sur la dernière version de `main`. Ensuite, effectuez un fast-forward merge sur `main` (ou un merge simple qui sera fast-forward si possible). Cela maintient `main` complètement linéaire. C'est souvent fait via des Pull/Merge Requests où on demande au contributeur de rebaser sa branche.</li>
							<li>**Option 2 (Workflow privilégiant le merge) :** Fusionnez les branches de fonctionnalités dans `main` en utilisant explicitement <code>git merge --no-ff</code>. Cela crée un commit de merge qui documente l'intégration de la fonctionnalité. L'historique de la branche de fonctionnalité reste intact. C'est la stratégie par défaut de plateformes comme GitHub lors du clic sur "Merge pull request".</li>
							<li>**Option 3 (Workflow "Squash and Merge") :** Lors de l'intégration d'une Pull Request, tous les commits de la branche de fonctionnalité sont "squashés" en un seul commit sur la branche principale. Cela garde l'historique principal très propre (un commit par fonctionnalité/PR) mais perd la granularité de l'historique de la branche de fonctionnalité.</li>
						</ul>
					</li>
					<li>
						<strong>Cohérence d'équipe :</strong> Le plus important est que l'équipe se mette d'accord sur un workflow et s'y tienne. Les deux approches (rebase ou merge pour l'intégration) sont valides et ont leurs adeptes.
					</li>
				</ol>


				<h3>7.9. Options de Rebase Spécifiques</h3>
				<p>Outre les options déjà vues, quelques autres peuvent être utiles dans des cas spécifiques :</p>
				<ul>
					<li>
						<strong><code>--rebase-merges</code> (ou <code>-r</code>) :</strong>
						<p>
							Cette option, disponible dans les versions plus récentes de Git, permet de rebaser une branche qui contient elle-même des commits de merge. Contrairement au rebase standard qui "aplatit" l'historique en ne rejouant que les commits non-merge, <code>--rebase-merges</code> tente de recréer la structure de merge de votre branche par-dessus la nouvelle base. C'est utile si vous avez une branche de fonctionnalité complexe avec des merges intentionnels que vous souhaitez préserver.
						</p>
						<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git rebase --rebase-merges">Copier</button>
<code>git rebase -r main
# ou
git rebase --rebase-merges main</code></pre>
						<p>C'est une alternative plus moderne et souvent plus robuste à l'ancienne option <code>--preserve-merges</code> (maintenant dépréciée).</p>
					</li>
					<li>
						<strong><code>--autostash</code> :</strong>
						<p>Si vous avez des modifications non commitées dans votre répertoire de travail lorsque vous lancez un rebase, Git refusera de démarrer. L'option <code>--autostash</code> va automatiquement créer un stash temporaire de vos modifications, effectuer le rebase, puis réappliquer le stash.</p>
						<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande git rebase --autostash">Copier</button>
<code>git rebase main --autostash</code></pre>
					</li>
				</ul>
				<p>
					La maîtrise de <code>git rebase</code> demande de la pratique et une bonne compréhension de ses implications. Commencez par l'utiliser sur des branches locales et des dépôts de test pour vous familiariser avec son comportement avant de l'appliquer dans des contextes collaboratifs plus complexes.
				</p>

			</section>

			<!-- (8) COMPARAISON & ANALYSE -->
			<section id="comparaison">
				<h2>8. Comparaison & Analyse</h2>
				<p>
					Quelques commandes utiles pour comparer ou analyser l’historique :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git diff                # Voir ce qui a changé avant commit
git diff --staged       # Voir ce qui est prêt à commit
git blame fichier       # Savoir qui a modifié chaque ligne
git bisect start        # Commencer la recherche binaire d’un bug
git bisect bad HEAD
git bisect good <commit_ou_tag>
git log -p              # Voir les changements en détail par commit
</code>
</pre>
			</section>

			<!-- (9) ANNULER/COMMITS -->
			<section id="annuler">
				<h2>9. Annuler ou corriger des commits</h2>
				<h3>Revert</h3>
				<p>
					Crée un commit inverse pour annuler un commit précédent :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git revert <commit_hash></code>
</pre>

				<h3>Reset</h3>
				<p>
					Reculer dans l’historique, avec la possibilité de garder ou non les changements :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
# Garde les modifs mais enlève le commit
git reset --soft HEAD~1

# Efface complètement les modifs du dernier commit
git reset --hard HEAD~1</code>
</pre>

				<h3>Amend</h3>
				<p>
					Pour modifier le dernier commit (changer son message ou ajouter un fichier oublié) :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git commit --amend</code>
</pre>
			</section>

			<!-- (10) STASH -->
			<section id="stash">
				<h2>10. Stash : mettre de côté des modifs</h2>
				<p>
					On peut sauvegarder temporairement son travail sans faire de commit final :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git stash
git stash list
git stash pop
git stash apply</code>
</pre>
			</section>

			<!-- (11) DISTANTS & COLLAB -->
			<section id="depots-distants">
				<h2>11. Dépôts Distants & Collaboration</h2>
				<p>
					Quelques commandes pour synchroniser avec un serveur (GitHub, GitLab…) :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git fetch
git pull
git push
git push -u origin branche</code>
</pre>
				<p>
					<strong>Fork & Pull Request :</strong> sur GitHub, vous pouvez forker un repo, faire vos modifs,
					puis ouvrir une Pull Request pour proposer vos changements au projet d’origine.
				</p>
			</section>

			<!-- (12) TAGS -->
			<section id="tags">
				<h2>12. Gestion des tags</h2>
				<p>
					Les tags servent souvent à marquer des versions (v1.0, v2.0…).
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git tag
git tag -a v1.0 -m "Version stable"
git push origin --tags</code>
</pre>
			</section>

			<!-- (13) SUBMODULES -->
			<section id="submodules">
				<h2>13. Submodules (Sous-modules)</h2>
				<p>
					On peut inclure un autre dépôt Git à l’intérieur du nôtre (ex: librairie partagée).
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git submodule add <URL>
git submodule init
git submodule update</code>
</pre>
			</section>

			<!-- (14) AVANCEES & UTILITAIRES -->
			<section id="avancees">
				<h2>14. Commandes avancées & utilitaires</h2>
				<p>
					Voici quelques commandes plus “spéciales” :
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git cherry-pick <commit>      # Prendre un commit précis d’une autre branche
git reflog                  # Historique caché de toutes les actions
git gc                      # Nettoyer et compresser le repo
git archive --format=zip HEAD > code.zip  # Exporter le code sans l'historique
git shortlog               # Liste des commits regroupés par auteur
</code>
</pre>
			</section>

			<!-- (15) BONNES PRATIQUES -->
			<section id="bonnes-pratiques">
				<h2>15. Bonnes pratiques</h2>
				<ol>
					<li>Commits fréquents & atomiques (petites étapes faciles à comprendre).</li>
					<li>Messages de commit clairs (expliquez “pourquoi” et pas juste “ce qui a changé”).</li>
					<li>Utiliser des branches descriptives (ex: <code>feature/login</code>, <code>fix/bug-42</code>).
					</li>
					<li>Revue de code via Pull Requests (pour un avis extérieur, moins de bugs). </li>
					<li>Éviter de réécrire l’historique partagé (risque de casser le repo de l’équipe). </li>
					<li>Maintenir un <code>.gitignore</code> (exclure fichiers inutiles, logs, etc.). </li>
				</ol>
			</section>

			<!-- (16) COMMANDES AVANCÉES DE GIT -->
			<section id="commandes-avancees-git">
				<h2>16. Les Commandes Avancées de Git</h2>
				<p>
					Git propose de nombreuses commandes avancées permettant de gérer finement l’historique du dépôt, de résoudre des problèmes complexes ou d’automatiser certaines tâches. Voici quelques-unes de ces commandes avec leurs explications détaillées :
				</p>

				<h3>1. Git Rebase</h3>
				<p>
					<strong>Description :</strong> La commande <code>git rebase</code> est un outil puissant pour réécrire l'historique des commits, permettant de créer un historique plus linéaire et propre. Elle déplace ou réapplique une série de commits sur une nouvelle base.
				</p>
				<p>
					Pour une explication détaillée, des exemples concrets, les cas d'usage (rebase simple, interactif, <code>--onto</code>), la gestion des conflits, les dangers à éviter (la "Règle d'Or"), et la comparaison avec <code>git merge</code>, veuillez vous référer à la <a href="#rebase">Section 7 : Rebase (Réécriture de l’historique)</a>.
				</p>

				<h3>2. Git Cherry-pick</h3>
				<p>
					<strong>Description :</strong> <code>git cherry-pick</code> permet d’extraire un ou plusieurs commits spécifiques depuis une autre branche et de les appliquer sur la branche courante.
				</p>
				<p><strong>Utilisation typique :</strong> Par exemple, pour appliquer une correction critique directement sur la branche de production :</p>
				<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git checkout production
git cherry-pick &lt;commit_hash&gt;
</code>
  </pre>

				<h3>3. Git Bisect</h3>
				<p>
					<strong>Description :</strong> <code>git bisect</code> est un outil de recherche dichotomique qui aide à identifier le commit précis ayant introduit un bug ou une régression.
				</p>
				<p><strong>Processus :</strong></p>
				<ol>
					<li>
						Démarrer la recherche :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git bisect start
</code>
      </pre>
					</li>
					<li>
						Marquer le commit avec le bug :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git bisect bad
</code>
      </pre>
					</li>
					<li>
						Marquer un commit fonctionnel :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git bisect good &lt;commit_hash&gt;
</code>
      </pre>
					</li>
					<li>
						Une fois identifié, réinitialiser le bisect :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git bisect reset
</code>
      </pre>
					</li>
				</ol>
				<p><em>Astuce :</em> Vous pouvez automatiser ce processus en créant un script de test retournant 0 en cas de succès et 1 en cas d’échec.</p>

				<h3>4. Git Stash</h3>
				<p>
					<strong>Description :</strong> La commande <code>git stash</code> sauvegarde temporairement des modifications non committées, permettant de nettoyer l’espace de travail sans perdre votre travail en cours.
				</p>
				<ul>
					<li>
						Sauvegarder avec un message :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git stash save "Travail en cours sur feature X"
</code>
      </pre>
					</li>
					<li>
						Lister les stashes :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git stash list
</code>
      </pre>
					</li>
					<li>
						Appliquer ou supprimer un stash spécifique :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git stash apply stash@{2}
git stash drop stash@{2}
</code>
      </pre>
					</li>
				</ul>

				<h3>5. Git Reflog</h3>
				<p>
					<strong>Description :</strong> <code>git reflog</code> conserve l’historique des déplacements de <code>HEAD</code>, permettant de retrouver des commits "perdus" ou de revenir à un état antérieur.
				</p>
				<p><strong>Utilisation :</strong></p>
				<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git reflog
</code>
  </pre>
				<p>Pour revenir à un commit précis, par exemple :</p>
				<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git reset --hard HEAD@{3}
</code>
  </pre>

				<h3>6. Git Reset</h3>
				<p>
					<strong>Description :</strong> <code>git reset</code> modifie la position de <code>HEAD</code> et, selon l’option choisie, peut modifier l’index et le répertoire de travail.
				</p>
				<ul>
					<li>
						<em>Soft (--soft) :</em> Déplace <code>HEAD</code> sans modifier l’index ni le répertoire de travail :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git reset --soft &lt;commit_hash&gt;
</code>
      </pre>
					</li>
					<li>
						<em>Mixed (par défaut) :</em> Réinitialise l’index sans toucher au répertoire de travail :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git reset &lt;commit_hash&gt;
</code>
      </pre>
					</li>
					<li>
						<em>Hard (--hard) :</em> Réinitialise <code>HEAD</code>, l’index et le répertoire de travail, supprimant toutes les modifications non committées :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git reset --hard &lt;commit_hash&gt;
</code>
      </pre>
					</li>
				</ul>
				<p><em>Conseil :</em> Utilisez <code>--hard</code> avec précaution, surtout sur des branches partagées.</p>

				<h3>7. Git Clean</h3>
				<p>
					<strong>Description :</strong> <code>git clean</code> supprime les fichiers non suivis dans le répertoire de travail, permettant de nettoyer votre environnement.
				</p>
				<ul>
					<li>
						Voir ce qui sera supprimé (mode test) :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git clean -n
</code>
      </pre>
					</li>
					<li>
						Supprimer les fichiers non suivis :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git clean -f
</code>
      </pre>
					</li>
					<li>
						Supprimer également les répertoires non suivis :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git clean -fd
</code>
      </pre>
					</li>
				</ul>
				<p><em>Astuce :</em> Utilisez toujours l’option <code>-n</code> pour une simulation avant de supprimer définitivement.</p>

				<h3>8. Git Filter-branch et Git Filter-repo</h3>
				<p>
					<strong>Description :</strong> Ces commandes permettent de réécrire l’historique complet du dépôt, ce qui est utile pour supprimer des fichiers sensibles ou nettoyer l’historique.
				</p>
				<ul>
					<li>
						<em>git filter-branch :</em> Bien que puissant, il peut être lent et complexe pour de gros dépôts.
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch chemin/du/fichier' --prune-empty --tag-name-filter cat -- --all
</code>
      </pre>
					</li>
					<li>
						<em>git filter-repo :</em> Une alternative moderne et performante. Exemple pour supprimer un fichier de l’historique :
						<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git filter-repo --path chemin/du/fichier --invert-paths
</code>
      </pre>
						<p><em>Astuce :</em> Sauvegardez toujours votre dépôt avant d’effectuer une réécriture historique.</p>
					</li>
				</ul>

				<h3>9. Git Submodule</h3>
				<p>
					<strong>Description :</strong> La commande <code>git submodule</code> permet d’intégrer et de gérer un dépôt Git externe au sein d’un projet, ce qui est utile pour gérer des dépendances ou bibliothèques de manière autonome.
				</p>
				<p><strong>Utilisation typique :</strong></p>
				<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git submodule add &lt;URL_du_dépôt&gt; chemin/destination
git submodule update --init --recursive
</code>
  </pre>

				<h3>10. Git Worktree</h3>
				<p>
					<strong>Description :</strong> La commande <code>git worktree</code> permet de travailler simultanément sur plusieurs branches dans des répertoires distincts sans avoir à cloner le dépôt plusieurs fois.
				</p>
				<p><strong>Utilisation :</strong> Pour créer un nouveau worktree pour une branche :</p>
				<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git worktree add ../chemin/vers/nouveau_worktree featureX
</code>
  </pre>
				<p>
					<em>Avantages :</em> Tester ou développer sur une branche tout en gardant la branche principale intacte. Idéal pour des tests, builds ou débogages sur des versions parallèles.<br />
					<em>Conseil :</em> Pour revenir à la gestion normale, supprimez le worktree avec :
				</p>
				<pre class="language-bash">
  <button class="btn btn-light copy-btn">Copier</button>
<code>
git worktree remove ../chemin/vers/nouveau_worktree
</code>
  </pre>

				<h3>Conclusion</h3>
				<p>
					Ces commandes avancées offrent une flexibilité considérable pour gérer l’historique, résoudre des problèmes complexes et optimiser votre flux de travail. Leur maîtrise vous permet de :
				</p>
				<ul>
					<li><strong>Gérer des workflows complexes :</strong> Adaptez l’historique avec <code>rebase</code>, <code>cherry-pick</code> et <code>reset</code>.</li>
					<li><strong>Identifier et corriger des erreurs :</strong> Utilisez <code>bisect</code> et <code>reflog</code> pour retrouver des commits problématiques.</li>
					<li><strong>Optimiser l’environnement de développement :</strong> Grâce à <code>stash</code>, <code>clean</code>, <code>submodule</code> et <code>worktree</code> pour maintenir un espace de travail organisé.</li>
				</ul>
				<p>
					En pratiquant ces commandes sur des dépôts de test, vous gagnerez en confiance et serez mieux préparé pour gérer des projets complexes.
				</p>
			</section>


			<!-- TABLEAU COMPLET DES COMMANDES -->
			<section id="tableau-commands">
				<div class="table-responsive mt-3">
					<h2>Tableau complet des commandes Git</h2>
					<p>Retrouvez ci-dessous un récapitulatif complet :</p>
					<div class="table-responsive mt-3">
						<table class="table table-bordered table-hover align-middle">
							<thead class="table-dark">
								<tr>
									<th>Commande</th>
									<th>Utilisation</th>
									<th>Explication</th>
									<th>Avantage ✅</th>
									<th>Inconvénient 🚨</th>
								</tr>
							</thead>
							<tbody>
								<!-- Liste COMPLETE (non tronquée) -->
								<tr>
									<td><strong>git init</strong></td>
									<td><code>git init</code></td>
									<td>Initialise un nouveau dépôt Git (création du dossier <code>.git/</code>).</td>
									<td>Démarrer facilement un nouveau projet.</td>
									<td>Crée un dépôt vide (peut nécessiter config/dépôt distant).</td>
								</tr>
								<tr>
									<td><strong>git clone</strong></td>
									<td><code>git clone URL [dossier]</code></td>
									<td>Copie un dépôt distant (ou local) dans un nouveau dossier.</td>
									<td>Récupération rapide d’un projet existant et de son historique.</td>
									<td>Peut être volumineux si le repo est très gros.</td>
								</tr>
								<tr>
									<td><strong>git remote add</strong></td>
									<td><code>git remote add &lt;nom&gt; &lt;URL&gt;</code></td>
									<td>Associe un dépôt distant (ex: <code>origin</code>) à l’URL spécifiée.</td>
									<td>Permet de pousser/puller vers un dépôt en ligne (GitHub...).</td>
									<td>Erreur possible si l’on se trompe d’URL.</td>
								</tr>
								<tr>
									<td><strong>git remote rename</strong></td>
									<td><code>git remote rename &lt;old&gt; &lt;new&gt;</code></td>
									<td>Renomme un dépôt distant (ex. <code>origin</code> → <code>oldorigin</code>).
									</td>
									<td>Clarifie le nom (en cas de multiples remotes).</td>
									<td>Scripts/CI peuvent être impactés si le nom change.</td>
								</tr>
								<tr>
									<td><strong>git remote remove</strong></td>
									<td><code>git remote remove &lt;nom&gt;</code></td>
									<td>Supprime un dépôt distant de la configuration Git.</td>
									<td>Nettoie la liste des remotes inutiles.</td>
									<td>Plus de push/pull possible vers ce remote si besoin.</td>
								</tr>
								<tr>
									<td><strong>git status</strong></td>
									<td><code>git status</code></td>
									<td>Affiche l’état des fichiers : suivis, non suivis, prêts à être commit, etc.</td>
									<td>Vue rapide et claire des changements.</td>
									<td>Aucun inconvénient majeur.</td>
								</tr>
								<tr>
									<td><strong>git add</strong></td>
									<td><code>git add fichier</code> / <code>git add .</code></td>
									<td>Ajoute des fichiers dans la zone de staging (préparation au commit).</td>
									<td>Contrôle précis sur ce qu’on veut commiter.</td>
									<td>Si on oublie un fichier, il ne sera pas dans le commit.</td>
								</tr>
								<tr>
									<td><strong>git commit</strong></td>
									<td><code>git commit -m "msg"</code></td>
									<td>Crée un instantané (commit) des changements validés.</td>
									<td>Construit l’historique avec un message descriptif.</td>
									<td>Un mauvais message gêne la compréhension de l’historique.</td>
								</tr>
								<tr>
									<td><strong>git commit -am</strong></td>
									<td><code>git commit -am "msg"</code></td>
									<td>Combine l’ajout et le commit pour les fichiers déjà suivis.</td>
									<td>Gain de temps pour modifications rapides.</td>
									<td>Ne gère pas les nouveaux fichiers non suivis.</td>
								</tr>
								<tr>
									<td><strong>git commit --amend</strong></td>
									<td><code>git commit --amend</code></td>
									<td>Modifie le dernier commit (message ou fichiers).</td>
									<td>Corrige un oubli ou un message trop vague.</td>
									<td>Réécrit l’historique, déconseillé si déjà poussé.</td>
								</tr>
								<tr>
									<td><strong>git log</strong></td>
									<td><code>git log</code>, <code>git log --oneline</code></td>
									<td>Affiche l’historique des commits (détaillé ou succinct).</td>
									<td>Bonne vision de l’évolution du projet.</td>
									<td>Peut être verbeux sur gros projets.</td>
								</tr>
								<tr>
									<td><strong>git checkout</strong></td>
									<td><code>git checkout &lt;branche&gt;</code> /
										<code>git checkout -- &lt;fichier&gt;</code></td>
									<td>Change de branche OU annule les modifs d’un fichier local.</td>
									<td>Navigation aisée entre branches.</td>
									<td>Perte possible de changements non commit si on oublie de stasher.</td>
								</tr>
								<tr>
									<td><strong>git branch</strong></td>
									<td><code>git branch &lt;nom&gt;</code></td>
									<td>Crée une branche ou liste les branches (si pas d’argument).</td>
									<td>Organise le travail (nouvelles fonctionnalités).</td>
									<td>Trop de branches peuvent créer la confusion.</td>
								</tr>
								<tr>
									<td><strong>git branch -m</strong></td>
									<td><code>git branch -m &lt;ancien&gt; &lt;nouveau&gt;</code></td>
									<td>Renomme une branche locale.</td>
									<td>Corrige un nom mal choisi.</td>
									<td>Peut troubler d’autres si la branche est partagée.</td>
								</tr>
								<tr>
									<td><strong>git branch -d</strong></td>
									<td><code>git branch -d &lt;nom&gt;</code></td>
									<td>Supprime une branche locale (fusionnée).</td>
									<td>Nettoyage des branches terminées.</td>
									<td>Impossible si non fusionnée (risque de perte).</td>
								</tr>
								<tr>
									<td><strong>git branch -D</strong></td>
									<td><code>git branch -D &lt;nom&gt;</code></td>
									<td>Supprime une branche locale sans vérification.</td>
									<td>Forcer la suppression d’une branche obsolète.</td>
									<td>Risque de perte définitive de commits.</td>
								</tr>
								<tr>
									<td><strong>git merge</strong></td>
									<td><code>git merge &lt;branche&gt;</code></td>
									<td>Fusionne la branche spécifiée dans la branche courante.</td>
									<td>Combine facilement plusieurs flux de travail.</td>
									<td>Peut générer des conflits, crée un commit de merge.</td>
								</tr>
								<tr>
									<td><strong>git merge --no-ff</strong></td>
									<td><code>git merge --no-ff &lt;branche&gt;</code></td>
									<td>Fusion sans fast-forward, garde un commit de merge dédié.</td>
									<td>Historique plus lisible (commit de merge conservé).</td>
									<td>Même si un fast-forward était possible, on force un commit supplémentaire.</td>
								</tr>
								<tr>
									<td><strong>git rebase</strong></td>
									<td><code>git rebase &lt;branche&gt;</code></td>
									<td>“Rejoue” les commits de la branche courante sur une autre branche.</td>
									<td>Historique linéaire et propre (pas de commit de merge).</td>
									<td>Réécrit l’historique (dangereux si partagé).</td>
								</tr>
								<tr>
									<td><strong>git rebase -i</strong></td>
									<td><code>git rebase -i HEAD~n</code></td>
									<td>Rebase interactif (modifier l’ordre, fusionner, renommer des commits).</td>
									<td>Historique très propre, possibilité de “squasher”.</td>
									<td>Complexe, risque de collisions ou pertes.</td>
								</tr>
								<tr>
									<td><strong>git rebase --continue</strong></td>
									<td><code>git rebase --continue</code></td>
									<td>Poursuit le rebase après résolution de conflit.</td>
									<td>Finalise le rebase proprement.</td>
									<td>Faut résoudre tous les conflits un par un.</td>
								</tr>
								<tr>
									<td><strong>git rebase --abort</strong></td>
									<td><code>git rebase --abort</code></td>
									<td>Annule le rebase en cours et revient à l’état initial.</td>
									<td>Utile si trop de conflits.</td>
									<td>Annule tout le travail du rebase.</td>
								</tr>
								<tr>
									<td><strong>git diff</strong></td>
									<td><code>git diff</code>, <code>git diff --staged</code></td>
									<td>Compare les différences non validées ou indexées.</td>
									<td>Repère précisément les lignes modifiées.</td>
									<td>Peut être long à lire sur gros projets.</td>
								</tr>
								<tr>
									<td><strong>git blame</strong></td>
									<td><code>git blame &lt;fichier&gt;</code></td>
									<td>Montre, ligne par ligne, qui a modifié le fichier et quand.</td>
									<td>Pratique pour attribuer un changement précis.</td>
									<td>Peu lisible si gros fichier avec multiples auteurs.</td>
								</tr>
								<tr>
									<td><strong>git bisect</strong></td>
									<td><code>git bisect start</code>, <code>git bisect bad</code>,
										<code>git bisect good</code></td>
									<td>Recherche binaire d’un commit fautif.</td>
									<td>Méthode puissante pour isoler un bug.</td>
									<td>Processus parfois long.</td>
								</tr>
								<tr>
									<td><strong>git revert</strong></td>
									<td><code>git revert &lt;commit&gt;</code></td>
									<td>Crée un commit annulant un autre commit.</td>
									<td>Historique conservé sans tout écraser.</td>
									<td>Peut allonger l’historique si nombreux revert.</td>
								</tr>
								<tr>
									<td><strong>git reset --soft</strong></td>
									<td><code>git reset --soft HEAD~1</code></td>
									<td>Reculer un commit en gardant les modifications dans le staging.</td>
									<td>Permet de refaire un commit propre.</td>
									<td>Réécrit l’historique (dangereux si déjà poussé).</td>
								</tr>
								<tr>
									<td><strong>git reset --hard</strong></td>
									<td><code>git reset --hard HEAD~1</code></td>
									<td>Reculer un commit en supprimant définitivement les modifs.</td>
									<td>Retour rapide à un état stable.</td>
									<td>Perte irréversible des changements.</td>
								</tr>
								<tr>
									<td><strong>git stash</strong></td>
									<td><code>git stash</code></td>
									<td>Met de côté les modifs non commitées.</td>
									<td>Utile pour passer sur une autre branche sans perdre son travail.</td>
									<td>On peut oublier les stash si on ne les liste pas.</td>
								</tr>
								<tr>
									<td><strong>git stash pop</strong></td>
									<td><code>git stash pop</code></td>
									<td>Récupère et supprime le dernier stash.</td>
									<td>Permet de reprendre rapidement son travail mis en attente.</td>
									<td>Conflits possibles si code très différent entre-temps.</td>
								</tr>
								<tr>
									<td><strong>git stash apply</strong></td>
									<td><code>git stash apply [stash@{n}]</code></td>
									<td>Applique un stash (sans le supprimer).</td>
									<td>Peut réutiliser plusieurs fois le même stash.</td>
									<td>Attention aux duplications si on l’applique plusieurs fois.</td>
								</tr>
								<tr>
									<td><strong>git stash list</strong></td>
									<td><code>git stash list</code></td>
									<td>Affiche la liste de tous les stashes mis de côté.</td>
									<td>Visualise rapidement les réserves de code.</td>
									<td>Pas d’inconvénient notable.</td>
								</tr>
								<tr>
									<td><strong>git fetch</strong></td>
									<td><code>git fetch [remote] [branche]</code></td>
									<td>Récupère les nouveautés sans les fusionner.</td>
									<td>Voir ce qui a changé avant d’intégrer.</td>
									<td>Étape supplémentaire (pull ou merge) pour la fusion finale.</td>
								</tr>
								<tr>
									<td><strong>git pull</strong></td>
									<td><code>git pull</code></td>
									<td>Récupère et fusionne directement les modifications du dépôt distant.</td>
									<td>Simple pour rester à jour.</td>
									<td>Peut engendrer des conflits si modifs simultanées.</td>
								</tr>
								<tr>
									<td><strong>git push</strong></td>
									<td><code>git push</code></td>
									<td>Envoie les commits locaux vers la branche distante.</td>
									<td>Partage facile avec l’équipe.</td>
									<td>Conflits possibles si historique local en retard.</td>
								</tr>
								<tr>
									<td><strong>git push -u</strong></td>
									<td><code>git push -u origin &lt;branche&gt;</code></td>
									<td>Pousse la branche locale et la configure avec le dépôt distant.</td>
									<td>Simplifie les futurs push/pull.</td>
									<td>Peut créer plusieurs branches distantes si mal utilisé.</td>
								</tr>
								<tr>
									<td><strong>git push --force</strong></td>
									<td><code>git push --force</code> ou <code>git push --force-with-lease</code></td>
									<td>Force la réécriture de l’historique distant.</td>
									<td>Utile après un rebase ou amend déjà poussé.</td>
									<td>Risque de perdre le travail d’autres contributeurs.</td>
								</tr>
								<tr>
									<td><strong>git tag</strong></td>
									<td><code>git tag &lt;nom&gt;</code></td>
									<td>Crée un tag léger (non annoté) sur le commit courant.</td>
									<td>Identifier rapidement une version.</td>
									<td>Pas de message ni métadonnées.</td>
								</tr>
								<tr>
									<td><strong>git tag -a</strong></td>
									<td><code>git tag -a v1.0 -m "message"</code></td>
									<td>Crée un tag annoté (avec message).</td>
									<td>Historique complet sur la version (auteur, date, message).</td>
									<td>Trop de tags peut devenir confus.</td>
								</tr>
								<tr>
									<td><strong>git push origin --tags</strong></td>
									<td><code>git push origin --tags</code></td>
									<td>Envoie tous les tags locaux vers le dépôt distant.</td>
									<td>Partage public des différentes versions marquées.</td>
									<td>Peut pousser des tags créés par erreur.</td>
								</tr>
								<tr>
									<td><strong>git submodule add</strong></td>
									<td><code>git submodule add &lt;URL&gt;</code></td>
									<td>Ajoute un dépôt Git comme sous-module dans le projet.</td>
									<td>Gère plusieurs projets dans un seul repo principal.</td>
									<td>Gestion parfois complexe si sous-modules changent souvent.</td>
								</tr>
								<tr>
									<td><strong>git submodule init</strong></td>
									<td><code>git submodule init</code></td>
									<td>Initialise les sous-modules d’un projet déjà cloné.</td>
									<td>Indispensable après un clone contenant des submodules.</td>
									<td>Étape supplémentaire qui peut être oubliée.</td>
								</tr>
								<tr>
									<td><strong>git submodule update</strong></td>
									<td><code>git submodule update</code></td>
									<td>Met à jour les sous-modules à la version indiquée dans le repo principal.</td>
									<td>Garde les sous-modules cohérents avec la référence choisie.</td>
									<td>Parfois besoin de <code>--recursive</code> (sous-sous-modules).</td>
								</tr>
								<tr>
									<td><strong>git clone --recurse-submodules</strong></td>
									<td><code>git clone --recurse-submodules &lt;URL&gt;</code></td>
									<td>Clone un projet et initialise les sous-modules en une seule commande.</td>
									<td>Pratique pour un projet multi-modules complet.</td>
									<td>Sinon il faut <code>init</code> et <code>update</code> manuellement.</td>
								</tr>
								<tr>
									<td><strong>git cherry-pick</strong></td>
									<td><code>git cherry-pick &lt;commit&gt;</code></td>
									<td>Copie un commit précis (d’une autre branche) dans la branche courante.</td>
									<td>Importe une correction ou fonctionnalité sans fusionner toute la branche.</td>
									<td>Conflits possibles si dépendances entre commits.</td>
								</tr>
								<tr>
									<td><strong>git reflog</strong></td>
									<td><code>git reflog</code></td>
									<td>Historique détaillé des actions (commits, checkout...) même effacées du log.
									</td>
									<td>Permet de récupérer un commit perdu.</td>
									<td>Lecture parfois confuse pour les débutants.</td>
								</tr>
								<tr>
									<td><strong>git gc</strong></td>
									<td><code>git gc</code></td>
									<td>Nettoie/optimise la base de données Git (compression, purge objets obsolètes).
									</td>
									<td>Réduit la taille du repo, améliore la performance.</td>
									<td>À utiliser avec précaution (peut effacer définitivement certains objets).</td>
								</tr>
								<tr>
									<td><strong>git archive</strong></td>
									<td><code>git archive --format=zip HEAD &gt; code.zip</code></td>
									<td>Crée une archive du contenu (sans l’historique complet).</td>
									<td>Utile pour exporter une version rapidement.</td>
									<td>Aucun suivi de l’historique dans l’archive.</td>
								</tr>
								<tr>
									<td><strong>git shortlog</strong></td>
									<td><code>git shortlog</code></td>
									<td>Résumé des commits groupés par auteur.</td>
									<td>Vision rapide de la contribution de chacun.</td>
									<td>Manque de détails sur les changements eux-mêmes.</td>
								</tr>
							</tbody>
						</table>
					</div>
					<p><strong>Remarques :</strong></p>
					<ul>
						<li>Certaines commandes ont des variantes (ex. <code>-m</code>, <code>-p</code>,
							<code>--stat</code>).</li>
						<li>Les avantages/inconvénients dépendent du contexte (projet solo/équipe, etc.).</li>
					</ul>
			</section>

			<!-- EXEMPLES CONCRETS -->
			<section id="exemples">
				<h2>Exemples Concrets</h2>
				<h4>1. Annuler le dernier commit en gardant les modifs</h4>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git reset --soft HEAD~1
# Les fichiers restent modifiés
</code>
</pre>

				<h4>2. Rebaser sa branche sur main</h4>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
git checkout ma-branche
git pull origin main
git rebase main
</code>
</pre>
			</section>

			<!-- EXERCICES & PIEGES -->
			<section id="exercices-pieges">
				<h2>Exercices & pièges courants</h2>
				<h3>Exercices pratiques</h3>
				<ul>
					<li><strong>Exercice 1 :</strong> Créer un dépôt local, y faire deux commits et pousser sur GitHub.
					</li>
					<li><strong>Exercice 2 :</strong> Créer une branche, y faire une modif, provoquer un conflit et le
						résoudre.</li>
					<li><strong>Exercice 3 :</strong> Faire un stash avant de changer de branche, puis le récupérer.
					</li>
				</ul>

				<h3>Pièges courants à éviter</h3>
				<ul>
					<li><strong>Forcer un push</strong> : <code>git push --force</code> sans précaution risque d’écraser
						le travail d’autrui.</li>
					<li><strong>Réécrire l’historique partagé</strong> : rebase ou reset sur une branche déjà utilisée
						par d’autres.</li>
					<li><strong>Oublier stash</strong> : si on change de branche sans stasher, on peut perdre ses
						modifs.</li>
					<li><strong>Merge mal résolu</strong> : bien faire <code>git add</code> et <code>git commit</code>
						après le conflit.</li>
				</ul>
			</section>

			<!-- CONVENTIONS DE COMMIT -->
			<section id="commit-conventions">
				<h2>Conventions Commit</h2>
				<p>
					Parfois on suit des règles pour les messages de commit (ex. <em>Conventional Commits</em>),
					afin de générer des changelogs automatiques, d’avoir une structure claire, etc.
				</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn">Copier</button>
<code>
feat: ajout fonctionnalité
fix: correction bug
docs: mise à jour doc
</code>
	</pre>
			</section>

			<!-- CI/CD GITHUB ACTIONS -->
			<section id="github-actions">
				<h2>CI/CD (GitHub Actions)</h2>
				<p>
					Pour automatiser des tests ou un déploiement, on peut créer un fichier
					<code>.github/workflows/ci.yml</code> comme ceci :
				</p>
				<pre class="language-yaml">
			  <button class="btn btn-light copy-btn">Copier</button>
<code>
name: CI

on:
	push:
	branches: [ "main" ]
	pull_request:
	branches: [ "main" ]

jobs:
	build:
	runs-on: ubuntu-latest
	steps:
		- uses: actions/checkout@v2
		- name: Installer dépendances
		run: npm install
		- name: Lancer les tests
		run: npm test
</code>
	</pre>
			</section>

			<!-- GLOSSAIRE GIT -->
			<section id="glossaire">
				<h2>Glossaire Git</h2>
				<ul>
					<li><strong>stash</strong> : mettre de côté des modifications non commit (temporaire).</li>
					<li><strong>rebase</strong> : rejouer des commits sur une autre base pour un historique plus
						linéaire.</li>
					<li><strong>fetch</strong> : télécharger les changements distants sans les fusionner (juste les
						voir).</li>
					<li><strong>fork</strong> : copier un dépôt (souvent sur GitHub) dans son espace perso.</li>
					<li><strong>cherry-pick</strong> : prendre un commit précis d’une autre branche et l’ajouter à la
						nôtre.</li>
					<li><strong>tag</strong> : étiquette (nom) sur un commit (souvent pour marquer une version stable).
					</li>
				</ul>
			</section>

			<!-- CONCLUSION -->
			<section id="conclusion">
				<h2>Conclusion</h2>
				<p>
					Vous avez vu ici toutes les bases de Git, plus des parties avancées (rebase, stash, etc.).
					Entraînez-vous régulièrement pour retenir les commandes.
				</p>
				<p>
					Git est très puissant et utile quand on travaille à plusieurs ou qu’on veut garder une trace
					de chaque changement dans son projet.
				</p>
				<p><strong>Bonne pratique de Git et bon code !</strong></p>

			</section>

		</div><!-- Fin .container -->
	</div><!-- Fin .contentWithToc -->

	<footer>
		<div class="container">
			<p class="m-0">Cours réalisé par <strong>G.G. Paterne</strong> - Tous droits réservés</p>
		</div>
	</footer>

	<!-- Bouton Scroll to Top -->
	<button type="button" class="btn btn-danger btn-floating" id="btnScrollTop" data-mdb-ripple-color="light" aria-label="Retourner en haut de la page">
		↑
	</button>

	<!-- Visually hidden span for screen reader announcements -->
	<span class="visually-hidden" id="sr-feedback" aria-live="polite" aria-atomic="true"></span>

	<!-- MDB JavaScript -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/8.1.0/mdb.min.js">
	</script>

	<!-- Prism.js pour coloration syntaxique -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js">
	</script>
	<!-- Custom JavaScript -->
	<script src="script.js"></script>
</body>

</html>