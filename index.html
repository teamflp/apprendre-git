<!DOCTYPE html>
<html lang="fr">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="author" content="G.G. Paterne" />
	<meta name="description" content="Cours complet Git avec fonctionnalit√©s avanc√©es">
	<title>Cours Complet Git - G.G. Paterne</title>

	<!-- MDB CSS (Material Design for Bootstrap) -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/8.1.0/mdb.min.css" />
	<!-- Prism.js CSS pour coloration syntaxique -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
	<!-- Font Awesome (ic√¥nes) -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" />
	<!-- Custom CSS -->
	<link rel="stylesheet" href="styles.css" />
</head>

<body>

	<!-- Barre de progression -->
	<div id="readingProgress"></div>

	<!-- Barre top mobile -->
	<nav class="navbar navbar-light bg-light d-md-none" id="menuTopBar">
		<div class="container-fluid">
			<!-- Titre / Logo -->
			<span class="navbar-brand fw-bold">Cours Git</span>

			<!-- Bouton Hamburger -->
			<button class="navbar-toggler" type="button" id="hamburgerBtn" style="border:none; background:none;">
				<i class="fas fa-bars"></i>
			</button>
		</div>
	</nav>

	<!-- Menu Table des Mati√®res (Responsive) -->
	<nav id="navbarTOC">
		<h5>Table des Mati√®res</h5>
		<a href="#introduction">1. Introduction</a>
		<a href="#installation">2. Installation & Config</a>
		<a href="#depots">3. D√©p√¥ts</a>
		<a href="#modifications">4. Suivi & Commit</a>
		<a href="#branches">5. Branches</a>
		<a href="#fusion">6. Merge & Conflits</a>
		<a href="#rebase">7. Rebase</a>
		<a href="#comparaison">8. Comparaison & Analyse</a>
		<a href="#annuler">9. Annuler/Commits</a>
		<a href="#stash">10. Stash</a>
		<a href="#depots-distants">11. Distants & Collab</a>
		<a href="#tags">12. Tags</a>
		<a href="#submodules">13. Submodules</a>
		<a href="#avancees">14. Avanc√©es & Utilitaires</a>
		<a href="#bonnes-pratiques">15. Bonnes Pratiques</a>
		<a href="#commandes-avancees-git">16. Commandes Avanc√©es de Git</a>
		<a href="#tableau-commands">17. Tableau Complet</a>
		<a href="#exemples">18. Exemples Concrets</a>
		<a href="#exercices-pieges">19. Exercices & Pi√®ges</a>
		<a href="#commit-conventions">20. Conventions Commit</a>
		<a href="#github-actions">21. CI/CD GitHub</a>
		<a href="#glossaire">22. Glossaire Git</a>
		<a href="#conclusion">23. Conclusion</a>
		<a href="#workflows">24. Git Workflows</a>
		<a href="#hooks-git">25. Hooks Git</a>
		<a href="#gitattributes">26. Fins de Ligne & .gitattributes</a>
		<a href="#git-rerere">27. `git rerere`</a>
		<a href="#collaboration-plateformes">28. Collaboration Avanc√©e sur Plateformes</a>

		<hr />
		<button class="btn btn-sm btn-dark" id="toggleDarkMode">Dark Mode</button>
	</nav>


	<!-- Contenu principal (d√©cal√© par rapport au menu) -->
	<div class="contentWithToc">

		<!-- Hero -->
		<div class="hero">
			<div class="container">
				<h1 class="fw-bold">Apprendre √† utiliser les commandes Git</h1>
				<p class="fst-italic">Par <strong>G.G. Paterne</strong></p>
			</div>
		</div>

		<div class="container my-4">

			<!-- Recherche code -->
			<input type="text" class="form-control" id="searchBar" placeholder="Filtrer les snippets de code‚Ä¶" />

			<!-- (1) INTRODUCTION -->
			<section id="introduction" class="mb-4">
				<div class="card shadow-sm">
					<h2 class="card-header text-primary">1. Introduction √† Git</h2>
					<div class="card-body">
						<h3>Qu‚Äôest-ce que Git‚ÄØ?</h3>
						<p>
							Git est un outil (logiciel) pour suivre les changements dans le code.
							Il permet de cr√©er un historique de toutes les modifications.
							On peut aussi travailler √† plusieurs dessus, sans se marcher sur les pieds.
						</p>
						<p><strong>Pourquoi utiliser Git‚ÄØ?</strong></p>
						<ul>
							<li>Revenir √† une version ant√©rieure si on casse quelque chose.</li>
							<li>Travailler √† plusieurs sur le m√™me projet, mais sur diff√©rentes branches.</li>
							<li>Garder un historique de tous les commits (changements).</li>
						</ul>


						<!-- Bouton de t√©l√©chargement -->
						<a href="Apprendre-git-par-la-pratique.pdf" class="btn btn-primary mt-3" download="CoursCompletGit">
							<i class="fas fa-download"></i>T√©l√©charger le cours complet (PDF)
						</a>
					</div>
				</div>
			</section>

			<!-- (2) INSTALLATION & CONFIG -->
			<section id="installation" class="mb-4">
				<div class="card shadow-sm">
					<h2 class="card-header text-primary">2. Installation et configuration</h2>
					<div class="card-body">
						<h3>Installation</h3>
						<p>
							Pour utiliser Git, on doit l‚Äôinstaller sur l‚Äôordinateur.
							Sur Linux Ubuntu/Debian, on peut faire :
						</p>
						<p>
							Sur Windows ou Mac, on peut t√©l√©charger l‚Äôinstalleur sur le site officiel‚ÄØ:
							<a href="https://git-scm.com/download" target="_blank">https://git-scm.com/download</a>
						</p>

					<pre class="language-bash">

				<button class="btn btn-light copy-btn">Copier</button>
	<code>
	sudo apt update
	sudo apt install git
	</code>
	</pre>

				<p>Ces deux commandes mettent √† jour la liste des paquets et installent Git.</p>


				<h3>Configuration globale</h3>
				<p>Donner son nom et email pour que Git sache qui fait les commits :</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git config --global user.name "Votre Nom"
	git config --global user.email "votre.email@example.com"</code>
	</pre>
				<p>On peut choisir son √©diteur pr√©f√©r√©, comme nano ou vim :</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git config --global core.editor "nano"</code>
	</pre>
				<p>
					Cette commande configure nano comme √©diteur par d√©faut.
				</p>
				<p>Pour voir toutes les configs :</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git config --list</code>
	</pre>
					</div>
				</div>
			</section>

			<!-- (3) DEPOTS -->
			<section id="depots" class="mb-4">
				<div class="card shadow-sm">

					<h2 class="card-header text-primary">3. Initialiser et g√©rer un d√©p√¥t</h2>
					<div class="card-body">
						<h3>Initialiser un nouveau d√©p√¥t</h3>
						<p>
							Pour commencer √† suivre un projet avec Git, on fait :
						</p>
						<pre class="language-bash">
						<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git init</code>
	</pre>
				<p>
					Cela cr√©e un dossier cach√© <code>.git</code> qui contient toutes les infos de suivi (commits,
					historique...).
				</p>

				<h3>Cloner un d√©p√¥t existant</h3>
				<p>
					Si un projet existe d√©j√† sur GitHub ou ailleurs, on peut le copier localement :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git clone https://github.com/utilisateur/projet.git</code>
	</pre>
				<p>
					Cela cr√©e un dossier avec tout le code et l‚Äôhistorique.
				</p>

				<h3>Ajouter un d√©p√¥t distant</h3>
				<p>
					Pour lier son dossier local √† un d√©p√¥t en ligne (ex: GitHub), on utilise :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git remote add origin https://github.com/utilisateur/projet.git</code>
	</pre>

				<h3>Lister / Renommer / Supprimer un d√©p√¥t distant</h3>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git remote -v              # Voir les d√©p√¥ts distants
	git remote rename origin old   # Renommer 'origin' en 'old'
	git remote remove origin       # Supprimer le remote 'origin'</code>
	</pre>
					</div>
				</div>
			</section>

			<!-- (4) SUIVI & COMMIT -->
			<section id="modifications" class="mb-4">
				<div class="card shadow-sm">
					<div class="card-body">
						<h2 class="card-header text-primary">4. Suivi et validation des modifications</h2>
						<h3>V√©rifier l'√©tat</h3>
						<p>Pour voir quels fichiers sont modifi√©s ou non suivis :</p>
						<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git status</code>
	</pre>

						<h3>Ajouter des fichiers</h3>
						<p>
							Avant de faire un commit, on doit ajouter les fichiers dans la ‚Äúzone de staging‚Äù :
						</p>
						<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git add fichier.txt
	git add .</code>
	</pre>
						<p>
							Le premier ajoute un seul fichier, le second ajoute tout ce qui est modifi√©/nouveau.
						</p>

						<h3>Cr√©er un commit</h3>
						<p>
							Pour enregistrer d√©finitivement les changements dans l‚Äôhistorique :
						</p>
						<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git commit -m "Description du changement"</code>
	</pre>
						<p>On peut tout faire d‚Äôun coup (pour les fichiers d√©j√† suivis) : <code>git commit -am "message"</code>
						</p>

						<h3>Afficher l‚Äôhistorique</h3>
						<p>Voir la liste de tous les commits d√©j√† faits :</p>
						<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git log
	git log --oneline
	git log --graph --decorate --oneline</code>
	</pre>
					</div>
				</div>
			</section>

			<!-- (5) BRANCHES -->
			<section id="branches" class="mb-4">
				<div class="card shadow-sm">
					<h2 class="card-header text-primary">5. Branches et navigation</h2>
					<div class="card-body">
						<h3>Cr√©er et lister</h3>
						<p>Pour voir ou cr√©er une branche :</p>
						<pre class="language-bash">
						<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git branch
	git branch nouvelle-branche</code>
	</pre>

				<h3>Changer de branche</h3>
				<p>On se d√©place sur une branche existante :</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git checkout nouvelle-branche</code>
	</pre>
				<p>Ou on la cr√©e et on y va d‚Äôun coup :</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git checkout -b nouvelle-branche</code>
	</pre>

				<h3>Renommer / Supprimer une branche</h3>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git branch -m ancien_nom nouveau_nom   # Renommer
	git branch -d branche            # Supprimer une branche fusionn√©e
	git branch -D branche            # Supprimer quand pas fusionn√©e</code>
	</pre>
					</div>
				</div>
			</section>

			<!-- (6) MERGE & CONFLITS -->
			<section id="fusion">
				<h2 class="card-header text-primary">6. Merge (Fusion) et Conflits</h2>
				<h3>Fusionner deux branches</h3>
				<p>
					On se place sur la branche o√π on veut int√©grer les changements (souvent main ou master), puis on
					merge :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git checkout main
	git merge nouvelle-branche</code>
	</pre>

				<h3>Conflits</h3>
				<p>
					S‚Äôil y a des conflits, Git arr√™te le merge et on doit r√©soudre √† la main :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git add fichier_conflit.txt
	git commit -m "R√©solution du conflit"</code>
	</pre>

				<h3>Merge ‚Äúno fast-forward‚Äù</h3>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git merge --no-ff nouvelle-branche</code>
	</pre>
				<p>
					Cr√©e un commit de merge m√™me si on peut faire un fast-forward, pour garder une trace.
				</p>
			</section>

			<!-- (7) REBASE -->
			<section id="rebase">
				<h2 class="card-header text-primary">7. Rebase (R√©√©criture de l‚Äôhistorique)</h2>
				<p>
					La commande <code>git rebase</code> permet de r√©√©crire l'historique du d√©p√¥t en appliquant une s√©rie de commits sur une nouvelle base. Cela permet d'avoir un historique plus lin√©aire et propre, de r√©soudre les conflits de fusion, et de simplifier l'int√©gration des modifications avec d'autres branches. Cela permet d‚Äôobtenir un historique plus <em>lin√©aire</em> et lisible, en √©vitant les commits de fusion inutiles. Elle est particuli√®rement utile pour int√©grer les derni√®res modifications d‚Äôune branche (ex. : <code>main</code>) dans votre branche de d√©veloppement.
					<br><br><strong>Note :</strong> Le rebase modifie l'historique de votre d√©p√¥t, vous devez √™tre sur une branche sans commits non publi√©s pour utiliser le rebase.'
				</p>

				<p>
					<strong>Attention :</strong> N‚Äôeffectuez pas de rebase sur des branches d√©j√† pouss√©es sur un d√©p√¥t partag√©, car cela r√©√©crit l‚Äôhistorique et peut perturber le travail de vos coll√®gues. Il est recommand√© de tester ces op√©rations sur des d√©p√¥ts de test ou des branches locales avant de les utiliser en production.
				</p>

				Voici quelques avantages de rebase :<br>
				<ul>
					<li>Simplifie l'historique : rebase permet de mettre √† jour l'historique en appliquant les modifications sur une nouvelle base, ce qui rend l'historique plus facile √† comprendre et √† analyser.</li>
					<li>R√©sout les conflits : rebase permet de r√©soudre les conflits de fusion en modifiant les fichiers conflictueux et en cr√©ant de nouveaux commits.</li>
					<li>Simplifie l'int√©gration : rebase permet de simplifier l'int√©gration des modifications avec d'autres branches en appliquant les modifications sur une nouvelle base, ce qui facilite la r√©solution des conflits et la fusion des branches.</li>
				</ul>

				<h3>Rebase simple</h3>
				<p>
					Pour mettre √† jour votre branche <code>ma-branche</code> avec les derniers commits de <code>main</code>, ex√©cutez :
				</p>
				<pre class="language-bash">
			<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git checkout ma-branche
	git rebase main
	</code>
		</pre>
				<p>
					<strong>Exemple :</strong> Si vous travaillez sur une branche <code>feature</code> et que des modifications ont √©t√© apport√©es sur <code>main</code>, cette commande permet de r√©appliquer vos commits de <code>feature</code> au-dessus des derniers commits de <code>main</code>.
				</p>

				<h3>Gestion des conflits lors d'un rebase</h3>
				<p>
					Si des conflits surviennent pendant le rebase, Git interrompt l‚Äôop√©ration pour que vous puissiez les r√©soudre. La proc√©dure est la suivante :
				</p>
				<ul>
					<li>
						<strong>Identifier et r√©soudre le conflit :</strong> Ouvrez le(s) fichier(s) concern√©(s) et modifiez les sections marqu√©es par <code>&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code> et <code>&gt;&gt;&gt;&gt;&gt;&gt;</code> pour choisir le contenu appropri√©.
					</li>
					<li>
						<strong>Ajouter le fichier r√©solu :</strong>
						<pre class="language-bash">
			<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git add fichier_conflit.txt
	</code>
				</pre>
					</li>
					<li>
						<strong>Poursuivre le rebase :</strong>
						<pre class="language-bash">
			<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git rebase --continue
	</code>
				</pre>
					</li>
					<li>
						<strong>Annuler le rebase :</strong> Si n√©cessaire, vous pouvez abandonner le rebase en cours avec :
						<pre class="language-bash">
			<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git rebase --abort
	</code>
				</pre>
					</li>
				</ul>

				<h3>Rebase interactif</h3>
				<p>
					Le rebase interactif vous permet de modifier l‚Äôordre des commits, de fusionner plusieurs commits (squash), de modifier leurs messages ou m√™me de supprimer des commits. C‚Äôest une technique puissante pour nettoyer l‚Äôhistorique avant de fusionner une branche.
				</p>
				<pre class="language-bash">
			<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git rebase -i HEAD~3
	</code>
		</pre>
				<p>
					Lancez cette commande depuis votre branche de d√©veloppement. Un √©diteur s‚Äôouvrira avec une liste des 3 derniers commits, par exemple :
				</p>
				<pre class="language-text">
			<button class="btn btn-light copy-btn">Copier</button>
	<code>
	pick abc1234 Premier commit de la feature
	squash def5678 Second commit √† fusionner avec le premier
	pick ghi9012 Troisi√®me commit
	</code>
		</pre>
				<p>
					Modifiez les mots-cl√©s selon vos besoins (<code>pick</code>, <code>squash</code>, <code>reword</code>, etc.), sauvegardez et fermez l‚Äô√©diteur. Git fusionnera alors les commits indiqu√©s et vous demandera de confirmer ou modifier le message final.
				</p>

				<h3>Options avanc√©es</h3>
				<ul>
					<li>
						<strong>Utilisation de <code>--onto</code> :</strong>
						<p>
							Permet de repositionner une s√©rie de commits sur une nouvelle base, diff√©rente du parent direct. Par exemple, pour d√©placer tous les commits de <code>feature</code> qui ne sont pas dans <code>base</code> sur <code>nouvelle-base</code> :
						</p>
						<pre class="language-bash">
			<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git checkout feature
	git rebase --onto nouvelle-base base feature
	</code>
				</pre>
					</li>
					<li>
						<strong>R√©solution automatique avec <code>-Xours</code> ou <code>-Xtheirs</code> :</strong>
						<p>
							Ces options permettent de r√©soudre automatiquement les conflits en privil√©giant votre version (<code>ours</code>) ou celle de la branche sur laquelle vous rebasez (<code>theirs</code>).
							<em>Exemple :</em>
						</p>
						<pre class="language-bash">
			<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git rebase -Xtheirs main
	</code>
				</pre>
					</li>
					<li>
						<strong>Conservation des commits de fusion :</strong>
						<p>
							Par d√©faut, le rebase "aplati" l‚Äôhistorique en supprimant les commits de fusion. Pour conserver la topologie des fusions, utilisez l‚Äôoption <code>--rebase-merges</code> :
						</p>
						<pre class="language-bash">
			<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git rebase --rebase-merges main
	</code>
				</pre>
					</li>
				</ul>

				<p>
					<strong>Attention :</strong> N‚Äôeffectuez pas de rebase sur des branches d√©j√† pouss√©es sur un d√©p√¥t partag√©, car cela r√©√©crit l‚Äôhistorique et peut perturber le travail de vos coll√®gues. Il est recommand√© de tester ces op√©rations sur des d√©p√¥ts de test ou des branches locales avant de les utiliser en production.
				</p>
			</section>


			<!-- (8) COMPARAISON & ANALYSE -->
			<section id="comparaison">
				<h2 class="card-header text-primary">8. Comparaison & Analyse</h2>
				<p>
					Quelques commandes utiles pour comparer ou analyser l‚Äôhistorique :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git diff                # Voir ce qui a chang√© avant commit
	git diff --staged       # Voir ce qui est pr√™t √† commit
	git blame fichier       # Savoir qui a modifi√© chaque ligne
	git bisect start        # Commencer la recherche binaire d‚Äôun bug
	git bisect bad HEAD
	git bisect good <commit_ou_tag>
	git log -p              # Voir les changements en d√©tail par commit
	</code>
	</pre>
			</section>

			<!-- (9) ANNULER/COMMITS -->
			<section id="annuler">
				<h2 class="card-header text-primary">9. Annuler ou corriger des commits</h2>
				<h3>Revert</h3>
				<p>
					Cr√©e un commit inverse pour annuler un commit pr√©c√©dent :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git revert <commit_hash></code>
	</pre>

				<h3>Reset</h3>
				<p>
					Reculer dans l‚Äôhistorique, avec la possibilit√© de garder ou non les changements :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	# Garde les modifs mais enl√®ve le commit
	git reset --soft HEAD~1

	# Efface compl√®tement les modifs du dernier commit
	git reset --hard HEAD~1</code>
	</pre>

				<h3>Amend</h3>
				<p>
					Pour modifier le dernier commit (changer son message ou ajouter un fichier oubli√©) :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git commit --amend</code>
	</pre>
			</section>

			<!-- (10) STASH -->
			<section id="stash">
				<h2 class="card-header text-primary">10. Stash : mettre de c√¥t√© des modifs</h2>
				<p>
					On peut sauvegarder temporairement son travail sans faire de commit final :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git stash
	git stash list
	git stash pop
	git stash apply</code>
	</pre>
			</section>

			<!-- (11) DISTANTS & COLLAB -->
			<section id="depots-distants">
				<h2 class="card-header text-primary">11. D√©p√¥ts Distants & Collaboration</h2>
				<p>
					Quelques commandes pour synchroniser avec un serveur (GitHub, GitLab‚Ä¶) :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git fetch
	git pull
	git push
	git push -u origin branche</code>
	</pre>
				<p>
					<strong>Fork & Pull Request :</strong> sur GitHub, vous pouvez forker un repo, faire vos modifs,
					puis ouvrir une Pull Request pour proposer vos changements au projet d‚Äôorigine.
				</p>
			</section>

			<!-- (12) TAGS -->
			<section id="tags">
				<h2 class="card-header text-primary">12. Gestion des tags</h2>
				<p>
					Les tags servent souvent √† marquer des versions (v1.0, v2.0‚Ä¶).
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git tag
	git tag -a v1.0 -m "Version stable"
	git push origin --tags</code>
	</pre>
			</section>

			<!-- (13) SUBMODULES -->
			<section id="submodules">
				<h2 class="card-header text-primary">13. Submodules (Sous-modules)</h2>
				<p>
					On peut inclure un autre d√©p√¥t Git √† l‚Äôint√©rieur du n√¥tre (ex: librairie partag√©e).
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git submodule add <URL>
	git submodule init
	git submodule update</code>
	</pre>
			</section>

			<!-- (14) AVANCEES & UTILITAIRES -->
			<section id="avancees">
				<h2 class="card-header text-primary">14. Commandes avanc√©es & utilitaires</h2>
				<p>
					Voici quelques commandes plus ‚Äúsp√©ciales‚Äù :
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git cherry-pick <commit>      # Prendre un commit pr√©cis d‚Äôune autre branche
	git reflog                  # Historique cach√© de toutes les actions
	git gc                      # Nettoyer et compresser le repo
	git archive --format=zip HEAD > code.zip  # Exporter le code sans l'historique
	git shortlog               # Liste des commits regroup√©s par auteur
	</code>
	</pre>
			</section>

			<!-- (15) BONNES PRATIQUES -->
			<section id="bonnes-pratiques">
				<h2 class="card-header text-primary">15. Bonnes pratiques</h2>
				<ol>
					<li>Commits fr√©quents & atomiques (petites √©tapes faciles √† comprendre).</li>
					<li>Messages de commit clairs (expliquez ‚Äúpourquoi‚Äù et pas juste ‚Äúce qui a chang√©‚Äù).</li>
					<li>Utiliser des branches descriptives (ex: <code>feature/login</code>, <code>fix/bug-42</code>).
					</li>
					<li>Revue de code via Pull Requests (pour un avis ext√©rieur, moins de bugs). </li>
					<li>√âviter de r√©√©crire l‚Äôhistorique partag√© (risque de casser le repo de l‚Äô√©quipe). </li>
					<li>Maintenir un <code>.gitignore</code> (exclure fichiers inutiles, logs, etc.). </li>
				</ol>
			</section>

			<!-- (16) COMMANDES AVANC√âES DE GIT -->
			<section id="commandes-avancees-git">
				<h2 class="card-header text-primary">16. Les Commandes Avanc√©es de Git</h2>
				<p>
					Git propose de nombreuses commandes avanc√©es permettant de g√©rer finement l‚Äôhistorique du d√©p√¥t, de r√©soudre des probl√®mes complexes ou d‚Äôautomatiser certaines t√¢ches. Voici quelques-unes de ces commandes avec leurs explications d√©taill√©es :
				</p>

				<h3>1. Git Rebase</h3>
				<p>
					<strong>Description :</strong> La commande <code>git rebase</code> permet de d√©placer ou r√©appliquer une s√©rie de commits sur une nouvelle base, offrant ainsi un historique plus lin√©aire et propre.
				</p>
				<p><strong>Utilisations avanc√©es :</strong></p>
				<ul>
					<li>
						<em>Rebase simple :</em> Pour mettre √† jour une branche de fonctionnalit√© avec les derni√®res modifications de la branche principale :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git checkout featureA
	git rebase main
	</code>
		  </pre>
					</li>
					<li>
						<em>Rebase interactif :</em> Permet de modifier l‚Äôordre des commits, de fusionner (squash), de r√©ordonner ou supprimer certains commits. Par exemple :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git rebase -i HEAD~3
	</code>
		  </pre>
						Dans l‚Äô√©diteur, vous pourriez voir :
						<pre class="language-text">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	pick abc1234 Premier commit de la feature
	squash def5678 Deuxi√®me commit √† fusionner avec le premier
	pick ghi9012 Troisi√®me commit
	</code>
		  </pre>
					</li>
				</ul>

				<h3>2. Git Cherry-pick</h3>
				<p>
					<strong>Description :</strong> <code>git cherry-pick</code> permet d‚Äôextraire un ou plusieurs commits sp√©cifiques depuis une autre branche et de les appliquer sur la branche courante.
				</p>
				<p><strong>Utilisation typique :</strong> Par exemple, pour appliquer une correction critique directement sur la branche de production :</p>
				<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git checkout production
	git cherry-pick &lt;commit_hash&gt;
	</code>
	  </pre>

				<h3>3. Git Bisect</h3>
				<p>
					<strong>Description :</strong> <code>git bisect</code> est un outil de recherche dichotomique qui aide √† identifier le commit pr√©cis ayant introduit un bug ou une r√©gression.
				</p>
				<p><strong>Processus :</strong></p>
				<ol>
					<li>
						D√©marrer la recherche :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git bisect start
	</code>
		  </pre>
					</li>
					<li>
						Marquer le commit avec le bug :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git bisect bad
	</code>
		  </pre>
					</li>
					<li>
						Marquer un commit fonctionnel :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git bisect good &lt;commit_hash&gt;
	</code>
		  </pre>
					</li>
					<li>
						Une fois identifi√©, r√©initialiser le bisect :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git bisect reset
	</code>
		  </pre>
					</li>
				</ol>
				<p><em>Astuce :</em> Vous pouvez automatiser ce processus en cr√©ant un script de test retournant 0 en cas de succ√®s et 1 en cas d‚Äô√©chec.</p>

				<h3>4. Git Stash</h3>
				<p>
					<strong>Description :</strong> La commande <code>git stash</code> sauvegarde temporairement des modifications non committ√©es, permettant de nettoyer l‚Äôespace de travail sans perdre votre travail en cours.
				</p>
				<ul>
					<li>
						Sauvegarder avec un message :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git stash save "Travail en cours sur feature X"
	</code>
		  </pre>
					</li>
					<li>
						Lister les stashes :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git stash list
	</code>
		  </pre>
					</li>
					<li>
						Appliquer ou supprimer un stash sp√©cifique :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git stash apply stash@{2}
	git stash drop stash@{2}
	</code>
		  </pre>
					</li>
				</ul>

				<h3>5. Git Reflog</h3>
				<p>
					<strong>Description :</strong> <code>git reflog</code> conserve l‚Äôhistorique des d√©placements de <code>HEAD</code>, permettant de retrouver des commits "perdus" ou de revenir √† un √©tat ant√©rieur.
				</p>
				<p><strong>Utilisation :</strong></p>
				<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git reflog
	</code>
	  </pre>
				<p>Pour revenir √† un commit pr√©cis, par exemple :</p>
				<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git reset --hard HEAD@{3}
	</code>
	  </pre>

				<h3>6. Git Reset</h3>
				<p>
					<strong>Description :</strong> <code>git reset</code> modifie la position de <code>HEAD</code> et, selon l‚Äôoption choisie, peut modifier l‚Äôindex et le r√©pertoire de travail.
				</p>
				<ul>
					<li>
						<em>Soft (--soft) :</em> D√©place <code>HEAD</code> sans modifier l‚Äôindex ni le r√©pertoire de travail :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git reset --soft &lt;commit_hash&gt;
	</code>
		  </pre>
					</li>
					<li>
						<em>Mixed (par d√©faut) :</em> R√©initialise l‚Äôindex sans toucher au r√©pertoire de travail :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git reset &lt;commit_hash&gt;
	</code>
		  </pre>
					</li>
					<li>
						<em>Hard (--hard) :</em> R√©initialise <code>HEAD</code>, l‚Äôindex et le r√©pertoire de travail, supprimant toutes les modifications non committ√©es :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git reset --hard &lt;commit_hash&gt;
	</code>
		  </pre>
					</li>
				</ul>
				<p><em>Conseil :</em> Utilisez <code>--hard</code> avec pr√©caution, surtout sur des branches partag√©es.</p>

				<h3>7. Git Clean</h3>
				<p>
					<strong>Description :</strong> <code>git clean</code> supprime les fichiers non suivis dans le r√©pertoire de travail, permettant de nettoyer votre environnement.
				</p>
				<ul>
					<li>
						Voir ce qui sera supprim√© (mode test) :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git clean -n
	</code>
		  </pre>
					</li>
					<li>
						Supprimer les fichiers non suivis :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git clean -f
	</code>
		  </pre>
					</li>
					<li>
						Supprimer √©galement les r√©pertoires non suivis :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git clean -fd
	</code>
		  </pre>
					</li>
				</ul>
				<p><em>Astuce :</em> Utilisez toujours l‚Äôoption <code>-n</code> pour une simulation avant de supprimer d√©finitivement.</p>

				<h3>8. Git Filter-branch et Git Filter-repo</h3>
				<p>
					<strong>Description :</strong> Ces commandes permettent de r√©√©crire l‚Äôhistorique complet du d√©p√¥t, ce qui est utile pour supprimer des fichiers sensibles ou nettoyer l‚Äôhistorique.
				</p>
				<ul>
					<li>
						<em>git filter-branch :</em> Bien que puissant, il peut √™tre lent et complexe pour de gros d√©p√¥ts.
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch chemin/du/fichier' --prune-empty --tag-name-filter cat -- --all
	</code>
		  </pre>
					</li>
					<li>
						<em>git filter-repo :</em> Une alternative moderne et performante. Exemple pour supprimer un fichier de l‚Äôhistorique :
						<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git filter-repo --path chemin/du/fichier --invert-paths
	</code>
		  </pre>
						<p><em>Astuce :</em> Sauvegardez toujours votre d√©p√¥t avant d‚Äôeffectuer une r√©√©criture historique.</p>
					</li>
				</ul>

				<h3>9. Git Submodule</h3>
				<p>
					<strong>Description :</strong> La commande <code>git submodule</code> permet d‚Äôint√©grer et de g√©rer un d√©p√¥t Git externe au sein d‚Äôun projet, ce qui est utile pour g√©rer des d√©pendances ou biblioth√®ques de mani√®re autonome.
				</p>
				<p><strong>Utilisation typique :</strong></p>
				<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git submodule add &lt;URL_du_d√©p√¥t&gt; chemin/destination
	git submodule update --init --recursive
	</code>
	  </pre>

				<h3>10. Git Worktree</h3>
				<p>
					<strong>Description :</strong> La commande <code>git worktree</code> permet de travailler simultan√©ment sur plusieurs branches dans des r√©pertoires distincts sans avoir √† cloner le d√©p√¥t plusieurs fois.
				</p>
				<p><strong>Utilisation :</strong> Pour cr√©er un nouveau worktree pour une branche :</p>
				<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git worktree add ../chemin/vers/nouveau_worktree featureX
	</code>
	  </pre>
				<p>
					<em>Avantages :</em> Tester ou d√©velopper sur une branche tout en gardant la branche principale intacte. Id√©al pour des tests, builds ou d√©bogages sur des versions parall√®les.<br />
					<em>Conseil :</em> Pour revenir √† la gestion normale, supprimez le worktree avec :
				</p>
				<pre class="language-bash">
	  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	git worktree remove ../chemin/vers/nouveau_worktree
	</code>
	  </pre>

				<h3>Conclusion</h3>
				<p>
					Ces commandes avanc√©es offrent une flexibilit√© consid√©rable pour g√©rer l‚Äôhistorique, r√©soudre des probl√®mes complexes et optimiser votre flux de travail. Leur ma√Ætrise vous permet de :
				</p>
				<ul>
					<li><strong>G√©rer des workflows complexes :</strong> Adaptez l‚Äôhistorique avec <code>rebase</code>, <code>cherry-pick</code> et <code>reset</code>.</li>
					<li><strong>Identifier et corriger des erreurs :</strong> Utilisez <code>bisect</code> et <code>reflog</code> pour retrouver des commits probl√©matiques.</li>
					<li><strong>Optimiser l‚Äôenvironnement de d√©veloppement :</strong> Gr√¢ce √† <code>stash</code>, <code>clean</code>, <code>submodule</code> et <code>worktree</code> pour maintenir un espace de travail organis√©.</li>
				</ul>
				<p>
					En pratiquant ces commandes sur des d√©p√¥ts de test, vous gagnerez en confiance et serez mieux pr√©par√© pour g√©rer des projets complexes.
				</p>
			</section>


			<!-- TABLEAU COMPLET DES COMMANDES -->
			<section id="tableau-commands">
				<div class="table-responsive mt-3">
					<h2 class="card-header text-primary">Tableau complet des commandes Git</h2>
					<p>Retrouvez ci-dessous un r√©capitulatif complet :</p>
					<div class="table-responsive mt-3">
						<table class="table table-bordered table-hover align-middle">
							<thead class="table-dark">
							<tr>
								<th>Commande</th>
								<th>Utilisation</th>
								<th>Explication</th>
								<th>Avantage ‚úÖ</th>
								<th>Inconv√©nient üö®</th>
							</tr>
							</thead>
							<tbody>
							<!-- Liste COMPLETE (non tronqu√©e) -->
							<tr>
								<td><strong>git init</strong></td>
								<td><code>git init</code></td>
								<td>Initialise un nouveau d√©p√¥t Git (cr√©ation du dossier <code>.git/</code>).</td>
								<td>D√©marrer facilement un nouveau projet.</td>
								<td>Cr√©e un d√©p√¥t vide (peut n√©cessiter config/d√©p√¥t distant).</td>
							</tr>
							<tr>
								<td><strong>git clone</strong></td>
								<td><code>git clone URL [dossier]</code></td>
								<td>Copie un d√©p√¥t distant (ou local) dans un nouveau dossier.</td>
								<td>R√©cup√©ration rapide d‚Äôun projet existant et de son historique.</td>
								<td>Peut √™tre volumineux si le repo est tr√®s gros.</td>
							</tr>
							<tr>
								<td><strong>git remote add</strong></td>
								<td><code>git remote add &lt;nom&gt; &lt;URL&gt;</code></td>
								<td>Associe un d√©p√¥t distant (ex: <code>origin</code>) √† l‚ÄôURL sp√©cifi√©e.</td>
								<td>Permet de pousser/puller vers un d√©p√¥t en ligne (GitHub...).</td>
								<td>Erreur possible si l‚Äôon se trompe d‚ÄôURL.</td>
							</tr>
							<tr>
								<td><strong>git remote rename</strong></td>
								<td><code>git remote rename &lt;old&gt; &lt;new&gt;</code></td>
								<td>Renomme un d√©p√¥t distant (ex. <code>origin</code> ‚Üí <code>oldorigin</code>).
								</td>
								<td>Clarifie le nom (en cas de multiples remotes).</td>
								<td>Scripts/CI peuvent √™tre impact√©s si le nom change.</td>
							</tr>
							<tr>
								<td><strong>git remote remove</strong></td>
								<td><code>git remote remove &lt;nom&gt;</code></td>
								<td>Supprime un d√©p√¥t distant de la configuration Git.</td>
								<td>Nettoie la liste des remotes inutiles.</td>
								<td>Plus de push/pull possible vers ce remote si besoin.</td>
							</tr>
							<tr>
								<td><strong>git status</strong></td>
								<td><code>git status</code></td>
								<td>Affiche l‚Äô√©tat des fichiers : suivis, non suivis, pr√™ts √† √™tre commit, etc.</td>
								<td>Vue rapide et claire des changements.</td>
								<td>Aucun inconv√©nient majeur.</td>
							</tr>
							<tr>
								<td><strong>git add</strong></td>
								<td><code>git add fichier</code> / <code>git add .</code></td>
								<td>Ajoute des fichiers dans la zone de staging (pr√©paration au commit).</td>
								<td>Contr√¥le pr√©cis sur ce qu‚Äôon veut commiter.</td>
								<td>Si on oublie un fichier, il ne sera pas dans le commit.</td>
							</tr>
							<tr>
								<td><strong>git commit</strong></td>
								<td><code>git commit -m "msg"</code></td>
								<td>Cr√©e un instantan√© (commit) des changements valid√©s.</td>
								<td>Construit l‚Äôhistorique avec un message descriptif.</td>
								<td>Un mauvais message g√™ne la compr√©hension de l‚Äôhistorique.</td>
							</tr>
							<tr>
								<td><strong>git commit -am</strong></td>
								<td><code>git commit -am "msg"</code></td>
								<td>Combine l‚Äôajout et le commit pour les fichiers d√©j√† suivis.</td>
								<td>Gain de temps pour modifications rapides.</td>
								<td>Ne g√®re pas les nouveaux fichiers non suivis.</td>
							</tr>
							<tr>
								<td><strong>git commit --amend</strong></td>
								<td><code>git commit --amend</code></td>
								<td>Modifie le dernier commit (message ou fichiers).</td>
								<td>Corrige un oubli ou un message trop vague.</td>
								<td>R√©√©crit l‚Äôhistorique, d√©conseill√© si d√©j√† pouss√©.</td>
							</tr>
							<tr>
								<td><strong>git log</strong></td>
								<td><code>git log</code>, <code>git log --oneline</code></td>
								<td>Affiche l‚Äôhistorique des commits (d√©taill√© ou succinct).</td>
								<td>Bonne vision de l‚Äô√©volution du projet.</td>
								<td>Peut √™tre verbeux sur gros projets.</td>
							</tr>
							<tr>
								<td><strong>git checkout</strong></td>
								<td><code>git checkout &lt;branche&gt;</code> /
									<code>git checkout -- &lt;fichier&gt;</code></td>
								<td>Change de branche OU annule les modifs d‚Äôun fichier local.</td>
								<td>Navigation ais√©e entre branches.</td>
								<td>Perte possible de changements non commit si on oublie de stasher.</td>
							</tr>
							<tr>
								<td><strong>git branch</strong></td>
								<td><code>git branch &lt;nom&gt;</code></td>
								<td>Cr√©e une branche ou liste les branches (si pas d‚Äôargument).</td>
								<td>Organise le travail (nouvelles fonctionnalit√©s).</td>
								<td>Trop de branches peuvent cr√©er la confusion.</td>
							</tr>
							<tr>
								<td><strong>git branch -m</strong></td>
								<td><code>git branch -m &lt;ancien&gt; &lt;nouveau&gt;</code></td>
								<td>Renomme une branche locale.</td>
								<td>Corrige un nom mal choisi.</td>
								<td>Peut troubler d‚Äôautres si la branche est partag√©e.</td>
							</tr>
							<tr>
								<td><strong>git branch -d</strong></td>
								<td><code>git branch -d &lt;nom&gt;</code></td>
								<td>Supprime une branche locale (fusionn√©e).</td>
								<td>Nettoyage des branches termin√©es.</td>
								<td>Impossible si non fusionn√©e (risque de perte).</td>
							</tr>
							<tr>
								<td><strong>git branch -D</strong></td>
								<td><code>git branch -D &lt;nom&gt;</code></td>
								<td>Supprime une branche locale sans v√©rification.</td>
								<td>Forcer la suppression d‚Äôune branche obsol√®te.</td>
								<td>Risque de perte d√©finitive de commits.</td>
							</tr>
							<tr>
								<td><strong>git merge</strong></td>
								<td><code>git merge &lt;branche&gt;</code></td>
								<td>Fusionne la branche sp√©cifi√©e dans la branche courante.</td>
								<td>Combine facilement plusieurs flux de travail.</td>
								<td>Peut g√©n√©rer des conflits, cr√©e un commit de merge.</td>
							</tr>
							<tr>
								<td><strong>git merge --no-ff</strong></td>
								<td><code>git merge --no-ff &lt;branche&gt;</code></td>
								<td>Fusion sans fast-forward, garde un commit de merge d√©di√©.</td>
								<td>Historique plus lisible (commit de merge conserv√©).</td>
								<td>M√™me si un fast-forward √©tait possible, on force un commit suppl√©mentaire.</td>
							</tr>
							<tr>
								<td><strong>git rebase</strong></td>
								<td><code>git rebase &lt;branche&gt;</code></td>
								<td>‚ÄúRejoue‚Äù les commits de la branche courante sur une autre branche.</td>
								<td>Historique lin√©aire et propre (pas de commit de merge).</td>
								<td>R√©√©crit l‚Äôhistorique (dangereux si partag√©).</td>
							</tr>
							<tr>
								<td><strong>git rebase -i</strong></td>
								<td><code>git rebase -i HEAD~n</code></td>
								<td>Rebase interactif (modifier l‚Äôordre, fusionner, renommer des commits).</td>
								<td>Historique tr√®s propre, possibilit√© de ‚Äúsquasher‚Äù.</td>
								<td>Complexe, risque de collisions ou pertes.</td>
							</tr>
							<tr>
								<td><strong>git rebase --continue</strong></td>
								<td><code>git rebase --continue</code></td>
								<td>Poursuit le rebase apr√®s r√©solution de conflit.</td>
								<td>Finalise le rebase proprement.</td>
								<td>Faut r√©soudre tous les conflits un par un.</td>
							</tr>
							<tr>
								<td><strong>git rebase --abort</strong></td>
								<td><code>git rebase --abort</code></td>
								<td>Annule le rebase en cours et revient √† l‚Äô√©tat initial.</td>
								<td>Utile si trop de conflits.</td>
								<td>Annule tout le travail du rebase.</td>
							</tr>
							<tr>
								<td><strong>git diff</strong></td>
								<td><code>git diff</code>, <code>git diff --staged</code></td>
								<td>Compare les diff√©rences non valid√©es ou index√©es.</td>
								<td>Rep√®re pr√©cis√©ment les lignes modifi√©es.</td>
								<td>Peut √™tre long √† lire sur gros projets.</td>
							</tr>
							<tr>
								<td><strong>git blame</strong></td>
								<td><code>git blame &lt;fichier&gt;</code></td>
								<td>Montre, ligne par ligne, qui a modifi√© le fichier et quand.</td>
								<td>Pratique pour attribuer un changement pr√©cis.</td>
								<td>Peu lisible si gros fichier avec multiples auteurs.</td>
							</tr>
							<tr>
								<td><strong>git bisect</strong></td>
								<td><code>git bisect start</code>, <code>git bisect bad</code>,
									<code>git bisect good</code></td>
								<td>Recherche binaire d‚Äôun commit fautif.</td>
								<td>M√©thode puissante pour isoler un bug.</td>
								<td>Processus parfois long.</td>
							</tr>
							<tr>
								<td><strong>git revert</strong></td>
								<td><code>git revert &lt;commit&gt;</code></td>
								<td>Cr√©e un commit annulant un autre commit.</td>
								<td>Historique conserv√© sans tout √©craser.</td>
								<td>Peut allonger l‚Äôhistorique si nombreux revert.</td>
							</tr>
							<tr>
								<td><strong>git reset --soft</strong></td>
								<td><code>git reset --soft HEAD~1</code></td>
								<td>Reculer un commit en gardant les modifications dans le staging.</td>
								<td>Permet de refaire un commit propre.</td>
								<td>R√©√©crit l‚Äôhistorique (dangereux si d√©j√† pouss√©).</td>
							</tr>
							<tr>
								<td><strong>git reset --hard</strong></td>
								<td><code>git reset --hard HEAD~1</code></td>
								<td>Reculer un commit en supprimant d√©finitivement les modifs.</td>
								<td>Retour rapide √† un √©tat stable.</td>
								<td>Perte irr√©versible des changements.</td>
							</tr>
							<tr>
								<td><strong>git stash</strong></td>
								<td><code>git stash</code></td>
								<td>Met de c√¥t√© les modifs non commit√©es.</td>
								<td>Utile pour passer sur une autre branche sans perdre son travail.</td>
								<td>On peut oublier les stash si on ne les liste pas.</td>
							</tr>
							<tr>
								<td><strong>git stash pop</strong></td>
								<td><code>git stash pop</code></td>
								<td>R√©cup√®re et supprime le dernier stash.</td>
								<td>Permet de reprendre rapidement son travail mis en attente.</td>
								<td>Conflits possibles si code tr√®s diff√©rent entre-temps.</td>
							</tr>
							<tr>
								<td><strong>git stash apply</strong></td>
								<td><code>git stash apply [stash@{n}]</code></td>
								<td>Applique un stash (sans le supprimer).</td>
								<td>Peut r√©utiliser plusieurs fois le m√™me stash.</td>
								<td>Attention aux duplications si on l‚Äôapplique plusieurs fois.</td>
							</tr>
							<tr>
								<td><strong>git stash list</strong></td>
								<td><code>git stash list</code></td>
								<td>Affiche la liste de tous les stashes mis de c√¥t√©.</td>
								<td>Visualise rapidement les r√©serves de code.</td>
								<td>Pas d‚Äôinconv√©nient notable.</td>
							</tr>
							<tr>
								<td><strong>git fetch</strong></td>
								<td><code>git fetch [remote] [branche]</code></td>
								<td>R√©cup√®re les nouveaut√©s sans les fusionner.</td>
								<td>Voir ce qui a chang√© avant d‚Äôint√©grer.</td>
								<td>√âtape suppl√©mentaire (pull ou merge) pour la fusion finale.</td>
							</tr>
							<tr>
								<td><strong>git pull</strong></td>
								<td><code>git pull</code></td>
								<td>R√©cup√®re et fusionne directement les modifications du d√©p√¥t distant.</td>
								<td>Simple pour rester √† jour.</td>
								<td>Peut engendrer des conflits si modifs simultan√©es.</td>
							</tr>
							<tr>
								<td><strong>git push</strong></td>
								<td><code>git push</code></td>
								<td>Envoie les commits locaux vers la branche distante.</td>
								<td>Partage facile avec l‚Äô√©quipe.</td>
								<td>Conflits possibles si historique local en retard.</td>
							</tr>
							<tr>
								<td><strong>git push -u</strong></td>
								<td><code>git push -u origin &lt;branche&gt;</code></td>
								<td>Pousse la branche locale et la configure avec le d√©p√¥t distant.</td>
								<td>Simplifie les futurs push/pull.</td>
								<td>Peut cr√©er plusieurs branches distantes si mal utilis√©.</td>
							</tr>
							<tr>
								<td><strong>git push --force</strong></td>
								<td><code>git push --force</code> ou <code>git push --force-with-lease</code></td>
								<td>Force la r√©√©criture de l‚Äôhistorique distant.</td>
								<td>Utile apr√®s un rebase ou amend d√©j√† pouss√©.</td>
								<td>Risque de perdre le travail d‚Äôautres contributeurs.</td>
							</tr>
							<tr>
								<td><strong>git tag</strong></td>
								<td><code>git tag &lt;nom&gt;</code></td>
								<td>Cr√©e un tag l√©ger (non annot√©) sur le commit courant.</td>
								<td>Identifier rapidement une version.</td>
								<td>Pas de message ni m√©tadonn√©es.</td>
							</tr>
							<tr>
								<td><strong>git tag -a</strong></td>
								<td><code>git tag -a v1.0 -m "message"</code></td>
								<td>Cr√©e un tag annot√© (avec message).</td>
								<td>Historique complet sur la version (auteur, date, message).</td>
								<td>Trop de tags peut devenir confus.</td>
							</tr>
							<tr>
								<td><strong>git push origin --tags</strong></td>
								<td><code>git push origin --tags</code></td>
								<td>Envoie tous les tags locaux vers le d√©p√¥t distant.</td>
								<td>Partage public des diff√©rentes versions marqu√©es.</td>
								<td>Peut pousser des tags cr√©√©s par erreur.</td>
							</tr>
							<tr>
								<td><strong>git submodule add</strong></td>
								<td><code>git submodule add &lt;URL&gt;</code></td>
								<td>Ajoute un d√©p√¥t Git comme sous-module dans le projet.</td>
								<td>G√®re plusieurs projets dans un seul repo principal.</td>
								<td>Gestion parfois complexe si sous-modules changent souvent.</td>
							</tr>
							<tr>
								<td><strong>git submodule init</strong></td>
								<td><code>git submodule init</code></td>
								<td>Initialise les sous-modules d‚Äôun projet d√©j√† clon√©.</td>
								<td>Indispensable apr√®s un clone contenant des submodules.</td>
								<td>√âtape suppl√©mentaire qui peut √™tre oubli√©e.</td>
							</tr>
							<tr>
								<td><strong>git submodule update</strong></td>
								<td><code>git submodule update</code></td>
								<td>Met √† jour les sous-modules √† la version indiqu√©e dans le repo principal.</td>
								<td>Garde les sous-modules coh√©rents avec la r√©f√©rence choisie.</td>
								<td>Parfois besoin de <code>--recursive</code> (sous-sous-modules).</td>
							</tr>
							<tr>
								<td><strong>git clone --recurse-submodules</strong></td>
								<td><code>git clone --recurse-submodules &lt;URL&gt;</code></td>
								<td>Clone un projet et initialise les sous-modules en une seule commande.</td>
								<td>Pratique pour un projet multi-modules complet.</td>
								<td>Sinon il faut <code>init</code> et <code>update</code> manuellement.</td>
							</tr>
							<tr>
								<td><strong>git cherry-pick</strong></td>
								<td><code>git cherry-pick &lt;commit&gt;</code></td>
								<td>Copie un commit pr√©cis (d‚Äôune autre branche) dans la branche courante.</td>
								<td>Importe une correction ou fonctionnalit√© sans fusionner toute la branche.</td>
								<td>Conflits possibles si d√©pendances entre commits.</td>
							</tr>
							<tr>
								<td><strong>git reflog</strong></td>
								<td><code>git reflog</code></td>
								<td>Historique d√©taill√© des actions (commits, checkout...) m√™me effac√©es du log.
								</td>
								<td>Permet de r√©cup√©rer un commit perdu.</td>
								<td>Lecture parfois confuse pour les d√©butants.</td>
							</tr>
							<tr>
								<td><strong>git gc</strong></td>
								<td><code>git gc</code></td>
								<td>Nettoie/optimise la base de donn√©es Git (compression, purge objets obsol√®tes).
								</td>
								<td>R√©duit la taille du repo, am√©liore la performance.</td>
								<td>√Ä utiliser avec pr√©caution (peut effacer d√©finitivement certains objets).</td>
							</tr>
							<tr>
								<td><strong>git archive</strong></td>
								<td><code>git archive --format=zip HEAD &gt; code.zip</code></td>
								<td>Cr√©e une archive du contenu (sans l‚Äôhistorique complet).</td>
								<td>Utile pour exporter une version rapidement.</td>
								<td>Aucun suivi de l‚Äôhistorique dans l‚Äôarchive.</td>
							</tr>
							<tr>
								<td><strong>git shortlog</strong></td>
								<td><code>git shortlog</code></td>
								<td>R√©sum√© des commits group√©s par auteur.</td>
								<td>Vision rapide de la contribution de chacun.</td>
								<td>Manque de d√©tails sur les changements eux-m√™mes.</td>
							</tr>
							</tbody>
						</table>
					</div>
					<p><strong>Remarques :</strong></p>
					<ul>
						<li>Certaines commandes ont des variantes (ex. <code>-m</code>, <code>-p</code>,
							<code>--stat</code>).</li>
						<li>Les avantages/inconv√©nients d√©pendent du contexte (projet solo/√©quipe, etc.).</li>
					</ul>
			</section>

			<!-- EXEMPLES CONCRETS -->
			<section id="exemples">
				<h2 class="card-header text-primary">Exemples Concrets</h2>
				<h4>1. Annuler le dernier commit en gardant les modifs</h4>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git reset --soft HEAD~1
	# Les fichiers restent modifi√©s
	</code>
	</pre>

				<h4>2. Rebaser sa branche sur main</h4>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	git checkout ma-branche
	git pull origin main
	git rebase main
	</code>
	</pre>
			</section>

			<!-- EXERCICES & PIEGES -->
			<section id="exercices-pieges">
				<h2 class="card-header text-primary">Exercices & pi√®ges courants</h2>
				<h3>Exercices pratiques</h3>
				<ul>
					<li><strong>Exercice 1 :</strong> Cr√©er un d√©p√¥t local, y faire deux commits et pousser sur GitHub.
					</li>
					<li><strong>Exercice 2 :</strong> Cr√©er une branche, y faire une modif, provoquer un conflit et le
						r√©soudre.</li>
					<li><strong>Exercice 3 :</strong> Faire un stash avant de changer de branche, puis le r√©cup√©rer.
					</li>
				</ul>

				<h3>Pi√®ges courants √† √©viter</h3>
				<ul>
					<li><strong>Forcer un push</strong> : <code>git push --force</code> sans pr√©caution risque d‚Äô√©craser
						le travail d‚Äôautrui.</li>
					<li><strong>R√©√©crire l‚Äôhistorique partag√©</strong> : rebase ou reset sur une branche d√©j√† utilis√©e
						par d‚Äôautres.</li>
					<li><strong>Oublier stash</strong> : si on change de branche sans stasher, on peut perdre ses
						modifs.</li>
					<li><strong>Merge mal r√©solu</strong> : bien faire <code>git add</code> et <code>git commit</code>
						apr√®s le conflit.</li>
				</ul>
			</section>

			<!-- CONVENTIONS DE COMMIT -->
			<section id="commit-conventions">
				<h2 class="card-header text-primary">Conventions Commit</h2>
				<p>
					Parfois on suit des r√®gles pour les messages de commit (ex. <em>Conventional Commits</em>),
					afin de g√©n√©rer des changelogs automatiques, d‚Äôavoir une structure claire, etc.
				</p>
				<pre class="language-bash">
		<button class="btn btn-light copy-btn">Copier</button>
	<code>
	feat: ajout fonctionnalit√©
	fix: correction bug
	docs: mise √† jour doc
	</code>
		</pre>
			</section>

			<!-- CI/CD GITHUB ACTIONS -->
			<section id="github-actions">
				<h2 class="card-header text-primary">CI/CD (GitHub Actions)</h2>
				<p>
					Pour automatiser des tests ou un d√©ploiement, on peut cr√©er un fichier
					<code>.github/workflows/ci.yml</code> comme ceci :
				</p>
				<pre class="language-yaml">
				  <button class="btn btn-light copy-btn">Copier</button>
	<code>
	name: CI

	on:
		push:
		branches: [ "main" ]
		pull_request:
		branches: [ "main" ]

	jobs:
		build:
		runs-on: ubuntu-latest
		steps:
			- uses: actions/checkout@v2
			- name: Installer d√©pendances
			run: npm install
			- name: Lancer les tests
			run: npm test
	</code>
		</pre>
			</section>

			<!-- GLOSSAIRE GIT -->
			<section id="glossaire">
				<h2 class="card-header text-primary">Glossaire Git</h2>
				<ul>
					<li><strong>stash</strong> : mettre de c√¥t√© des modifications non commit (temporaire).</li>
					<li><strong>rebase</strong> : rejouer des commits sur une autre base pour un historique plus
						lin√©aire.</li>
					<li><strong>fetch</strong> : t√©l√©charger les changements distants sans les fusionner (juste les
						voir).</li>
					<li><strong>fork</strong> : copier un d√©p√¥t (souvent sur GitHub) dans son espace perso.</li>
					<li><strong>cherry-pick</strong> : prendre un commit pr√©cis d‚Äôune autre branche et l‚Äôajouter √† la
						n√¥tre.</li>
					<li><strong>tag</strong> : √©tiquette (nom) sur un commit (souvent pour marquer une version stable).
					</li>
				</ul>
			</section>

			<!-- CONCLUSION -->
			<section id="conclusion">
				<h2 class="card-header text-primary">Conclusion</h2>
				<p>
					Vous avez vu ici toutes les bases de Git, plus des parties avanc√©es (rebase, stash, etc.).
					Entra√Ænez-vous r√©guli√®rement pour retenir les commandes.
				</p>
				<p>
					Git est tr√®s puissant et utile quand on travaille √† plusieurs ou qu‚Äôon veut garder une trace
					de chaque changement dans son projet.
				</p>
				<p><strong>Bonne pratique de Git et bon code‚ÄØ!</strong></p>

			</section>

			<!-- (24) GIT WORKFLOWS -->
			<section id="workflows">
				<h2 class="card-header text-primary">24. Git Workflows</h2>
				<h3>Introduction aux Workflows Git</h3>
				<p>Un workflow Git (ou flux de travail Git) est un ensemble de conventions, de recommandations et de strat√©gies sur la mani√®re d'utiliser Git efficacement au sein d'un projet ou d'une √©quipe. Choisir un workflow adapt√© permet de structurer le d√©veloppement, de faciliter la collaboration, de g√©rer les versions et de maintenir un historique de projet propre et compr√©hensible. Il n'existe pas de workflow universel ; le choix d√©pendra souvent de la taille de l'√©quipe, de la nature du projet (ex: application web, biblioth√®que), du cycle de release, et des outils de CI/CD utilis√©s.</p>
				<p>Les workflows d√©finissent typiquement :</p>
				<ul>
					<li>La structure des branches (quelles branches sont utilis√©es et leur r√¥le).</li>
					<li>Quand et comment les branches sont cr√©√©es, fusionn√©es ou rebas√©es.</li>
					<li>Comment les versions et les releases sont g√©r√©es.</li>
					<li>Les conventions de nommage pour les branches et les commits.</li>
				</ul>
				<p>Nous allons explorer quelques workflows populaires.</p>

				<h3>Gitflow Workflow</h3>
				<p>Propos√© par Vincent Driessen en 2010, Gitflow est un mod√®le de branching robuste, con√ßu pour des projets avec un cycle de release planifi√©. Il est particuli√®rement populaire pour les logiciels qui ont des versions distinctes (ex: v1.0, v1.1, v2.0).</p>
				<h5>Branches Principales :</h5>
				<ul>
					<li><code>main</code> (ou <code>master</code>) : Contient le code de production stable, pr√™t √† √™tre d√©ploy√©. Chaque commit sur <code>main</code> est une nouvelle version et devrait √™tre tagu√© avec un num√©ro de version.</li>
					<li><code>develop</code> : Sert de branche d'int√©gration principale pour les fonctionnalit√©s. C'est ici que le code de la prochaine release est accumul√©. Lorsque <code>develop</code> atteint un √©tat stable et est pr√™te pour une release, elle est merg√©e dans <code>main</code> et tagu√©e.</li>
				</ul>
				<h5>Branches de Support :</h5>
				<ul>
					<li><strong>Branches de fonctionnalit√© (<code>feature/*</code>) :</strong>
						<ul>
							<li>Cr√©√©es √† partir de : <code>develop</code>.</li>
							<li>Doivent √™tre merg√©es dans : <code>develop</code>.</li>
							<li>Convention de nommage : <code>feature/nom-de-la-fonction</code> (ex: <code>feature/user-authentication</code>).</li>
							<li>But : D√©velopper de nouvelles fonctionnalit√©s de mani√®re isol√©e. Ne doivent jamais interagir directement avec <code>main</code>.</li>
						</ul>
					</li>
					<li><strong>Branches de release (<code>release/*</code>) :</strong>
						<ul>
							<li>Cr√©√©es √† partir de : <code>develop</code> (quand <code>develop</code> est pr√™te pour une release).</li>
							<li>Doivent √™tre merg√©es dans : <code>develop</code> ET <code>main</code>.</li>
							<li>Convention de nommage : <code>release/v1.0.1</code>.</li>
							<li>But : Pr√©parer une nouvelle release de production. Permet de faire des corrections de derni√®re minute, de la documentation, etc., sans interrompre le flux sur <code>develop</code>. Une fois pr√™te, la branche de release est merg√©e dans <code>main</code> (et tagu√©e) et aussi dans <code>develop</code> (pour y reporter les corrections de derni√®re minute).</li>
						</ul>
					</li>
					<li><strong>Branches de correctif (<code>hotfix/*</code>) :</strong>
						<ul>
							<li>Cr√©√©es √† partir de : <code>main</code> (depuis le tag de la version √† corriger).</li>
							<li>Doivent √™tre merg√©es dans : <code>develop</code> ET <code>main</code>.</li>
							<li>Convention de nommage : <code>hotfix/description-du-correctif</code> (ex: <code>hotfix/security-vulnerability-fix</code>).</li>
							<li>But : Corriger rapidement des bugs critiques en production. Permet de ne pas attendre le prochain cycle de release. Une fois le correctif appliqu√©, la branche est merg√©e dans <code>main</code> (et une nouvelle version est tagu√©e) et √©galement dans <code>develop</code>.</li>
						</ul>
					</li>
				</ul>
				<h5>Avantages de Gitflow :</h5>
				<ul>
					<li>Tr√®s structur√© et clair, surtout pour les projets avec plusieurs versions et des cycles de release d√©finis.</li>
					<li>Bonne isolation entre les nouvelles fonctionnalit√©s, la pr√©paration des releases et les correctifs urgents.</li>
					<li>Le r√¥le de chaque branche est bien d√©fini.</li>
				</ul>
				<h5>Inconv√©nients de Gitflow :</h5>
				<ul>
					<li>Peut √™tre per√ßu comme complexe, surtout pour les petits projets ou les √©quipes qui pratiquent l'int√©gration continue et le d√©ploiement continu (CI/CD).</li>
					<li>Le nombre de branches peut devenir important.</li>
					<li>La branche <code>develop</code> peut parfois diverger significativement de <code>main</code> sur de longues p√©riodes.</li>
				</ul>

				<h3>GitHub Flow</h3>
				<p>GitHub Flow est un workflow plus simple et l√©ger, popularis√© par GitHub. Il est particuli√®rement bien adapt√© aux projets qui pratiquent le d√©ploiement continu ou fr√©quent (ex: applications web).</p>
				<h5>Principes Cl√©s :</h5>
				<ul>
					<li><code>main</code> est toujours la branche principale et elle est **toujours d√©ployable**. Ce qui est sur <code>main</code> est consid√©r√© comme stable et pr√™t pour la production.</li>
					<li>Pour travailler sur quelque chose de nouveau (fonctionnalit√©, bugfix), cr√©ez une **branche descriptive** √† partir de <code>main</code> (ex: <code>feature/user-profile</code>, <code>fix/login-bug</code>).</li>
					<li>Poussez vos commits sur cette branche descriptive r√©guli√®rement sur le d√©p√¥t distant.</li>
					<li>Lorsque vous avez besoin de feedback ou que la fonctionnalit√© est pr√™te, ouvrez une **Pull Request (PR)**.</li>
					<li>Apr√®s revue et approbation de la PR (et passage des tests automatis√©s), la branche est **merg√©e dans <code>main</code>**.</li>
					<li>Une fois merg√©e dans <code>main</code>, les changements devraient √™tre **d√©ploy√©s imm√©diatement** (ou tr√®s rapidement).</li>
				</ul>
				<h5>Processus Typique :</h5>
				<ol>
					<li>Cr√©ez une branche √† partir de <code>main</code>: <code>git checkout -b feature/nouvelle-idee main</code></li>
					<li>Faites vos commits sur cette branche.</li>
					<li>Poussez la branche sur le serveur : <code>git push origin feature/nouvelle-idee</code></li>
					<li>Ouvrez une Pull Request sur GitHub (ou GitLab, etc.).</li>
					<li>Discutez, revoyez le code, ajoutez des commits si n√©cessaire (en poussant sur la m√™me branche).</li>
					<li>Une fois la PR approuv√©e et les tests CI pass√©s, mergez-la dans <code>main</code> (souvent via l'interface de la plateforme).</li>
					<li>D√©ployez <code>main</code>.</li>
					<li>Supprimez la branche de fonctionnalit√© une fois merg√©e et d√©ploy√©e.</li>
				</ol>
				<h5>Avantages de GitHub Flow :</h5>
				<ul>
					<li>Simple √† comprendre et √† mettre en ≈ìuvre.</li>
					<li>Favorise l'int√©gration continue et le d√©ploiement continu (CI/CD).</li>
					<li>Les Pull Requests facilitent la revue de code et la discussion avant l'int√©gration.</li>
					<li><code>main</code> est toujours une source de v√©rit√© pour le code stable.</li>
				</ul>
				<h5>Inconv√©nients de GitHub Flow :</h5>
				<ul>
					<li>Moins adapt√© si vous avez besoin de g√©rer plusieurs versions en parall√®le ou si vous avez des cycles de release longs et planifi√©s (Gitflow pourrait √™tre mieux).</li>
					<li>N√©cessite une bonne discipline pour s'assurer que <code>main</code> est r√©ellement toujours d√©ployable.</li>
					<li>La gestion des hotfixes peut n√©cessiter une petite adaptation (souvent, un hotfix suit le m√™me flux : branche √† partir de `main`, PR, merge, d√©ploiement).</li>
				</ul>

				<h3>Trunk-Based Development (Mention)</h3>
				<p>Le Trunk-Based Development (TBD) est un workflow o√π tous les d√©veloppeurs collaborent sur le code dans une seule branche appel√©e "trunk" (souvent <code>main</code> ou <code>master</code>). Les changements sont int√©gr√©s fr√©quemment (au moins une fois par jour).</p>
				<ul>
					<li>Les fonctionnalit√©s plus longues ou risqu√©es sont souvent g√©r√©es avec des "Feature Flags" (bascules de fonctionnalit√©s) pour permettre d'int√©grer le code dans le trunk sans le rendre actif pour les utilisateurs finaux imm√©diatement.</li>
					<li>Les branches, si utilis√©es, sont tr√®s courtes (quelques commits, durant moins d'un jour ou deux) avant d'√™tre merg√©es dans le trunk.</li>
					<li>Fortement d√©pendant d'une suite de tests automatis√©s robuste et d'une CI/CD performante.</li>
					<li>Objectif : √©viter les probl√®mes de "merge hell" en int√©grant continuellement.</li>
				</ul>
				<p>Ce workflow est courant dans les environnements qui visent une tr√®s haute v√©locit√© et un d√©ploiement continu.</p>
			</section>

			<!-- (25) HOOKS GIT -->
			<section id="hooks-git">
				<h2 class="card-header text-primary">25. Hooks Git (Crochets Git)</h2>

				<h3>Qu'est-ce qu'un Hook Git ?</h3>
				<p>Les hooks (ou "crochets") Git sont des scripts que Git ex√©cute automatiquement avant ou apr√®s certains √©v√©nements importants de son cycle de vie, tels que la cr√©ation de commits, le push de modifications, ou le changement de branches. Ils vous permettent de personnaliser le comportement de Git et d'automatiser des t√¢ches sp√©cifiques √† votre workflow.</p>
				<p>Par exemple, vous pouvez utiliser un hook pour :</p>
				<ul>
					<li>V√©rifier que votre message de commit respecte un format standard.</li>
					<li>Ex√©cuter des tests unitaires avant de permettre un commit.</li>
					<li>Notifier votre √©quipe d'int√©gration continue apr√®s un push r√©ussi.</li>
					<li>V√©rifier la qualit√© du code (linting) avant qu'il ne soit commit√©.</li>
				</ul>
				<p>Les hooks sont locaux √† chaque d√©p√¥t Git ; ils ne sont pas versionn√©s avec le d√©p√¥t lui-m√™me et ne sont donc pas transf√©r√©s lors d'un clone. Chaque d√©veloppeur doit configurer ses propres hooks ou utiliser un m√©canisme pour les partager au sein de l'√©quipe (par exemple, en les versionnant dans un dossier du projet et en ayant un script pour les copier/lier dans <code>.git/hooks</code>).</p>

				<h3>Types de Hooks</h3>
				<p>Il existe deux cat√©gories principales de hooks :</p>
				<ul>
					<li><strong>Hooks c√¥t√© client (Client-Side Hooks) :</strong> Ils sont ex√©cut√©s sur la machine locale du d√©veloppeur et affectent son workflow personnel. Ce sont ceux sur lesquels nous allons nous concentrer. Exemples : <code>pre-commit</code>, <code>prepare-commit-msg</code>, <code>commit-msg</code>, <code>post-commit</code>, <code>pre-push</code>.</li>
					<li><strong>Hooks c√¥t√© serveur (Server-Side Hooks) :</strong> Ils sont ex√©cut√©s sur le serveur Git distant (par exemple, votre serveur GitHub Enterprise, GitLab, ou un serveur Git auto-h√©berg√©) et sont utiles pour faire respecter des politiques pour le projet, envoyer des notifications, etc. Exemples : <code>pre-receive</code>, <code>update</code>, <code>post-receive</code>. La configuration de ces hooks d√©pend de la plateforme serveur.</li>
				</ul>

				<h3>Emplacement et Activation des Hooks</h3>
				<p>Les hooks c√¥t√© client r√©sident dans le r√©pertoire <code>.git/hooks/</code> de votre d√©p√¥t. Lorsque vous initialisez un nouveau d√©p√¥t avec <code>git init</code>, Git peuple ce dossier avec un ensemble d'exemples de scripts de hooks. Ces fichiers se terminent tous par <code>.sample</code> (par exemple, <code>pre-commit.sample</code>).</p>
				<p>Pour activer un hook, il suffit de :</p>
				<ol>
					<li>Naviguer vers le r√©pertoire <code>.git/hooks/</code>.</li>
					<li>Supprimer l'extension <code>.sample</code> du fichier de hook que vous voulez activer. Par exemple, renommez <code>pre-commit.sample</code> en <code>pre-commit</code>.</li>
					<li>Rendre le script ex√©cutable : <code>chmod +x pre-commit</code> (sur Linux/macOS).</li>
				</ol>
				<p>Vous pouvez √©crire vos scripts de hook dans n'importe quel langage de script que votre syst√®me peut ex√©cuter (Bash, Perl, Python, Ruby, Node.js, etc.), tant que le script est ex√©cutable et commence par un shebang correct (par exemple, <code>#!/bin/sh</code> ou <code>#!/usr/bin/env python3</code>).</p>
				<p>Si un script de hook retourne un code de sortie non nul (diff√©rent de 0), l'action Git correspondante (commit, push, etc.) est g√©n√©ralement annul√©e.</p>

				<h3>Exemple : Hook <code>pre-commit</code></h3>
				<p>Le hook <code>pre-commit</code> est ex√©cut√© juste avant que Git ne cr√©e le commit, apr√®s que vous ayez tap√© <code>git commit</code> mais avant que l'√©diteur de message de commit ne s'ouvre (sauf si vous utilisez <code>-m</code>).</p>
				<p>Il est id√©al pour effectuer des v√©rifications sur le code que vous √™tes sur le point de commiter. Si le script <code>pre-commit</code> sort avec un code non nul, le commit est avort√©.</p>
				<p><strong>Sc√©nario :</strong> S'assurer qu'aucun fichier ne contient de marqueurs de conflit de fusion (<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>) oubli√©s.</p>
				<p>Cr√©ez le fichier <code>.git/hooks/pre-commit</code> (et rendez-le ex√©cutable) avec le contenu suivant :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de hook pre-commit">Copier</button>
	<code>#!/bin/sh

	# V√©rifier les fichiers staged pour les marqueurs de conflit
	if git diff --cached --name-only --diff-filter=ACM | xargs grep -E -q -s '<<<<<<<|=======|>>>>>>>'; then
	  echo "ERREUR : Marqueurs de conflit de fusion d√©tect√©s dans les fichiers staged."
	  echo "Veuillez r√©soudre les conflits avant de commiter."
	  exit 1
	fi

	# Un autre exemple : interdire les commits directs sur la branche main (simple v√©rification)
	BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)
	if [ "$BRANCH_NAME" = "main" ]; then
	  # echo "ERREUR : Les commits directs sur la branche 'main' ne sont pas autoris√©s."
	  # echo "Veuillez utiliser une branche de fonctionnalit√© et une Pull Request."
	  # exit 1 # D√©commentez pour activer cette r√®gle
	fi

	# Si tout va bien, sortir avec 0 pour permettre le commit
	exit 0</code></pre>
				<p>Ce script v√©rifie d'abord les conflits. La partie comment√©e montre comment vous pourriez ajouter une r√®gle pour interdire les commits sur `main`.</p>

				<h3>Exemple : Hook <code>commit-msg</code></h3>
				<p>Le hook <code>commit-msg</code> prend un argument : le chemin vers un fichier temporaire qui contient le message de commit que vous avez r√©dig√©. Il est ex√©cut√© apr√®s que vous ayez ferm√© l'√©diteur de message de commit (ou apr√®s avoir fourni un message avec <code>-m</code>).</p>
				<p>Il est utilis√© pour valider ou reformater le message de commit. S'il sort avec un code non nul, le commit est avort√©.</p>
				<p><strong>Sc√©nario :</strong> S'assurer que le message de commit respecte un format simple (par exemple, ne commence pas par "WIP", a une longueur minimale).</p>
				<p>Cr√©ez <code>.git/hooks/commit-msg</code> (et rendez-le ex√©cutable) :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de hook commit-msg">Copier</button>
	<code>#!/bin/sh

	COMMIT_MSG_FILE=$1
	COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

	# V√©rifier si le message commence par "WIP" (Work In Progress)
	if echo "$COMMIT_MSG" | grep -qE '^WIP:'; then
	  echo "ATTENTION : Le message de commit commence par 'WIP:'."
	  echo "Ceci est permis, mais n'oubliez pas de le finaliser plus tard."
	  # Ne pas faire exit 1 ici si on veut juste avertir
	fi

	# V√©rifier une longueur minimale (par exemple, 10 caract√®res, sans compter les commentaires)
	ACTUAL_MSG=$(echo "$COMMIT_MSG" | grep -v '^#') # Ignorer les lignes de commentaire
	if [ ${#ACTUAL_MSG} -lt 10 ]; then
	  echo "ERREUR : Le message de commit est trop court (moins de 10 caract√®res)."
	  echo "Veuillez fournir un message plus descriptif."
	  exit 1
	fi

	# V√©rifier la pr√©sence d'un ticket ID (exemple: [PROJECT-123])
	# if ! echo "$COMMIT_MSG" | grep -qE '\[[A-Z]+-[0-9]+\]'; then
	#   echo "ERREUR : Le message de commit doit inclure un ID de ticket (ex: [PROJECT-123])."
	#   exit 1
	# fi


	# Si tout va bien
	exit 0</code></pre>
				<p>Ce script v√©rifie quelques r√®gles simples. Vous pouvez l'adapter pour des formats plus stricts comme <a href="#commit-conventions">Conventional Commits</a>.</p>

				<h3>Autres Hooks Utiles (Client-Side)</h3>
				<ul>
					<li><strong><code>prepare-commit-msg</code> :</strong> Ex√©cut√© avant l'√©diteur de message de commit mais apr√®s la cr√©ation du message par d√©faut. Utile pour ins√©rer un mod√®le de message ou modifier le message g√©n√©r√© automatiquement (par exemple, pour les commits de merge ou squash).</li>
					<li><strong><code>post-commit</code> :</strong> Ex√©cut√© juste apr√®s qu'un commit a √©t√© effectu√© avec succ√®s. Utile pour des notifications ou des t√¢ches de nettoyage.</li>
					<li><strong><code>pre-rebase</code> :</strong> Ex√©cut√© avant que <code>git rebase</code> ne commence. Peut √™tre utilis√© pour emp√™cher le rebase de certaines branches.</li>
					<li><strong><code>post-checkout</code> :</strong> Ex√©cut√© apr√®s un <code>git checkout</code> r√©ussi. Utile pour nettoyer le r√©pertoire de travail, installer des d√©pendances si un certain fichier a chang√©, etc.</li>
					<li><strong><code>pre-push</code> :</strong> Ex√©cut√© avant que <code>git push</code> n'envoie les commits au distant. C'est un excellent endroit pour ex√©cuter des tests d'int√©gration plus longs ou des v√©rifications finales avant de partager votre code. S'il √©choue, le push est annul√©.</li>
				</ul>

				<h3>Langages pour les Hooks</h3>
				<p>Comme mentionn√©, vous pouvez utiliser la plupart des langages de script. Le Shell (Bash, sh) est courant pour sa simplicit√© et sa portabilit√© sur les syst√®mes Unix-like. Python, Ruby, Perl et Node.js sont √©galement de bons choix, surtout si la logique du hook devient plus complexe ou si vous voulez utiliser des biblioth√®ques existantes.</p>
				<p>N'oubliez pas le shebang (<code>#!</code>) au d√©but de votre script pour indiquer l'interpr√©teur et de rendre le fichier de hook ex√©cutable.</p>
				<div class="alert alert-info" role="alert">
					<strong>Conseil :</strong> Il existe des outils et des frameworks (comme <a href="https://pre-commit.com/" target="_blank" rel="noopener noreferrer">pre-commit.com</a>) qui aident √† g√©rer et partager des hooks Git pr√©-construits ou personnalis√©s au sein d'une √©quipe, simplifiant leur installation et leur maintenance.
				</div>
			</section>

			<!-- (26) FINS DE LIGNE & .GITATTRIBUTES -->
			<section id="gitattributes">
				<h2 class="card-header text-primary">26. Fins de Ligne & <code>.gitattributes</code></h2>

				<h3>Le Probl√®me des Fins de Ligne (CRLF vs LF)</h3>
				<p>L'un des probl√®mes les plus courants et frustrants lorsque l'on travaille en √©quipe sur diff√©rents syst√®mes d'exploitation est la gestion des fins de ligne. Les syst√®mes Windows utilisent une s√©quence de deux caract√®res : retour chariot (Carriage Return, CR) et saut de ligne (Line Feed, LF), souvent not√©e CRLF. Les syst√®mes Unix (Linux, macOS) utilisent uniquement un saut de ligne (LF).</p>
				<p>Si les d√©veloppeurs d'une √©quipe utilisent des syst√®mes diff√©rents sans configuration appropri√©e, Git peut :</p>
				<ul>
					<li>Signaler des modifications sur chaque ligne d'un fichier alors que seul le type de fin de ligne a chang√©.</li>
					<li>Corrompre les fins de ligne, rendant les scripts non ex√©cutables sur certains syst√®mes ou causant des probl√®mes avec certains outils.</li>
				</ul>

				<h3>Configuration Globale (<code>core.autocrlf</code>)</h3>
				<p>Git tente de g√©rer ce probl√®me avec le param√®tre de configuration <code>core.autocrlf</code>. Il a trois valeurs possibles :</p>
				<ul>
					<li><strong><code>true</code> (Windows) :</strong>
						<code>git config --global core.autocrlf true</code>
						<br>Sur checkout (r√©cup√©ration) : Git convertit les fins de ligne LF en CRLF.
						<br>Sur commit (validation) : Git convertit les fins de ligne CRLF en LF.
						<br>C'est la configuration recommand√©e pour les utilisateurs Windows.
					</li>
					<li><strong><code>input</code> (macOS/Linux) :</strong>
						<code>git config --global core.autocrlf input</code>
						<br>Sur checkout : Git ne fait rien.
						<br>Sur commit : Git convertit les fins de ligne CRLF en LF.
						<br>C'est la configuration recommand√©e pour les utilisateurs macOS et Linux.
					</li>
					<li><strong><code>false</code> :</strong>
						<code>git config --global core.autocrlf false</code>
						<br>Git ne fait aucune conversion. Les fins de ligne sont commit√©es telles quelles. Non recommand√© pour les projets multi-OS.
					</li>
				</ul>
				<p>Bien que <code>core.autocrlf</code> aide, il n'est pas toujours suffisant et peut √™tre source de confusion car il d√©pend de la configuration locale de chaque d√©veloppeur. Une solution plus robuste et centralis√©e est d'utiliser un fichier <code>.gitattributes</code>.</p>

				<h3>Le Fichier <code>.gitattributes</code> : Introduction</h3>
				<p>Le fichier <code>.gitattributes</code> permet de d√©clarer des attributs sp√©cifiques pour des chemins (fichiers ou r√©pertoires) dans votre d√©p√¥t. Ces attributs indiquent √† Git comment traiter ces chemins. Contrairement √† <code>.gitignore</code> qui sp√©cifie les fichiers √† ignorer, <code>.gitattributes</code> d√©finit des comportements pour les fichiers suivis par Git.</p>
				<p>Ce fichier doit √™tre commit√© dans votre d√©p√¥t pour que ses r√®gles s'appliquent de mani√®re coh√©rente √† tous les collaborateurs. Il est g√©n√©ralement plac√© √† la racine du projet.</p>
				<p>Chaque ligne du fichier <code>.gitattributes</code> suit le format :<br>
					<code>pattern attr1 attr2 ...</code><br>
					O√π <code>pattern</code> est un motif de fichier (similaire √† ceux de <code>.gitignore</code>, ex: <code>*.txt</code>, <code>src/*.js</code>) et <code>attr1</code>, <code>attr2</code> sont les attributs que vous assignez.</p>

				<h3>G√©rer les Fins de Ligne via <code>.gitattributes</code></h3>
				<p>L'attribut le plus important pour la gestion des fins de ligne est <code>text</code>. Combin√© avec <code>eol</code>, il offre un contr√¥le pr√©cis :</p>
				<ul>
					<li><strong><code>* text=auto</code></strong>
						<p>C'est la configuration la plus courante et recommand√©e pour commencer. Pour tous les fichiers (<code>*</code>), Git essaiera de deviner s'il s'agit de fichiers texte. Si c'est le cas, il normalisera les fins de ligne en LF dans le d√©p√¥t et les convertira aux fins de ligne natives du syst√®me d'exploitation de l'utilisateur lors du checkout (CRLF pour Windows, LF pour macOS/Linux).</p>
					</li>
					<li><strong><code>*.txt text</code></strong>
						<p>Traite tous les fichiers <code>.txt</code> comme des fichiers texte et normalise leurs fins de ligne (LF dans le d√©p√¥t).</p>
					</li>
					<li><strong><code>*.sh text eol=lf</code></strong>
						<p>Traite tous les scripts shell (<code>.sh</code>) comme des fichiers texte et s'assure qu'ils utilisent des fins de ligne LF, que ce soit dans le d√©p√¥t ou dans le r√©pertoire de travail, quel que soit le syst√®me d'exploitation. C'est crucial car les scripts shell avec des fins de ligne CRLF ne fonctionnent pas correctement sur les syst√®mes Unix.</p>
					</li>
					<li><strong><code>*.bat text eol=crlf</code></strong>
						<p>Traite tous les scripts batch Windows (<code>.bat</code>) comme des fichiers texte et s'assure qu'ils utilisent des fins de ligne CRLF.</p>
					</li>
				</ul>
				<p><strong>Exemple de fichier <code>.gitattributes</code> :</strong></p>
				<pre class="language-text">
	<button class="btn btn-light copy-btn" aria-label="Copier l'exemple de fichier .gitattributes">Copier</button>
	<code># D√©finit le comportement par d√©faut pour tous les fichiers
	* text=auto

	# Force les fins de ligne LF pour les types de fichiers sensibles
	*.js    text eol=lf
	*.jsx   text eol=lf
	*.json  text eol=lf
	*.css   text eol=lf
	*.html  text eol=lf
	*.sh    text eol=lf
	*.py    text eol=lf
	*.md    text eol=lf
	*.xml   text eol=lf
	*.yml   text eol=lf
	*.yaml  text eol=lf

	# Pour les fichiers Windows sp√©cifiques, forcer CRLF
	*.bat   text eol=crlf
	*.cmd   text eol=crlf
	*.sln   text eol=crlf
	*.vcproj text eol=crlf

	# Marquer les fichiers binaires (Git ne tentera pas de les convertir ou de les differ)
	*.png   binary
	*.jpg   binary
	*.jpeg  binary
	*.gif   binary
	*.pdf   binary
	*.zip   binary
	*.exe   binary
	*.dll   binary
	*.o     binary
	*.a     binary
	*.obj   binary
	*.so    binary</code></pre>
				<p>Apr√®s avoir ajout√© ou modifi√© un fichier <code>.gitattributes</code>, il est possible que vous deviez rafra√Æchir les fichiers de votre r√©pertoire de travail pour que les nouvelles r√®gles s'appliquent. Git ne modifie pas automatiquement les fichiers d√©j√† pr√©sents. Vous pouvez le faire en :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier les commandes pour rafra√Æchir les fichiers apr√®s modification de .gitattributes">Copier</button>
	<code>git add . --renormalize</code></pre>
				<p>Puis commitez les changements si Git d√©tecte des normalisations de fins de ligne.</p>

				<h3>Marquer les Fichiers Binaires</h3>
				<p>Il est important d'indiquer √† Git quels fichiers sont binaires. Git essaiera de ne pas modifier les fins de ligne de ces fichiers et ne tentera pas de g√©n√©rer des diffs textuels pour eux.</p>
				<p>Vous pouvez le faire avec l'attribut <code>binary</code> ou en sp√©cifiant <code>-text</code> :</p>
				<ul>
					<li><code>*.png binary</code></li>
					<li><code>*.jpg -text</code> (signifie "pas un fichier texte")</li>
				</ul>
				<p>Cela emp√™che la corruption de fichiers binaires par les conversions de fins de ligne et rend les op√©rations comme <code>git diff</code> plus performantes pour ces fichiers.</p>
				<div class="alert alert-info" role="alert">
					Utiliser un fichier <code>.gitattributes</code> bien configur√© est une bonne pratique pour tout projet, surtout ceux impliquant plusieurs collaborateurs ou syst√®mes d'exploitation, afin d'√©viter les probl√®mes li√©s aux fins de ligne et de s'assurer que Git traite correctement les diff√©rents types de fichiers.
				</div>
			</section>

			<!-- (27) GIT RERERE -->
			<section id="git-rerere">
				<h2 class="card-header text-primary">27. <code>git rerere</code> (Reuse Recorded Resolution)</h2>

				<h3>Le Probl√®me : R√©soudre les M√™mes Conflits R√©p√©titivement</h3>
				<p>Lorsque vous travaillez sur des branches qui vivent longtemps et que vous rebasez fr√©quemment sur une branche principale active (comme <code>main</code> ou <code>develop</code>), ou lorsque vous effectuez des merges r√©p√©titifs entre les m√™mes branches, vous pouvez vous retrouver √† r√©soudre les m√™mes conflits de fusion encore et encore. Cela peut √™tre fastidieux et source d'erreurs.</p>
				<p>Par exemple, si vous avez une branche de fonctionnalit√© et que vous la rebasez sur <code>main</code>, vous r√©solvez des conflits. Si, quelques jours plus tard, vous rebasez √† nouveau cette m√™me branche sur une version plus r√©cente de <code>main</code>, il est probable que beaucoup des m√™mes conflits r√©apparaissent.</p>

				<h3>Qu'est-ce que <code>git rerere</code> et Comment √áa Marche ?</h3>
				<p><code>rerere</code> signifie "<strong>re</strong>use <strong>re</strong>corded <strong>re</strong>solution" (r√©utiliser la r√©solution enregistr√©e). C'est une fonctionnalit√© de Git qui observe comment vous r√©solvez les conflits de hunk (morceaux de code en conflit) et enregistre ces r√©solutions. Si Git rencontre √† nouveau exactement le m√™me conflit, il peut automatiquement appliquer la r√©solution que vous aviez pr√©c√©demment fournie.</p>
				<p>Lorsqu'un conflit de fusion se produit et que <code>rerere</code> est activ√© :</p>
				<ol>
					<li>Git v√©rifie si ce conflit exact a d√©j√† √©t√© r√©solu et enregistr√©.</li>
					<li>S'il trouve un enregistrement correspondant, il utilise la r√©solution pr√©c√©dente pour modifier les fichiers dans votre r√©pertoire de travail. Les fichiers peuvent alors appara√Ætre comme r√©solus (ou partiellement r√©solus si de nouveaux conflits sont pr√©sents).</li>
					<li>Si le conflit est nouveau, Git enregistre l'√©tat pr√©-r√©solution du conflit. Une fois que vous avez r√©solu le conflit manuellement et que vous avez fait <code>git add</code> sur les fichiers concern√©s, Git enregistre la mani√®re dont vous l'avez r√©solu.</li>
				</ol>
				<p>Cela ne signifie pas que vous n'aurez plus jamais √† r√©soudre de conflits, mais cela peut consid√©rablement r√©duire le nombre de conflits identiques que vous devez traiter manuellement.</p>

				<h3>Activer <code>git rerere</code></h3>
				<p>La fonctionnalit√© <code>rerere</code> n'est pas activ√©e par d√©faut. Pour l'activer globalement pour tous vos d√©p√¥ts :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande pour activer git rerere globalement">Copier</button>
	<code>git config --global rerere.enabled true</code></pre>
				<p>Vous pouvez √©galement l'activer uniquement pour un d√©p√¥t sp√©cifique en omettant l'option <code>--global</code> dans le r√©pertoire de ce d√©p√¥t.</p>
				<p>Une fois activ√©, Git cr√©era un r√©pertoire <code>rr-cache</code> dans votre dossier <code>.git</code> pour stocker les r√©solutions enregistr√©es. Ce cache est sp√©cifique √† votre d√©p√¥t local (il n'est pas pouss√© vers le distant, bien qu'il puisse √™tre partag√© manuellement si n√©cessaire, mais c'est un cas d'usage plus avanc√©).</p>
				<p>Il existe aussi l'option <code>rerere.autoupdate</code> :</p>
				<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier la commande pour activer rerere.autoupdate">Copier</button>
	<code>git config --global rerere.autoupdate true</code></pre>
				<p>Si <code>rerere.autoupdate</code> est √† <code>true</code> (par d√©faut √† <code>false</code>), Git mettra automatiquement √† jour l'index (comme si vous aviez fait <code>git add</code>) pour les hunks qu'il a pu r√©soudre automatiquement gr√¢ce √† <code>rerere</code>. Cela peut vous faire gagner une √©tape, mais certains pr√©f√®rent v√©rifier la r√©solution automatique avant de l'ajouter √† l'index.</p>

				<h3>Quand est-ce le plus utile ?</h3>
				<ul>
					<li><strong>Rebases fr√©quents :</strong> Si vous maintenez une branche de fonctionnalit√© √† jour en la rebasant r√©guli√®rement sur une branche cible qui √©volue rapidement.</li>
					<li><strong>Branches de longue dur√©e :</strong> Pour les branches qui divergent significativement et qui sont merg√©es ou rebas√©es p√©riodiquement.</li>
					<li><strong>Maintenance de plusieurs versions :</strong> Lors du backporting de correctifs sur d'anciennes branches de release, o√π des conflits similaires peuvent survenir.</li>
					<li><strong>Lors de l'utilisation de <code>git bisect</code> :</strong> Si la recherche binaire implique des merges ou des rebases qui g√©n√®rent des conflits r√©p√©titifs.</li>
				</ul>

				<h3>Commandes Associ√©es (Optionnel)</h3>
				<p>Bien que <code>rerere</code> fonctionne principalement en arri√®re-plan, quelques commandes peuvent √™tre utiles pour interagir avec le cache <code>rr-cache</code> :</p>
				<ul>
					<li><code>git rerere status</code> : Affiche les conflits que <code>rerere</code> suit actuellement.</li>
					<li><code>git rerere diff</code> : Affiche les diffs des r√©solutions enregistr√©es.</li>
					<li><code>git rerere remaining</code> : Affiche les conflits qui n√©cessitent encore une r√©solution manuelle (si <code>rerere.autoupdate</code> est false ou si certains hunks n'ont pas pu √™tre r√©solus).</li>
					<li><code>git rerere clear</code> : Supprime tous les enregistrements du cache <code>rr-cache</code> pour le d√©p√¥t courant (utile si vous pensez qu'une r√©solution incorrecte a √©t√© enregistr√©e).</li>
					<li><code>git rerere gc</code> : Effectue un nettoyage (garbage collection) des anciennes r√©solutions enregistr√©es qui ne sont plus pertinentes.</li>
				</ul>
				<p>En g√©n√©ral, vous n'aurez pas besoin d'utiliser ces commandes fr√©quemment, car l'avantage principal de <code>rerere</code> est son automatisation silencieuse.</p>
				<div class="alert alert-success" role="alert">
					<strong>En r√©sum√© :</strong> <code>git rerere</code> est un outil discret mais puissant qui apprend de vos r√©solutions de conflits pass√©es pour vous faire gagner du temps sur des conflits identiques √† l'avenir. Activez-le et laissez-le travailler en arri√®re-plan !
				</div>
			</section>

			<!-- (28) COLLABORATION AVANCEE SUR PLATEFORMES -->
			<section id="collaboration-plateformes">
				<h2 class="card-header text-primary">28. Collaboration Avanc√©e sur Plateformes</h2>

				<h3>Introduction : Au-del√† du <code>push</code> et <code>pull</code></h3>
				<p>Si les commandes Git de base comme <code>push</code>, <code>pull</code>, <code>commit</code>, et <code>branch</code> sont essentielles pour le travail individuel et la synchronisation simple, la collaboration moderne sur des projets logiciels, en particulier avec des √©quipes ou sur des projets open source, s'appuie fortement sur les fonctionnalit√©s offertes par les plateformes d'h√©bergement Git telles que GitHub, GitLab, Bitbucket, etc. Ces plateformes fournissent des outils et des workflows qui facilitent la revue de code, la discussion, le suivi des t√¢ches et l'int√©gration des contributions de mani√®re structur√©e.</p>

				<h3>Pull Requests (PRs) / Merge Requests (MRs) : Le C≈ìur de la Collaboration</h3>
				<p>Les Pull Requests (terme utilis√© par GitHub et Bitbucket) ou Merge Requests (terme utilis√© par GitLab) sont le m√©canisme central de la collaboration sur ces plateformes. Une PR/MR est une proposition formelle d'int√©grer les changements d'une branche (par exemple, une branche de fonctionnalit√©) dans une autre (souvent la branche principale comme <code>main</code> ou <code>develop</code>).</p>
				<h5>Bonnes pratiques pour la cr√©ation de PRs/MRs :</h5>
				<ul>
					<li><strong>Titre clair et concis :</strong> Le titre doit r√©sumer l'objectif de la PR/MR. Beaucoup d'√©quipes utilisent des pr√©fixes (ex: <code>feat:</code>, <code>fix:</code>, <code>docs:</code>) inspir√©s des Conventional Commits.</li>
					<li><strong>Description d√©taill√©e :</strong> Expliquez le <em>pourquoi</em> des changements, le probl√®me r√©solu ou la fonctionnalit√© ajout√©e. Incluez des liens vers les issues/tickets concern√©s. Si des changements d'interface utilisateur sont impliqu√©s, des captures d'√©cran ou des GIFs sont tr√®s utiles.</li>
					<li><strong>Commits atomiques et propres :</strong> La branche source de la PR/MR devrait avoir un historique de commits propre et compr√©hensible. Chaque commit devrait repr√©senter une √©tape logique. Utilisez le <a href="#rebase">rebase interactif</a> pour nettoyer votre historique local avant de cr√©er la PR/MR ou de la mettre √† jour.</li>
					<li><strong>Petites PRs/MRs cibl√©es :</strong> Privil√©giez des PRs/MRs de petite taille, focalis√©es sur un seul objectif. Elles sont plus faciles et rapides √† r√©viser, √† tester et √† merger.</li>
					<li><strong>Auto-revue :</strong> Relisez votre propre code et la description de votre PR/MR avant de la soumettre ou de demander des revues. Vous trouverez souvent des erreurs ou des am√©liorations vous-m√™me.</li>
				</ul>
				<h5>Le processus de revue de code :</h5>
				<p>La revue de code est une √©tape cruciale pour am√©liorer la qualit√© du code, partager les connaissances et d√©tecter les bugs t√¥t. Voici quelques conseils :</p>
				<ul>
					<li><strong>Pour le r√©viseur :</strong>
						<ul>
							<li>Soyez constructif et respectueux. Le but est d'am√©liorer le code, pas de critiquer l'auteur.</li>
							<li>Comprenez le contexte et l'objectif des changements.</li>
							<li>V√©rifiez la logique, la clart√©, la performance, la s√©curit√©, la maintenabilit√©, et la conformit√© aux conventions du projet.</li>
							<li>Posez des questions plut√¥t que d'affirmer. Sugg√©rez des am√©liorations au lieu d'imposer des changements.</li>
							<li>Utilisez les outils de la plateforme (commentaires en ligne, suggestions de code).</li>
						</ul>
					</li>
					<li><strong>Pour l'auteur :</strong>
						<ul>
							<li>Ne prenez pas le feedback personnellement. Consid√©rez-le comme une opportunit√© d'apprendre et d'am√©liorer.</li>
							<li>R√©pondez aux commentaires, expliquez vos choix si n√©cessaire, ou indiquez que vous allez appliquer les suggestions.</li>
							<li>Poussez de nouveaux commits sur votre branche pour adresser le feedback. La PR/MR se mettra √† jour automatiquement.</li>
							<li>Remerciez les r√©viseurs pour leur temps.</li>
						</ul>
					</li>
				</ul>
				<p>La discussion continue jusqu'√† ce que la PR/MR soit approuv√©e et pr√™te √† √™tre merg√©e.</p>

				<h3>Gestion des Issues / Tickets</h3>
				<p>Les plateformes Git fournissent des syst√®mes de suivi des "issues" (probl√®mes, t√¢ches, bugs, demandes de fonctionnalit√©s). Une bonne gestion des issues est essentielle pour l'organisation du projet.</p>
				<ul>
					<li><strong>Cr√©ation d'issues claires :</strong> Une issue bien d√©crite comprend un titre explicite, des √©tapes pour reproduire un bug (si applicable), le comportement attendu vs. le comportement observ√©, et toute information contextuelle pertinente (version du logiciel, environnement, etc.).</li>
					<li><strong>Liaison Issues - Commits - PRs/MRs :</strong> La plupart des plateformes permettent de lier les issues au travail effectu√©. En incluant des mots-cl√©s comme <code>fixes #123</code>, <code>closes #123</code>, ou <code>resolves #123</code> dans vos messages de commit ou descriptions de PR/MR, l'issue #123 sera automatiquement ferm√©e lorsque la PR/MR sera merg√©e dans la branche par d√©faut. Vous pouvez aussi simplement mentionner une issue (<code>ref #123</code>) pour cr√©er un lien sans la fermer.</li>
					<li><strong>Labels (√âtiquettes) :</strong> Utilisez des labels pour cat√©goriser les issues (ex: <code>bug</code>, <code>enhancement</code>, <code>documentation</code>, <code>priority:high</code>, <code>good first issue</code>). Cela aide √† filtrer et √† prioriser le travail.</li>
					<li><strong>Milestones (Jalons) :</strong> Regroupez des issues et des PRs/MRs en milestones pour suivre l'avancement vers une version ou un objectif sp√©cifique.</li>
					<li><strong>Assignations :</strong> Assignez des issues aux membres de l'√©quipe pour clarifier qui est responsable de quoi.</li>
				</ul>

				<h3>Strat√©gies de Merge des PRs/MRs sur les Plateformes</h3>
				<p>Lorsque une PR/MR est pr√™te, les plateformes offrent g√©n√©ralement plusieurs options pour l'int√©grer :</p>
				<ul>
					<li><strong>Merge Commit (Cr√©er un commit de fusion) :</strong>
						<ul>
							<li>C'est l'option par d√©faut sur beaucoup de plateformes (ex: le bouton "Merge pull request" de GitHub).</li>
							<li>Tous les commits de la branche de fonctionnalit√© sont conserv√©s, et un nouveau commit de merge est cr√©√© sur la branche cible pour lier les historiques.</li>
							<li><strong>Avantages :</strong> Pr√©serve tout l'historique de la branche de fonctionnalit√©, y compris les commits individuels. Le point de merge est clairement identifiable.</li>
							<li><strong>Inconv√©nients :</strong> Peut rendre l'historique de la branche principale plus "bruyant" avec de nombreux commits de merge si les branches de fonctionnalit√©s ont beaucoup de petits commits interm√©diaires.</li>
						</ul>
					</li>
					<li><strong>Squash and Merge (√âcraser et fusionner) :</strong>
						<ul>
							<li>Combine tous les commits de la branche de fonctionnalit√© en un seul commit sur la branche cible. Le message de ce commit unique peut √™tre √©dit√© √† partir des messages des commits originaux.</li>
							<li><strong>Avantages :</strong> Maintient un historique de la branche principale tr√®s propre et lin√©aire, avec un seul commit par fonctionnalit√© ou PR merg√©e.</li>
							<li><strong>Inconv√©nients :</strong> Perd la granularit√© de l'historique de la branche de fonctionnalit√© (les commits individuels de d√©veloppement ne sont plus visibles sur la branche principale).</li>
						</ul>
					</li>
					<li><strong>Rebase and Merge (Rebaser et fusionner) :</strong>
						<ul>
							<li>Prend tous les commits de la branche de fonctionnalit√©, les rebase sur la derni√®re version de la branche cible, puis les ajoute √† la branche cible sans cr√©er de commit de merge (effectue un fast-forward si possible).</li>
							<li><strong>Avantages :</strong> Cr√©e un historique parfaitement lin√©aire sur la branche principale, sans commits de merge. Les commits individuels de la fonctionnalit√© sont pr√©serv√©s.</li>
							<li><strong>Inconv√©nients :</strong> R√©√©crit l'historique des commits de la branche de fonctionnalit√© (nouveaux SHA). Peut rendre plus complexe le suivi de quand exactement une branche a √©t√© "merg√©e" si l'on ne regarde que le graphe. N√©cessite que les contributeurs soient √† l'aise avec le rebase de leurs branches.</li>
						</ul>
					</li>
				</ul>
				<p>Le choix de la strat√©gie d√©pend des pr√©f√©rences de l'√©quipe et du projet. Beaucoup d'√©quipes optent pour "Squash and Merge" ou "Rebase and Merge" pour garder un historique <code>main</code> propre, tout en s'assurant que les PRs elles-m√™mes contiennent des commits bien structur√©s.</p>

				<h3>Forks et Contribution √† des Projets Externes</h3>
				<p>Lorsque vous voulez contribuer √† un projet open source auquel vous n'avez pas les droits de push directs, le workflow typique est "Fork & Pull Request" :</p>
				<ol>
					<li><strong>Forker le d√©p√¥t :</strong> Sur la plateforme (GitHub, GitLab), cr√©ez une copie personnelle (un "fork") du d√©p√¥t original sous votre propre compte.</li>
					<li><strong>Cloner votre fork :</strong> Clonez votre fork sur votre machine locale : <code>git clone https://github.com/VOTRE_NOM_UTILISATEUR/nom-du-projet.git</code></li>
					<li><strong>Configurer un remote <code>upstream</code> :</strong> Ajoutez le d√©p√¥t original comme un remote pour pouvoir r√©cup√©rer ses mises √† jour : <code>git remote add upstream https://github.com/PROPRIETAIRE_ORIGINAL/nom-du-projet.git</code></li>
					<li><strong>Cr√©er une branche de fonctionnalit√© :</strong> Travaillez toujours sur une branche d√©di√©e : <code>git checkout -b ma-contribution</code></li>
					<li><strong>Faire vos modifications et commits.</strong></li>
					<li><strong>Pousser votre branche sur votre fork :</strong> <code>git push origin ma-contribution</code></li>
					<li><strong>Ouvrir une Pull Request :</strong> Depuis votre fork sur la plateforme, ouvrez une PR ciblant la branche appropri√©e du d√©p√¥t <code>upstream</code> (original).</li>
					<li><strong>Maintenir son fork et sa branche √† jour :</strong> Pendant que votre PR est en revue, le projet <code>upstream</code> peut √©voluer. Pour mettre votre branche √† jour :
						<pre class="language-bash">
	<button class="btn btn-light copy-btn" aria-label="Copier les commandes pour mettre √† jour un fork">Copier</button>
	<code>git checkout main # ou la branche principale de votre fork
	git fetch upstream
	git merge upstream/main # Mettre √† jour votre main local avec le main de l'upstream
	git checkout ma-contribution
	git rebase main # Rebaser votre branche de contribution sur votre main √† jour
	git push origin ma-contribution --force-with-lease # Mettre √† jour la PR (force-push n√©cessaire apr√®s rebase)</code></pre>
					</li>
				</ol>

				<h3>Utilisation des "Draft PRs" / "WIP PRs"</h3>
				<p>La plupart des plateformes permettent de cr√©er des Pull Requests en mode "Brouillon" (Draft) ou de les marquer comme "Work In Progress" (WIP) dans leur titre. C'est utile lorsque :</p>
				<ul>
					<li>Vous voulez obtenir un feedback pr√©liminaire sur une id√©e ou une approche avant que le code ne soit finalis√©.</li>
					<li>Vous voulez utiliser l'int√©gration continue (CI) de la PR pour lancer des tests sur votre branche, m√™me si elle n'est pas pr√™te pour une revue compl√®te.</li>
					<li>Cela signale aux r√©viseurs potentiels que la PR n'est pas encore pr√™te √† √™tre merg√©e.</li>
				</ul>
				<p>Une fois pr√™te, vous pouvez convertir la Draft PR en une PR normale pour une revue formelle.</p>
			</section>

		</div><!-- Fin .container -->
	</div><!-- Fin .contentWithToc -->

	<footer>
		<div class="container">
			<p class="m-0">Cours r√©alis√© par <strong>G.G. Paterne</strong> - Tous droits r√©serv√©s</p>
		</div>
	</footer>

	<!-- Bouton Scroll to Top -->
	<button type="button" class="btn btn-danger btn-floating" id="btnScrollTop" data-mdb-ripple-color="light">
		‚Üë
	</button>

	<!-- MDB JavaScript -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/8.1.0/mdb.min.js">
	</script>

	<!-- Prism.js pour coloration syntaxique -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js">
	</script>
	<!-- Custom JavaScript -->
	<script src="script.js"></script>
</body>

</html>